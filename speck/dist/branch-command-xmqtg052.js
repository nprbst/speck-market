#!/usr/bin/env bun
// @bun
import{a as v,b as R,c,d as u,e as t,f as n,g as Yq,h as d,i as e,j as Zq,k as _q,l as Uq,m as Vq,n as zq,o as Lq,p as i,q as r,r as Oq,s as a,t as Gq}from"./speck-v4perbmj.js";import{B as l,C as Qq,D as Wq,F as s,G as Xq,I as N,u as Eq,x as Tq}from"./paths-qqmkr5wb.js";import B from"path";import b from"fs/promises";var{$:I}=globalThis.Bun;async function jq(q){try{let H=(await I`git -C ${q} symbolic-ref --short HEAD 2>/dev/null || git -C ${q} rev-parse --short HEAD 2>/dev/null`.quiet()).text().trim();if(H&&/^\d{3}-.+$/.test(H)){let W=B.join(q,"specs",H);try{return await b.access(W),H}catch{}}let J=B.join(q,"specs"),Y=(await b.readdir(J)).filter((W)=>/^\d{3}-.+$/.test(W));if(Y.length===0)return null;return Y.sort(),Y[Y.length-1]??null}catch{return null}}async function $q(){try{return(await I`which gh`.quiet()).exitCode===0}catch{return!1}}async function Dq(q,K,H){try{let J=await I`git -C ${H} log ${q}..${K} --format=%s%n%b`.quiet();if(J.exitCode!==0)return[];return J.stdout.toString().trim().split(`
`).filter((Q)=>Q.trim())}catch{return[]}}function Pq(q){let K=[/^wip/i,/^fix$/i,/^tmp/i,/^temp/i,/^test/i,/^update$/i,/^merge/i,/^rebase/i,/^\./],H=q.trim().toLowerCase();return!K.some((J)=>J.test(H))&&H.length>5}function Aq(q){if(q.length===0)return null;let K=q.filter((Q)=>Q.trim()&&Pq(Q));if(K.length===0)return null;let H=K[0]?.split(`
`)[0]??"Update",J=K.map((Q)=>`- ${Q.split(`
`)[0]}`).join(`
`);return{title:H,body:J}}async function vq(q,K,H){try{let Q=(await I`git -C ${H} diff ${q}...${K} --stat`.quiet()).stdout.toString().trim(),W=(await I`git -C ${H} diff ${q}...${K} --name-status`.quiet()).stdout.toString().trim().split(`
`).filter((U)=>U.trim()),X=`Update ${K} (${W.length} files changed)`,V=`## Changes

${Q}

## Files Modified
${W.map((U)=>`- ${U}`).join(`
`)}`;return{title:X,body:V}}catch{return{title:`Update ${K}`,body:"Changes made on this branch"}}}function wq(q,K,H){if(K)return K;return"main"}async function Mq(q,K,H,J,Q){if(Q?.context==="child"){if(!await Gq(J))return console.warn(`
\u26A0\uFE0F  WARNING: No remote configured for this repository.`),console.warn("Branch created locally. PR creation unavailable."),console.warn(`
To configure remote:`),console.warn("  git remote add origin <url>"),console.warn(`  git push -u origin <branch-name>
`),null}if(!await $q())return null;let W=u(H,q),X;if(Q?.context==="child")X=await a(J)||"main";else X=wq(q,W?.baseBranch||null,J);let V=await Dq(X,q,J);if(V.length===0)return null;let U=Aq(V);if(!U)U=await vq(X,q,J);let L=U.title;if(Q?.childRepoName)L=`[${Q.childRepoName}] ${U.title}`;return{title:L,body:U.body,prBase:X}}function o(q,K,H){let J=q.branches.filter((W)=>W.specId===K),Q=J.filter((W)=>!J.some((X)=>X.name===W.baseBranch));function Y(W,X,V){let U=J.find((O)=>O.name===W);if(!U)return;let L="  ".repeat(X),Z=X===0?"":V?"\u2514\u2500 ":"\u251C\u2500 ",z=W===H?" (current)":"",E=U.status!=="active"?` (${U.status}${U.pr?`, PR #${U.pr}`:""})`:"";console.log(`${L}${Z}${W}${z}${E}`);let P=J.filter((O)=>O.baseBranch===W);P.forEach((O,j)=>{Y(O.name,X+1,j===P.length-1)})}Q.forEach((W)=>{console.log(`  ${W.baseBranch}`),Y(W.name,1,!0)})}function Jq(q,K){let H=K;while(H){let J=q.branches.find((Q)=>Q.name===H.baseBranch);if(!J)return H.baseBranch;H=J}return"main"}async function kq(q){let K=q.findIndex((_)=>!_.startsWith("--"));if(K===-1)throw Error("Branch name required: /speck.branch create <name> [--base <base>]");let H=q[K],J=q.indexOf("--base"),Q=q.indexOf("--spec"),Y=q.includes("--skip-pr-prompt"),W=q.includes("--create-pr"),X=q.indexOf("--title"),V=q.indexOf("--description"),U=q.indexOf("--pr-base"),L=q.includes("--json"),Z=await N(),z=Z.REPO_ROOT,E=await l(),P=await Qq(),O=null;if(E.mode==="multi-repo"){let _=P?"child":"root",k=P?await jq(E.speckRoot):null,y=P?await Wq(E.repoRoot,E.speckRoot):null;O={...E,context:_,parentSpecId:k,childRepoName:y}}let j="";try{j=await i(z)}catch(_){j=""}let D,F=J!==-1?q[J+1]:void 0;if(F)D=F;else{if(!j)return console.error("Error: No commits in repository. Cannot determine current branch."),console.error("Please create an initial commit first, or specify --base explicitly."),1;D=j,console.log(`Defaulting base to current branch: ${D}`)}let T=Q!==-1&&q[Q+1]?q[Q+1]:null;if(!await Xq(H))throw Error(`Invalid branch name: '${H}'. Must be a valid git ref name.`);try{await Oq(D,z)}catch(_){if(_ instanceof Error)throw Error(_.message);throw _}if(!T){if(Z.FEATURE_DIR&&Z.FEATURE_DIR.includes("/specs/")){let _=Z.FEATURE_DIR.match(/\/specs\/([^/]+)/);if(_&&_[1]){if(T=_[1],!L)console.log(`Auto-detected spec: ${T}`)}}if(!T)throw Error(`Could not auto-detect spec ID. Please specify with --spec flag:
  /speck.branch create <name> [--base <base>] --spec <spec-id>`)}let G=T,A=O?E.specsDir:B.join(z,"specs"),w=B.join(A,G);try{await b.access(w)}catch{throw Error(`Spec directory not found: specs/${G}/`)}if((await I`git -C ${z} status --porcelain`.quiet()).stdout.toString().split(`
`).filter((_)=>_.trim().length>0).filter((_)=>!_.includes(".speck/branches.json")).length>0){console.log(`
${"\u26A0".repeat(30)}`),console.log(`\u26A0 Warning: Current branch '${j}' has uncommitted changes`),console.log(`${"\u26A0".repeat(30)}
`);let _=await I`git -C ${z} diff --stat`.quiet();throw console.log("Changed files:"),console.log(_.stdout.toString()),console.log(`
Options:`),console.log("  1. Commit changes now (recommended)"),console.log("  2. Stash changes (saves for later)"),console.log("  3. Carry changes to new branch (creates new branch with changes)"),console.log("  4. Abort branch creation"),console.log(`
Choose an option or run one of these commands first:`),console.log('  git add . && git commit -m "message"  # Commit changes'),console.log("  git stash                              # Stash changes"),console.log(`
Then re-run: /speck.branch create `+q.join(" ")),Error("Uncommitted changes detected. Please commit or stash changes before creating a new branch.")}let $=await v(z);if(!Y&&!W){let _=await Mq(j,D,$,z,O);if(_){if(L){let k={branch:j,title:_.title,body:_.body,base:_.prBase};console.log(JSON.stringify(k))}else{let k={type:"pr-suggestion",branch:j,suggestedTitle:_.title,suggestedDescription:_.body,suggestedBase:_.prBase,newBranch:H};console.error(JSON.stringify(k)),console.log(`
${"=".repeat(60)}`),console.log(`\uD83D\uDCA1 PR Opportunity: Create PR for '${j}' before switching`),console.log(`${"=".repeat(60)}`),console.log(`
Suggested PR details:`),console.log(`  Title: ${_.title}`),console.log(`  Base: ${_.prBase}`),console.log(`
Description:`),console.log(_.body.split(`
`).map((y)=>`  ${y}`).join(`
`)),console.log(`
${"-".repeat(60)}`),console.log("Option 1: Create PR with gh CLI:"),console.log(`  gh pr create --base ${_.prBase} --title "${_.title}" --body "${_.body.replace(/"/g,"\\\"")}"`),console.log(`
Option 2: Create PR via GitHub URL:`),console.log(`  https://github.com/OWNER/REPO/compare/${_.prBase}...${j}?expand=1&title=${encodeURIComponent(_.title)}`),console.log(`
Option 3: Skip and create branch without PR`),console.log(`${"=".repeat(60)}
`)}return 2}}if(W){let _=X!==-1&&q[X+1]?q[X+1]:null,k=V!==-1&&q[V+1]?q[V+1]:null,y=U!==-1&&q[U+1]?q[U+1]:null;if(!_||!k||!y)throw Error("--create-pr requires --title, --description, and --pr-base flags");console.log(`Creating PR for '${j}'...`);try{let x=await I`gh pr create --base ${y} --title ${_} --body ${k}`.quiet();if(x.exitCode!==0)throw Error(`gh pr create failed: ${x.stderr.toString()}`);let g=x.stdout.toString().match(/\/pull\/(\d+)/),p=g&&g[1]?parseInt(g[1],10):null;if(p){if(console.log(`\u2713 Created PR #${p} for '${j}'`),u($,j))$=n($,j,"submitted",p),await R(z,$)}else console.log(`\u2713 PR created for '${j}' (could not parse PR number from output)`)}catch(x){let C=x instanceof Error?x.message:String(x);if(C.includes("gh: command not found")||C.includes("not found"))return console.error(`
\u274C Error: GitHub CLI (gh) is not installed`),console.error(`
To install gh:`),console.error("  brew install gh           # macOS"),console.error("  sudo apt install gh       # Ubuntu/Debian"),console.error("  winget install GitHub.cli # Windows"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${H} --skip-pr-prompt`),1;if(C.includes("authentication")||C.includes("401"))return console.error(`
\u274C Error: GitHub CLI is not authenticated`),console.error(`
To authenticate:`),console.error("  gh auth login"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${H} --skip-pr-prompt`),1;return console.error(`
\u274C Error creating PR: ${C}`),console.error(`
You can:`),console.error("  1. Check your network connection and try again"),console.error("  2. Create the PR manually via GitHub web UI"),console.error("  3. Use --skip-pr-prompt to create branch without PR"),1}}let M=new Date().toISOString(),qq={name:H,specId:G,baseBranch:D,status:"active",pr:null,createdAt:M,updatedAt:M,...O?.parentSpecId?{parentSpecId:O.parentSpecId}:{}},Hq=d(H,{...$,branches:[...$.branches,qq]});if(Hq)throw Error(`Circular dependency detected: ${Hq.join(" \u2192 ")}`);if($=t($,qq),await Uq(H,D,z),await Lq(H,z),await R(z,$),!L)console.log(`\u2713 Created stacked branch '${H}'`),console.log(`\u2713 Based on: ${D}`),console.log(`\u2713 Linked to spec: ${G}`),console.log(),console.log("Branch stack:"),o($,G,H),console.log(),console.log("Next steps:"),console.log("  - Implement feature on this branch"),console.log(`  - Run /speck.tasks --branch ${H} to generate tasks`),console.log(`  - When ready: /speck.branch create <next-branch> --base ${H}`)}async function Iq(q){let K=q.includes("--all"),H=await N(),J=await l(),Q=H.REPO_ROOT;if(K&&J.mode==="multi-repo"){await fq(J.speckRoot,Q);return}let Y=await v(Q);if(Y.branches.length===0){console.log("No stacked branches found."),console.log("Create your first stacked branch with:"),console.log("  /speck.branch create <name> --base main");return}let W="";try{W=await i(Q)}catch(X){W=""}if(K){let X=Object.keys(Y.specIndex);for(let V of X)console.log(`
Spec: ${V}`),console.log("Branch Stack:"),o(Y,V,W);console.log(`
Total: ${Y.branches.length} branches across ${X.length} specs`)}else{let X=c(Y,W);if(!X){console.log("Current branch is not in stacked mode."),console.log("Use --all to see all stacked branches.");return}console.log(`Spec: ${X}
`),console.log("Branch Stack:"),o(Y,X,W),console.log(`
Legend:`),console.log("  (current) = checked out branch"),console.log("  (active) = development in progress"),console.log("  (submitted) = PR open for review")}}async function fq(q,K){let H=await e(q,K);if(console.log(`Branch List (All Repositories)
`),H.rootRepo&&H.rootRepo.branchCount>0){console.log("Root Repository:"),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let Q=await v(q);for(let Y of Q.branches){let W=Y.pr?String(Y.pr).padEnd(5):"-".padEnd(5);console.log(`${Y.name.padEnd(18)} ${Y.baseBranch.padEnd(14)} ${Y.specId.padEnd(23)} ${W} ${Y.status}`)}console.log("")}let J=Array.from(H.childRepos.keys()).sort();for(let Q of J){let Y=H.childRepos.get(Q);console.log(`Child: ${Q}`),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let W=await v(Y.repoPath);for(let X of W.branches){let V=X.pr?String(X.pr).padEnd(5):"-".padEnd(5);console.log(`${X.name.padEnd(18)} ${X.baseBranch.padEnd(14)} ${X.specId.padEnd(23)} ${V} ${X.status}`)}console.log("")}if(J.length===0&&!H.rootRepo)console.log("No branches found in any repository.")}async function xq(q=[]){let K=q.includes("--all"),H=await N(),J=await l(),Q=H.REPO_ROOT;if(K&&J.mode==="multi-repo"){await Nq(J.speckRoot,Q);return}let Y=await v(Q),W="";try{W=await i(Q)}catch(Z){W=""}let X=c(Y,W);if(!X){console.log("Current branch is not in stacked mode.");return}let V=Y.branches.filter((Z)=>Z.specId===X),U=0;console.log(`Spec: ${X}
`);for(let Z of V){if(!await r(Z.name,Q)){console.log(`${Z.name} (${Z.status}${Z.pr?`, PR #${Z.pr}`:""})`),console.log("  \u26A0 ORPHANED: Branch no longer exists in git"),console.log(`  \u2192 Run: /speck.branch delete ${Z.name} (cleanup metadata)`),U++;continue}let E=await Vq(Z.name,Z.baseBranch,Q);if(E&&Z.status!=="merged")console.log(`${Z.name} (${Z.status}${Z.pr?`, PR #${Z.pr}`:""})`),console.log(`  \u26A0 MERGED: Branch merged into base but status is '${Z.status}'`),console.log(`  \u2192 Run: /speck.branch update ${Z.name} --status merged`),U++;if(E&&Z.status==="merged"){let P=V.filter((O)=>O.baseBranch===Z.name&&O.status!=="merged");if(P.length>0)for(let O of P)console.log(`
${O.name} (${O.status})`),console.log(`  \u26A0 REBASE NEEDED: Base branch '${Z.name}' has been merged`),console.log(`  \u2192 Run: git rebase ${Jq(Y,Z)}`),console.log(`  \u2192 Update base: /speck.branch update ${O.name} --base ${Jq(Y,Z)}`),U++}}if(U===0)console.log("\u2713 Branch stack is healthy - no warnings");else console.log(`
\u26A0 ${U} warning(s) found`);let L=await s();if(L.context==="child"&&Y.branches.length>0)try{let{findChildRepos:Z}=await import("./paths-qqmkr5wb.js"),z=L.speckRoot||"";if(!(await Z(z)).includes(Q))console.log(`
\u26A0 Orphaned tracking detected:`),console.log(`  ${Y.branches.length} branch(es) tracked but repo unlinked from parent spec`),console.log(`  Parent: ${z}`),console.log("  Fix: Re-link with /speck.link or archive .speck/branches.json")}catch{}}async function Nq(q,K){let H=await e(q,K);if(console.log(`Branch Status (All Repositories)
`),H.rootRepo&&H.rootRepo.branchCount>0)console.log("Root Repository:"),await Kq(q,H.rootRepo),console.log("");let J=Array.from(H.childRepos.keys()).sort();for(let Q of J){let Y=H.childRepos.get(Q);console.log(`Child: ${Q}`),await Kq(Y.repoPath,Y),console.log("")}if(J.length===0&&!H.rootRepo)console.log("No branches found in any repository.")}async function Kq(q,K){let H=await v(q),J=[];if(K.statusCounts.active>0)J.push(`${K.statusCounts.active} active`);if(K.statusCounts.submitted>0)J.push(`${K.statusCounts.submitted} submitted`);if(K.statusCounts.merged>0)J.push(`${K.statusCounts.merged} merged`);if(K.statusCounts.abandoned>0)J.push(`${K.statusCounts.abandoned} abandoned`);if(J.length>0)console.log(`  Total: ${K.branchCount} branches (${J.join(", ")})`);console.log("  Dependency Tree:");for(let Q of K.chains)if(Q.branches.length>0)Fq(Q.branches,H)}function Fq(q,K){q.forEach((H,J)=>{let Q=K.branches.find((X)=>X.name===H);if(!Q)return;let W=`${J===0?"    \u2514\u2500":"       \u2514\u2500"} ${H}`;if(Q.pr)W+=` (${Q.status}, PR #${Q.pr})`;else if(Q.status!=="active")W+=` (${Q.status})`;console.log(W)})}async function Sq(q){let K=q[0];if(!K)throw Error("Branch name required: /speck.branch update <name> [options]");let H=q.indexOf("--status"),J=q.indexOf("--pr"),Q=q.indexOf("--base"),W=(await N()).REPO_ROOT,X=await v(W);if(!u(X,K))throw Error(`Branch '${K}' not found in mapping`);if(H!==-1){let U=q[H+1];if(!U)throw Error("--status flag requires a value");let L=U;if(!["active","submitted","merged","abandoned"].includes(L))throw Error(`Invalid status: '${L}'. Must be: active, submitted, merged, or abandoned`);let Z=J!==-1&&q[J+1]?parseInt(q[J+1],10):void 0;X=n(X,K,L,Z)}if(Q!==-1){let U=q[Q+1];if(!U)throw Error("--base flag requires a branch name");if(!await r(U,W))throw Error(`Base branch '${U}' does not exist`);let Z=X.branches.map((E)=>E.name===K?{...E,baseBranch:U,updatedAt:new Date().toISOString()}:E),z=d(K,{...X,branches:Z});if(z)throw Error(`Cannot update base: circular dependency detected: ${z.join(" \u2192 ")}`);X={...X,branches:Z}}await R(W,X),console.log(`\u2713 Updated branch '${K}'`)}async function yq(q){let K=q[0];if(!K)throw Error("Branch name required: /speck.branch delete <name>");let H=q.includes("--force"),Q=(await N()).REPO_ROOT,Y=await v(Q),W=Y.branches.filter((V)=>V.baseBranch===K);if(W.length>0&&!H)throw console.error(`Error: Branch '${K}' has child branches:`),W.forEach((V)=>console.error(`  - ${V.name}`)),console.error(`
Use --force to delete anyway (will orphan children)`),Error("Branch has children");let X=Yq(Y,K);await R(Q,X),console.log(`\u2713 Removed branch '${K}' from metadata`),console.log(),console.log("Note: Git branch still exists. To delete it, run:"),console.log(`  git branch -D ${K}`)}async function Cq(q){let K=q.indexOf("--pattern"),H=K!==-1?q[K+1]:void 0,J=q.indexOf("--batch"),Q=J!==-1,W=(await N()).REPO_ROOT,X=await s(),V=X.context==="child"?await jq(X.speckRoot):null,U=await zq(W,H);if(U.length===0){console.log("No branches found to import.");return}let L=await v(W),Z=await a(W),z=U.filter(({name:T})=>!L.branches.some((S)=>S.name===T)&&T!==Z);if(z.length===0){console.log("All branches are already in stacked mode.");return}let E=X.specsDir,O=(await b.readdir(E)).filter((T)=>/^\d{3}-/.test(T));if(!Q){let T=z.map(({name:G,upstream:A})=>{let w="main";if(A){let f=A.replace(/^origin\//,"");if(f&&f!==G)w=f}return{name:G,upstream:A||null,inferredBase:w}});return console.error(JSON.stringify({type:"import-prompt",branches:T,availableSpecs:O})),console.log(`Found ${z.length} branches to import:
`),T.forEach((G)=>{console.log(`\u2022 ${G.name}`),console.log(`  Upstream: ${G.upstream||"(none)"}`),console.log(`  Inferred base: ${G.inferredBase}`),console.log()}),console.log(`Available specs: ${O.join(", ")}
`),console.log("Agent interaction required: Map each branch to a spec."),3}let j=q.slice(J+1),D=0,F=0;for(let T of j){let S=T.split(":"),G=S[0],A=S[1];if(!G||!A){console.log(`\u26A0 Invalid mapping format: ${T}`);continue}if(A==="skip"){console.log(`\u2298 Skipped ${G}`),F++;continue}let w=z.find((M)=>M.name===G);if(!w){console.log(`\u26A0 Branch not found: ${G}`);continue}let f="main";if(w.upstream){let M=w.upstream.replace(/^origin\//,"");if(M&&M!==w.name)f=M}let m=new Date().toISOString(),h={name:G,specId:A,baseBranch:f,status:"active",pr:null,createdAt:m,updatedAt:m,...V&&{parentSpecId:V}},$=d(G,{...L,branches:[...L.branches,h]});if($){console.log(`\u26A0 Skipped ${G} (would create cycle: ${$.join(" \u2192 ")})`),F++;continue}L=t(L,h),console.log(`\u2713 Imported ${G} \u2192 ${A}`),D++}await R(W,L),console.log(`
\u2713 Import complete:`),console.log(`  Imported: ${D}`),console.log(`  Skipped: ${F}`)}async function hq(q=process.argv.slice(2)){if(process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: This script is deprecated. Use 'speck-branch' virtual command or 'bun .speck/scripts/speck.ts branch' instead.\x1B[0m
`);if(q.length===0)return console.log("Usage: /speck.branch <command> [args]"),console.log(),console.log("Commands:"),console.log("  create <name> [--base <base>] [--spec <spec-id>]"),console.log("  list [--all]"),console.log("  status"),console.log("  update <name> [--status <status>] [--pr <number>] [--base <branch>]"),console.log("  delete <name> [--force]"),console.log("  import [--pattern <pattern>]"),1;let K=q[0],H=q.slice(1);try{let J=void 0;switch(K){case"create":J=await kq(H);break;case"list":J=await Iq(H);break;case"status":J=await xq(H);break;case"update":J=await Sq(H);break;case"delete":J=await yq(H);break;case"import":J=await Cq(H);break;default:return console.error(`Unknown command: ${K}`),console.error("Run '/speck.branch' for usage"),1}if(typeof J==="number")return J}catch(J){if(J instanceof _q||J instanceof Zq)return console.error(`Error: ${J.message}`),1;if(J instanceof Error){if(console.error(`Error: ${J.message}`),J.stack)console.error(`Stack trace: ${J.stack}`);return 1}return console.error(`Unknown error: ${String(J)}`),1}return 0}export{hq as main};
