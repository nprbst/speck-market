#!/usr/bin/env bun
// @bun
var bQ=Object.create;var{getPrototypeOf:ZQ,defineProperty:x3,getOwnPropertyNames:xQ}=Object;var yQ=Object.prototype.hasOwnProperty;var E_=(q,_,Q)=>{Q=q!=null?bQ(ZQ(q)):{};let X=_||!q||!q.__esModule?x3(Q,"default",{value:q,enumerable:!0}):Q;for(let $ of xQ(q))if(!yQ.call(X,$))x3(X,$,{get:()=>q[$],enumerable:!0});return X};var Fq=(q,_)=>()=>(_||q((_={exports:{}}).exports,_),_.exports);var A_=(q,_)=>{for(var Q in _)x3(q,Q,{get:_[Q],enumerable:!0,configurable:!0,set:(X)=>_[Q]=()=>X})};var gQ=(q,_)=>()=>(q&&(_=q(q=0)),_);var Zq=import.meta.require;var J3=Fq((hQ)=>{class y3 extends Error{constructor(q,_,Q){super(Q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=_,this.exitCode=q,this.nestedError=void 0}}class B_ extends y3{constructor(q){super(1,"commander.invalidArgument",q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}hQ.CommanderError=y3;hQ.InvalidArgumentError=B_});var A3=Fq((cQ)=>{var{InvalidArgumentError:mQ}=J3();class D_{constructor(q,_){switch(this.description=_||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,q[0]){case"<":this.required=!0,this._name=q.slice(1,-1);break;case"[":this.required=!1,this._name=q.slice(1,-1);break;default:this.required=!0,this._name=q;break}if(this._name.endsWith("..."))this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_collectValue(q,_){if(_===this.defaultValue||!Array.isArray(_))return[q];return _.push(q),_}default(q,_){return this.defaultValue=q,this.defaultValueDescription=_,this}argParser(q){return this.parseArg=q,this}choices(q){return this.argChoices=q.slice(),this.parseArg=(_,Q)=>{if(!this.argChoices.includes(_))throw new mQ(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue(_,Q);return _},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function dQ(q){let _=q.name()+(q.variadic===!0?"...":"");return q.required?"<"+_+">":"["+_+"]"}cQ.Argument=D_;cQ.humanReadableArgName=dQ});var g3=Fq((oQ)=>{var{humanReadableArgName:nQ}=A3();class O_{constructor(){this.helpWidth=void 0,this.minWidthToWrap=40,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}prepareContext(q){this.helpWidth=this.helpWidth??q.helpWidth??80}visibleCommands(q){let _=q.commands.filter((X)=>!X._hidden),Q=q._getHelpCommand();if(Q&&!Q._hidden)_.push(Q);if(this.sortSubcommands)_.sort((X,$)=>{return X.name().localeCompare($.name())});return _}compareOptions(q,_){let Q=(X)=>{return X.short?X.short.replace(/^-/,""):X.long.replace(/^--/,"")};return Q(q).localeCompare(Q(_))}visibleOptions(q){let _=q.options.filter((X)=>!X.hidden),Q=q._getHelpOption();if(Q&&!Q.hidden){let X=Q.short&&q._findOption(Q.short),$=Q.long&&q._findOption(Q.long);if(!X&&!$)_.push(Q);else if(Q.long&&!$)_.push(q.createOption(Q.long,Q.description));else if(Q.short&&!X)_.push(q.createOption(Q.short,Q.description))}if(this.sortOptions)_.sort(this.compareOptions);return _}visibleGlobalOptions(q){if(!this.showGlobalOptions)return[];let _=[];for(let Q=q.parent;Q;Q=Q.parent){let X=Q.options.filter(($)=>!$.hidden);_.push(...X)}if(this.sortOptions)_.sort(this.compareOptions);return _}visibleArguments(q){if(q._argsDescription)q.registeredArguments.forEach((_)=>{_.description=_.description||q._argsDescription[_.name()]||""});if(q.registeredArguments.find((_)=>_.description))return q.registeredArguments;return[]}subcommandTerm(q){let _=q.registeredArguments.map((Q)=>nQ(Q)).join(" ");return q._name+(q._aliases[0]?"|"+q._aliases[0]:"")+(q.options.length?" [options]":"")+(_?" "+_:"")}optionTerm(q){return q.flags}argumentTerm(q){return q.name()}longestSubcommandTermLength(q,_){return _.visibleCommands(q).reduce((Q,X)=>{return Math.max(Q,this.displayWidth(_.styleSubcommandTerm(_.subcommandTerm(X))))},0)}longestOptionTermLength(q,_){return _.visibleOptions(q).reduce((Q,X)=>{return Math.max(Q,this.displayWidth(_.styleOptionTerm(_.optionTerm(X))))},0)}longestGlobalOptionTermLength(q,_){return _.visibleGlobalOptions(q).reduce((Q,X)=>{return Math.max(Q,this.displayWidth(_.styleOptionTerm(_.optionTerm(X))))},0)}longestArgumentTermLength(q,_){return _.visibleArguments(q).reduce((Q,X)=>{return Math.max(Q,this.displayWidth(_.styleArgumentTerm(_.argumentTerm(X))))},0)}commandUsage(q){let _=q._name;if(q._aliases[0])_=_+"|"+q._aliases[0];let Q="";for(let X=q.parent;X;X=X.parent)Q=X.name()+" "+Q;return Q+_+" "+q.usage()}commandDescription(q){return q.description()}subcommandDescription(q){return q.summary()||q.description()}optionDescription(q){let _=[];if(q.argChoices)_.push(`choices: ${q.argChoices.map((Q)=>JSON.stringify(Q)).join(", ")}`);if(q.defaultValue!==void 0){if(q.required||q.optional||q.isBoolean()&&typeof q.defaultValue==="boolean")_.push(`default: ${q.defaultValueDescription||JSON.stringify(q.defaultValue)}`)}if(q.presetArg!==void 0&&q.optional)_.push(`preset: ${JSON.stringify(q.presetArg)}`);if(q.envVar!==void 0)_.push(`env: ${q.envVar}`);if(_.length>0){let Q=`(${_.join(", ")})`;if(q.description)return`${q.description} ${Q}`;return Q}return q.description}argumentDescription(q){let _=[];if(q.argChoices)_.push(`choices: ${q.argChoices.map((Q)=>JSON.stringify(Q)).join(", ")}`);if(q.defaultValue!==void 0)_.push(`default: ${q.defaultValueDescription||JSON.stringify(q.defaultValue)}`);if(_.length>0){let Q=`(${_.join(", ")})`;if(q.description)return`${q.description} ${Q}`;return Q}return q.description}formatItemList(q,_,Q){if(_.length===0)return[];return[Q.styleTitle(q),..._,""]}groupItems(q,_,Q){let X=new Map;return q.forEach(($)=>{let J=Q($);if(!X.has(J))X.set(J,[])}),_.forEach(($)=>{let J=Q($);if(!X.has(J))X.set(J,[]);X.get(J).push($)}),X}formatHelp(q,_){let Q=_.padWidth(q,_),X=_.helpWidth??80;function $(z,M){return _.formatItem(z,Q,M,_)}let J=[`${_.styleTitle("Usage:")} ${_.styleUsage(_.commandUsage(q))}`,""],Y=_.commandDescription(q);if(Y.length>0)J=J.concat([_.boxWrap(_.styleCommandDescription(Y),X),""]);let H=_.visibleArguments(q).map((z)=>{return $(_.styleArgumentTerm(_.argumentTerm(z)),_.styleArgumentDescription(_.argumentDescription(z)))});if(J=J.concat(this.formatItemList("Arguments:",H,_)),this.groupItems(q.options,_.visibleOptions(q),(z)=>z.helpGroupHeading??"Options:").forEach((z,M)=>{let E=z.map((v)=>{return $(_.styleOptionTerm(_.optionTerm(v)),_.styleOptionDescription(_.optionDescription(v)))});J=J.concat(this.formatItemList(M,E,_))}),_.showGlobalOptions){let z=_.visibleGlobalOptions(q).map((M)=>{return $(_.styleOptionTerm(_.optionTerm(M)),_.styleOptionDescription(_.optionDescription(M)))});J=J.concat(this.formatItemList("Global Options:",z,_))}return this.groupItems(q.commands,_.visibleCommands(q),(z)=>z.helpGroup()||"Commands:").forEach((z,M)=>{let E=z.map((v)=>{return $(_.styleSubcommandTerm(_.subcommandTerm(v)),_.styleSubcommandDescription(_.subcommandDescription(v)))});J=J.concat(this.formatItemList(M,E,_))}),J.join(`
`)}displayWidth(q){return S_(q).length}styleTitle(q){return q}styleUsage(q){return q.split(" ").map((_)=>{if(_==="[options]")return this.styleOptionText(_);if(_==="[command]")return this.styleSubcommandText(_);if(_[0]==="["||_[0]==="<")return this.styleArgumentText(_);return this.styleCommandText(_)}).join(" ")}styleCommandDescription(q){return this.styleDescriptionText(q)}styleOptionDescription(q){return this.styleDescriptionText(q)}styleSubcommandDescription(q){return this.styleDescriptionText(q)}styleArgumentDescription(q){return this.styleDescriptionText(q)}styleDescriptionText(q){return q}styleOptionTerm(q){return this.styleOptionText(q)}styleSubcommandTerm(q){return q.split(" ").map((_)=>{if(_==="[options]")return this.styleOptionText(_);if(_[0]==="["||_[0]==="<")return this.styleArgumentText(_);return this.styleSubcommandText(_)}).join(" ")}styleArgumentTerm(q){return this.styleArgumentText(q)}styleOptionText(q){return q}styleArgumentText(q){return q}styleSubcommandText(q){return q}styleCommandText(q){return q}padWidth(q,_){return Math.max(_.longestOptionTermLength(q,_),_.longestGlobalOptionTermLength(q,_),_.longestSubcommandTermLength(q,_),_.longestArgumentTermLength(q,_))}preformatted(q){return/\n[^\S\r\n]/.test(q)}formatItem(q,_,Q,X){let J=" ".repeat(2);if(!Q)return J+q;let Y=q.padEnd(_+q.length-X.displayWidth(q)),H=2,G=(this.helpWidth??80)-_-H-2,z;if(G<this.minWidthToWrap||X.preformatted(Q))z=Q;else z=X.boxWrap(Q,G).replace(/\n/g,`
`+" ".repeat(_+H));return J+Y+" ".repeat(H)+z.replace(/\n/g,`
${J}`)}boxWrap(q,_){if(_<this.minWidthToWrap)return q;let Q=q.split(/\r\n|\n/),X=/[\s]*[^\s]+/g,$=[];return Q.forEach((J)=>{let Y=J.match(X);if(Y===null){$.push("");return}let H=[Y.shift()],W=this.displayWidth(H[0]);Y.forEach((G)=>{let z=this.displayWidth(G);if(W+z<=_){H.push(G),W+=z;return}$.push(H.join(""));let M=G.trimStart();H=[M],W=this.displayWidth(M)}),$.push(H.join(""))}),$.join(`
`)}}function S_(q){let _=/\x1b\[\d*(;\d*)*m/g;return q.replace(_,"")}oQ.Help=O_;oQ.stripColor=S_});var h3=Fq((eQ)=>{var{InvalidArgumentError:aQ}=J3();class N_{constructor(q,_){this.flags=q,this.description=_||"",this.required=q.includes("<"),this.optional=q.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(q),this.mandatory=!1;let Q=tQ(q);if(this.short=Q.shortFlag,this.long=Q.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0,this.helpGroupHeading=void 0}default(q,_){return this.defaultValue=q,this.defaultValueDescription=_,this}preset(q){return this.presetArg=q,this}conflicts(q){return this.conflictsWith=this.conflictsWith.concat(q),this}implies(q){let _=q;if(typeof q==="string")_={[q]:!0};return this.implied=Object.assign(this.implied||{},_),this}env(q){return this.envVar=q,this}argParser(q){return this.parseArg=q,this}makeOptionMandatory(q=!0){return this.mandatory=!!q,this}hideHelp(q=!0){return this.hidden=!!q,this}_collectValue(q,_){if(_===this.defaultValue||!Array.isArray(_))return[q];return _.push(q),_}choices(q){return this.argChoices=q.slice(),this.parseArg=(_,Q)=>{if(!this.argChoices.includes(_))throw new aQ(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue(_,Q);return _},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){if(this.negate)return F_(this.name().replace(/^no-/,""));return F_(this.name())}helpGroup(q){return this.helpGroupHeading=q,this}is(q){return this.short===q||this.long===q}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class v_{constructor(q){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,q.forEach((_)=>{if(_.negate)this.negativeOptions.set(_.attributeName(),_);else this.positiveOptions.set(_.attributeName(),_)}),this.negativeOptions.forEach((_,Q)=>{if(this.positiveOptions.has(Q))this.dualOptions.add(Q)})}valueFromOption(q,_){let Q=_.attributeName();if(!this.dualOptions.has(Q))return!0;let X=this.negativeOptions.get(Q).presetArg,$=X!==void 0?X:!1;return _.negate===($===q)}}function F_(q){return q.split("-").reduce((_,Q)=>{return _+Q[0].toUpperCase()+Q.slice(1)})}function tQ(q){let _,Q,X=/^-[^-]$/,$=/^--[^-]/,J=q.split(/[ |,]+/).concat("guard");if(X.test(J[0]))_=J.shift();if($.test(J[0]))Q=J.shift();if(!_&&X.test(J[0]))_=J.shift();if(!_&&$.test(J[0]))_=Q,Q=J.shift();if(J[0].startsWith("-")){let Y=J[0],H=`option creation failed due to '${Y}' in option flags '${q}'`;if(/^-[^-][^-]/.test(Y))throw Error(`${H}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);if(X.test(Y))throw Error(`${H}
- too many short flags`);if($.test(Y))throw Error(`${H}
- too many long flags`);throw Error(`${H}
- unrecognised flag format`)}if(_===void 0&&Q===void 0)throw Error(`option creation failed due to no flags found in '${q}'.`);return{shortFlag:_,longFlag:Q}}eQ.Option=N_;eQ.DualOptions=v_});var I_=Fq(($X)=>{function QX(q,_){if(Math.abs(q.length-_.length)>3)return Math.max(q.length,_.length);let Q=[];for(let X=0;X<=q.length;X++)Q[X]=[X];for(let X=0;X<=_.length;X++)Q[0][X]=X;for(let X=1;X<=_.length;X++)for(let $=1;$<=q.length;$++){let J=1;if(q[$-1]===_[X-1])J=0;else J=1;if(Q[$][X]=Math.min(Q[$-1][X]+1,Q[$][X-1]+1,Q[$-1][X-1]+J),$>1&&X>1&&q[$-1]===_[X-2]&&q[$-2]===_[X-1])Q[$][X]=Math.min(Q[$][X],Q[$-2][X-2]+1)}return Q[q.length][_.length]}function XX(q,_){if(!_||_.length===0)return"";_=Array.from(new Set(_));let Q=q.startsWith("--");if(Q)q=q.slice(2),_=_.map((Y)=>Y.slice(2));let X=[],$=3,J=0.4;if(_.forEach((Y)=>{if(Y.length<=1)return;let H=QX(q,Y),W=Math.max(q.length,Y.length);if((W-H)/W>J){if(H<$)$=H,X=[Y];else if(H===$)X.push(Y)}}),X.sort((Y,H)=>Y.localeCompare(H)),Q)X=X.map((Y)=>`--${Y}`);if(X.length>1)return`
(Did you mean one of ${X.join(", ")}?)`;if(X.length===1)return`
(Did you mean ${X[0]}?)`;return""}$X.suggestSimilar=XX});var k_=Fq((MX)=>{var YX=Zq("events").EventEmitter,l3=Zq("child_process"),$q=Zq("path"),B3=Zq("fs"),I=Zq("process"),{Argument:HX,humanReadableArgName:WX}=A3(),{CommanderError:u3}=J3(),{Help:GX,stripColor:zX}=g3(),{Option:R_,DualOptions:jX}=h3(),{suggestSimilar:T_}=I_();class d3 extends YX{constructor(q){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!1,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=q||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._savedState=null,this._outputConfiguration={writeOut:(_)=>I.stdout.write(_),writeErr:(_)=>I.stderr.write(_),outputError:(_,Q)=>Q(_),getOutHelpWidth:()=>I.stdout.isTTY?I.stdout.columns:void 0,getErrHelpWidth:()=>I.stderr.isTTY?I.stderr.columns:void 0,getOutHasColors:()=>m3()??(I.stdout.isTTY&&I.stdout.hasColors?.()),getErrHasColors:()=>m3()??(I.stderr.isTTY&&I.stderr.hasColors?.()),stripColor:(_)=>zX(_)},this._hidden=!1,this._helpOption=void 0,this._addImplicitHelpCommand=void 0,this._helpCommand=void 0,this._helpConfiguration={},this._helpGroupHeading=void 0,this._defaultCommandGroup=void 0,this._defaultOptionGroup=void 0}copyInheritedSettings(q){return this._outputConfiguration=q._outputConfiguration,this._helpOption=q._helpOption,this._helpCommand=q._helpCommand,this._helpConfiguration=q._helpConfiguration,this._exitCallback=q._exitCallback,this._storeOptionsAsProperties=q._storeOptionsAsProperties,this._combineFlagAndOptionalValue=q._combineFlagAndOptionalValue,this._allowExcessArguments=q._allowExcessArguments,this._enablePositionalOptions=q._enablePositionalOptions,this._showHelpAfterError=q._showHelpAfterError,this._showSuggestionAfterError=q._showSuggestionAfterError,this}_getCommandAndAncestors(){let q=[];for(let _=this;_;_=_.parent)q.push(_);return q}command(q,_,Q){let X=_,$=Q;if(typeof X==="object"&&X!==null)$=X,X=null;$=$||{};let[,J,Y]=q.match(/([^ ]+) *(.*)/),H=this.createCommand(J);if(X)H.description(X),H._executableHandler=!0;if($.isDefault)this._defaultCommandName=H._name;if(H._hidden=!!($.noHelp||$.hidden),H._executableFile=$.executableFile||null,Y)H.arguments(Y);if(this._registerCommand(H),H.parent=this,H.copyInheritedSettings(this),X)return this;return H}createCommand(q){return new d3(q)}createHelp(){return Object.assign(new GX,this.configureHelp())}configureHelp(q){if(q===void 0)return this._helpConfiguration;return this._helpConfiguration=q,this}configureOutput(q){if(q===void 0)return this._outputConfiguration;return this._outputConfiguration={...this._outputConfiguration,...q},this}showHelpAfterError(q=!0){if(typeof q!=="string")q=!!q;return this._showHelpAfterError=q,this}showSuggestionAfterError(q=!0){return this._showSuggestionAfterError=!!q,this}addCommand(q,_){if(!q._name)throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if(_=_||{},_.isDefault)this._defaultCommandName=q._name;if(_.noHelp||_.hidden)q._hidden=!0;return this._registerCommand(q),q.parent=this,q._checkForBrokenPassThrough(),this}createArgument(q,_){return new HX(q,_)}argument(q,_,Q,X){let $=this.createArgument(q,_);if(typeof Q==="function")$.default(X).argParser(Q);else $.default(Q);return this.addArgument($),this}arguments(q){return q.trim().split(/ +/).forEach((_)=>{this.argument(_)}),this}addArgument(q){let _=this.registeredArguments.slice(-1)[0];if(_?.variadic)throw Error(`only the last argument can be variadic '${_.name()}'`);if(q.required&&q.defaultValue!==void 0&&q.parseArg===void 0)throw Error(`a default value for a required argument is never used: '${q.name()}'`);return this.registeredArguments.push(q),this}helpCommand(q,_){if(typeof q==="boolean"){if(this._addImplicitHelpCommand=q,q&&this._defaultCommandGroup)this._initCommandGroup(this._getHelpCommand());return this}let Q=q??"help [command]",[,X,$]=Q.match(/([^ ]+) *(.*)/),J=_??"display help for command",Y=this.createCommand(X);if(Y.helpOption(!1),$)Y.arguments($);if(J)Y.description(J);if(this._addImplicitHelpCommand=!0,this._helpCommand=Y,q||_)this._initCommandGroup(Y);return this}addHelpCommand(q,_){if(typeof q!=="object")return this.helpCommand(q,_),this;return this._addImplicitHelpCommand=!0,this._helpCommand=q,this._initCommandGroup(q),this}_getHelpCommand(){if(this._addImplicitHelpCommand??(this.commands.length&&!this._actionHandler&&!this._findCommand("help"))){if(this._helpCommand===void 0)this.helpCommand(void 0,void 0);return this._helpCommand}return null}hook(q,_){let Q=["preSubcommand","preAction","postAction"];if(!Q.includes(q))throw Error(`Unexpected value for event passed to hook : '${q}'.
Expecting one of '${Q.join("', '")}'`);if(this._lifeCycleHooks[q])this._lifeCycleHooks[q].push(_);else this._lifeCycleHooks[q]=[_];return this}exitOverride(q){if(q)this._exitCallback=q;else this._exitCallback=(_)=>{if(_.code!=="commander.executeSubCommandAsync")throw _};return this}_exit(q,_,Q){if(this._exitCallback)this._exitCallback(new u3(q,_,Q));I.exit(q)}action(q){let _=(Q)=>{let X=this.registeredArguments.length,$=Q.slice(0,X);if(this._storeOptionsAsProperties)$[X]=this;else $[X]=this.opts();return $.push(this),q.apply(this,$)};return this._actionHandler=_,this}createOption(q,_){return new R_(q,_)}_callParseArg(q,_,Q,X){try{return q.parseArg(_,Q)}catch($){if($.code==="commander.invalidArgument"){let J=`${X} ${$.message}`;this.error(J,{exitCode:$.exitCode,code:$.code})}throw $}}_registerOption(q){let _=q.short&&this._findOption(q.short)||q.long&&this._findOption(q.long);if(_){let Q=q.long&&this._findOption(q.long)?q.long:q.short;throw Error(`Cannot add option '${q.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${Q}'
-  already used by option '${_.flags}'`)}this._initOptionGroup(q),this.options.push(q)}_registerCommand(q){let _=(X)=>{return[X.name()].concat(X.aliases())},Q=_(q).find((X)=>this._findCommand(X));if(Q){let X=_(this._findCommand(Q)).join("|"),$=_(q).join("|");throw Error(`cannot add command '${$}' as already have command '${X}'`)}this._initCommandGroup(q),this.commands.push(q)}addOption(q){this._registerOption(q);let _=q.name(),Q=q.attributeName();if(q.negate){let $=q.long.replace(/^--no-/,"--");if(!this._findOption($))this.setOptionValueWithSource(Q,q.defaultValue===void 0?!0:q.defaultValue,"default")}else if(q.defaultValue!==void 0)this.setOptionValueWithSource(Q,q.defaultValue,"default");let X=($,J,Y)=>{if($==null&&q.presetArg!==void 0)$=q.presetArg;let H=this.getOptionValue(Q);if($!==null&&q.parseArg)$=this._callParseArg(q,$,H,J);else if($!==null&&q.variadic)$=q._collectValue($,H);if($==null)if(q.negate)$=!1;else if(q.isBoolean()||q.optional)$=!0;else $="";this.setOptionValueWithSource(Q,$,Y)};if(this.on("option:"+_,($)=>{let J=`error: option '${q.flags}' argument '${$}' is invalid.`;X($,J,"cli")}),q.envVar)this.on("optionEnv:"+_,($)=>{let J=`error: option '${q.flags}' value '${$}' from env '${q.envVar}' is invalid.`;X($,J,"env")});return this}_optionEx(q,_,Q,X,$){if(typeof _==="object"&&_ instanceof R_)throw Error("To add an Option object use addOption() instead of option() or requiredOption()");let J=this.createOption(_,Q);if(J.makeOptionMandatory(!!q.mandatory),typeof X==="function")J.default($).argParser(X);else if(X instanceof RegExp){let Y=X;X=(H,W)=>{let G=Y.exec(H);return G?G[0]:W},J.default($).argParser(X)}else J.default(X);return this.addOption(J)}option(q,_,Q,X){return this._optionEx({},q,_,Q,X)}requiredOption(q,_,Q,X){return this._optionEx({mandatory:!0},q,_,Q,X)}combineFlagAndOptionalValue(q=!0){return this._combineFlagAndOptionalValue=!!q,this}allowUnknownOption(q=!0){return this._allowUnknownOption=!!q,this}allowExcessArguments(q=!0){return this._allowExcessArguments=!!q,this}enablePositionalOptions(q=!0){return this._enablePositionalOptions=!!q,this}passThroughOptions(q=!0){return this._passThroughOptions=!!q,this._checkForBrokenPassThrough(),this}_checkForBrokenPassThrough(){if(this.parent&&this._passThroughOptions&&!this.parent._enablePositionalOptions)throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)}storeOptionsAsProperties(q=!0){if(this.options.length)throw Error("call .storeOptionsAsProperties() before adding options");if(Object.keys(this._optionValues).length)throw Error("call .storeOptionsAsProperties() before setting option values");return this._storeOptionsAsProperties=!!q,this}getOptionValue(q){if(this._storeOptionsAsProperties)return this[q];return this._optionValues[q]}setOptionValue(q,_){return this.setOptionValueWithSource(q,_,void 0)}setOptionValueWithSource(q,_,Q){if(this._storeOptionsAsProperties)this[q]=_;else this._optionValues[q]=_;return this._optionValueSources[q]=Q,this}getOptionValueSource(q){return this._optionValueSources[q]}getOptionValueSourceWithGlobals(q){let _;return this._getCommandAndAncestors().forEach((Q)=>{if(Q.getOptionValueSource(q)!==void 0)_=Q.getOptionValueSource(q)}),_}_prepareUserArgs(q,_){if(q!==void 0&&!Array.isArray(q))throw Error("first parameter to parse must be array or undefined");if(_=_||{},q===void 0&&_.from===void 0){if(I.versions?.electron)_.from="electron";let X=I.execArgv??[];if(X.includes("-e")||X.includes("--eval")||X.includes("-p")||X.includes("--print"))_.from="eval"}if(q===void 0)q=I.argv;this.rawArgs=q.slice();let Q;switch(_.from){case void 0:case"node":this._scriptPath=q[1],Q=q.slice(2);break;case"electron":if(I.defaultApp)this._scriptPath=q[1],Q=q.slice(2);else Q=q.slice(1);break;case"user":Q=q.slice(0);break;case"eval":Q=q.slice(1);break;default:throw Error(`unexpected parse option { from: '${_.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",Q}parse(q,_){this._prepareForParse();let Q=this._prepareUserArgs(q,_);return this._parseCommand([],Q),this}async parseAsync(q,_){this._prepareForParse();let Q=this._prepareUserArgs(q,_);return await this._parseCommand([],Q),this}_prepareForParse(){if(this._savedState===null)this.saveStateBeforeParse();else this.restoreStateBeforeParse()}saveStateBeforeParse(){this._savedState={_name:this._name,_optionValues:{...this._optionValues},_optionValueSources:{...this._optionValueSources}}}restoreStateBeforeParse(){if(this._storeOptionsAsProperties)throw Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);this._name=this._savedState._name,this._scriptPath=null,this.rawArgs=[],this._optionValues={...this._savedState._optionValues},this._optionValueSources={...this._savedState._optionValueSources},this.args=[],this.processedArgs=[]}_checkForMissingExecutable(q,_,Q){if(B3.existsSync(q))return;let X=_?`searched for local subcommand relative to directory '${_}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",$=`'${q}' does not exist
 - if '${Q}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${X}`;throw Error($)}_executeSubCommand(q,_){_=_.slice();let Q=!1,X=[".js",".ts",".tsx",".mjs",".cjs"];function $(G,z){let M=$q.resolve(G,z);if(B3.existsSync(M))return M;if(X.includes($q.extname(z)))return;let E=X.find((v)=>B3.existsSync(`${M}${v}`));if(E)return`${M}${E}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let J=q._executableFile||`${this._name}-${q._name}`,Y=this._executableDir||"";if(this._scriptPath){let G;try{G=B3.realpathSync(this._scriptPath)}catch{G=this._scriptPath}Y=$q.resolve($q.dirname(G),Y)}if(Y){let G=$(Y,J);if(!G&&!q._executableFile&&this._scriptPath){let z=$q.basename(this._scriptPath,$q.extname(this._scriptPath));if(z!==this._name)G=$(Y,`${z}-${q._name}`)}J=G||J}Q=X.includes($q.extname(J));let H;if(I.platform!=="win32")if(Q)_.unshift(J),_=P_(I.execArgv).concat(_),H=l3.spawn(I.argv[0],_,{stdio:"inherit"});else H=l3.spawn(J,_,{stdio:"inherit"});else this._checkForMissingExecutable(J,Y,q._name),_.unshift(J),_=P_(I.execArgv).concat(_),H=l3.spawn(I.execPath,_,{stdio:"inherit"});if(!H.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((z)=>{I.on(z,()=>{if(H.killed===!1&&H.exitCode===null)H.kill(z)})});let W=this._exitCallback;H.on("close",(G)=>{if(G=G??1,!W)I.exit(G);else W(new u3(G,"commander.executeSubCommandAsync","(close)"))}),H.on("error",(G)=>{if(G.code==="ENOENT")this._checkForMissingExecutable(J,Y,q._name);else if(G.code==="EACCES")throw Error(`'${J}' not executable`);if(!W)I.exit(1);else{let z=new u3(1,"commander.executeSubCommandAsync","(error)");z.nestedError=G,W(z)}}),this.runningCommand=H}_dispatchSubcommand(q,_,Q){let X=this._findCommand(q);if(!X)this.help({error:!0});X._prepareForParse();let $;return $=this._chainOrCallSubCommandHook($,X,"preSubcommand"),$=this._chainOrCall($,()=>{if(X._executableHandler)this._executeSubCommand(X,_.concat(Q));else return X._parseCommand(_,Q)}),$}_dispatchHelpCommand(q){if(!q)this.help();let _=this._findCommand(q);if(_&&!_._executableHandler)_.help();return this._dispatchSubcommand(q,[],[this._getHelpOption()?.long??this._getHelpOption()?.short??"--help"])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((q,_)=>{if(q.required&&this.args[_]==null)this.missingArgument(q.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let q=(Q,X,$)=>{let J=X;if(X!==null&&Q.parseArg){let Y=`error: command-argument value '${X}' is invalid for argument '${Q.name()}'.`;J=this._callParseArg(Q,X,$,Y)}return J};this._checkNumberOfArguments();let _=[];this.registeredArguments.forEach((Q,X)=>{let $=Q.defaultValue;if(Q.variadic){if(X<this.args.length){if($=this.args.slice(X),Q.parseArg)$=$.reduce((J,Y)=>{return q(Q,Y,J)},Q.defaultValue)}else if($===void 0)$=[]}else if(X<this.args.length){if($=this.args[X],Q.parseArg)$=q(Q,$,Q.defaultValue)}_[X]=$}),this.processedArgs=_}_chainOrCall(q,_){if(q?.then&&typeof q.then==="function")return q.then(()=>_());return _()}_chainOrCallHooks(q,_){let Q=q,X=[];if(this._getCommandAndAncestors().reverse().filter(($)=>$._lifeCycleHooks[_]!==void 0).forEach(($)=>{$._lifeCycleHooks[_].forEach((J)=>{X.push({hookedCommand:$,callback:J})})}),_==="postAction")X.reverse();return X.forEach(($)=>{Q=this._chainOrCall(Q,()=>{return $.callback($.hookedCommand,this)})}),Q}_chainOrCallSubCommandHook(q,_,Q){let X=q;if(this._lifeCycleHooks[Q]!==void 0)this._lifeCycleHooks[Q].forEach(($)=>{X=this._chainOrCall(X,()=>{return $(this,_)})});return X}_parseCommand(q,_){let Q=this.parseOptions(_);if(this._parseOptionsEnv(),this._parseOptionsImplied(),q=q.concat(Q.operands),_=Q.unknown,this.args=q.concat(_),q&&this._findCommand(q[0]))return this._dispatchSubcommand(q[0],q.slice(1),_);if(this._getHelpCommand()&&q[0]===this._getHelpCommand().name())return this._dispatchHelpCommand(q[1]);if(this._defaultCommandName)return this._outputHelpIfRequested(_),this._dispatchSubcommand(this._defaultCommandName,q,_);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});this._outputHelpIfRequested(Q.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let X=()=>{if(Q.unknown.length>0)this.unknownOption(Q.unknown[0])},$=`command:${this.name()}`;if(this._actionHandler){X(),this._processArguments();let J;if(J=this._chainOrCallHooks(J,"preAction"),J=this._chainOrCall(J,()=>this._actionHandler(this.processedArgs)),this.parent)J=this._chainOrCall(J,()=>{this.parent.emit($,q,_)});return J=this._chainOrCallHooks(J,"postAction"),J}if(this.parent?.listenerCount($))X(),this._processArguments(),this.parent.emit($,q,_);else if(q.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",q,_);if(this.listenerCount("command:*"))this.emit("command:*",q,_);else if(this.commands.length)this.unknownCommand();else X(),this._processArguments()}else if(this.commands.length)X(),this.help({error:!0});else X(),this._processArguments()}_findCommand(q){if(!q)return;return this.commands.find((_)=>_._name===q||_._aliases.includes(q))}_findOption(q){return this.options.find((_)=>_.is(q))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((q)=>{q.options.forEach((_)=>{if(_.mandatory&&q.getOptionValue(_.attributeName())===void 0)q.missingMandatoryOptionValue(_)})})}_checkForConflictingLocalOptions(){let q=this.options.filter((Q)=>{let X=Q.attributeName();if(this.getOptionValue(X)===void 0)return!1;return this.getOptionValueSource(X)!=="default"});q.filter((Q)=>Q.conflictsWith.length>0).forEach((Q)=>{let X=q.find(($)=>Q.conflictsWith.includes($.attributeName()));if(X)this._conflictingOption(Q,X)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((q)=>{q._checkForConflictingLocalOptions()})}parseOptions(q){let _=[],Q=[],X=_;function $(G){return G.length>1&&G[0]==="-"}let J=(G)=>{if(!/^-(\d+|\d*\.\d+)(e[+-]?\d+)?$/.test(G))return!1;return!this._getCommandAndAncestors().some((z)=>z.options.map((M)=>M.short).some((M)=>/^-\d$/.test(M)))},Y=null,H=null,W=0;while(W<q.length||H){let G=H??q[W++];if(H=null,G==="--"){if(X===Q)X.push(G);X.push(...q.slice(W));break}if(Y&&(!$(G)||J(G))){this.emit(`option:${Y.name()}`,G);continue}if(Y=null,$(G)){let z=this._findOption(G);if(z){if(z.required){let M=q[W++];if(M===void 0)this.optionMissingArgument(z);this.emit(`option:${z.name()}`,M)}else if(z.optional){let M=null;if(W<q.length&&(!$(q[W])||J(q[W])))M=q[W++];this.emit(`option:${z.name()}`,M)}else this.emit(`option:${z.name()}`);Y=z.variadic?z:null;continue}}if(G.length>2&&G[0]==="-"&&G[1]!=="-"){let z=this._findOption(`-${G[1]}`);if(z){if(z.required||z.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${z.name()}`,G.slice(2));else this.emit(`option:${z.name()}`),H=`-${G.slice(2)}`;continue}}if(/^--[^=]+=/.test(G)){let z=G.indexOf("="),M=this._findOption(G.slice(0,z));if(M&&(M.required||M.optional)){this.emit(`option:${M.name()}`,G.slice(z+1));continue}}if(X===_&&$(G)&&!(this.commands.length===0&&J(G)))X=Q;if((this._enablePositionalOptions||this._passThroughOptions)&&_.length===0&&Q.length===0){if(this._findCommand(G)){_.push(G),Q.push(...q.slice(W));break}else if(this._getHelpCommand()&&G===this._getHelpCommand().name()){_.push(G,...q.slice(W));break}else if(this._defaultCommandName){Q.push(G,...q.slice(W));break}}if(this._passThroughOptions){X.push(G,...q.slice(W));break}X.push(G)}return{operands:_,unknown:Q}}opts(){if(this._storeOptionsAsProperties){let q={},_=this.options.length;for(let Q=0;Q<_;Q++){let X=this.options[Q].attributeName();q[X]=X===this._versionOptionName?this._version:this[X]}return q}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((q,_)=>Object.assign(q,_.opts()),{})}error(q,_){if(this._outputConfiguration.outputError(`${q}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let Q=_||{},X=Q.exitCode||1,$=Q.code||"commander.error";this._exit(X,$,q)}_parseOptionsEnv(){this.options.forEach((q)=>{if(q.envVar&&q.envVar in I.env){let _=q.attributeName();if(this.getOptionValue(_)===void 0||["default","config","env"].includes(this.getOptionValueSource(_)))if(q.required||q.optional)this.emit(`optionEnv:${q.name()}`,I.env[q.envVar]);else this.emit(`optionEnv:${q.name()}`)}})}_parseOptionsImplied(){let q=new jX(this.options),_=(Q)=>{return this.getOptionValue(Q)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(Q))};this.options.filter((Q)=>Q.implied!==void 0&&_(Q.attributeName())&&q.valueFromOption(this.getOptionValue(Q.attributeName()),Q)).forEach((Q)=>{Object.keys(Q.implied).filter((X)=>!_(X)).forEach((X)=>{this.setOptionValueWithSource(X,Q.implied[X],"implied")})})}missingArgument(q){let _=`error: missing required argument '${q}'`;this.error(_,{code:"commander.missingArgument"})}optionMissingArgument(q){let _=`error: option '${q.flags}' argument missing`;this.error(_,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(q){let _=`error: required option '${q.flags}' not specified`;this.error(_,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(q,_){let Q=(J)=>{let Y=J.attributeName(),H=this.getOptionValue(Y),W=this.options.find((z)=>z.negate&&Y===z.attributeName()),G=this.options.find((z)=>!z.negate&&Y===z.attributeName());if(W&&(W.presetArg===void 0&&H===!1||W.presetArg!==void 0&&H===W.presetArg))return W;return G||J},X=(J)=>{let Y=Q(J),H=Y.attributeName();if(this.getOptionValueSource(H)==="env")return`environment variable '${Y.envVar}'`;return`option '${Y.flags}'`},$=`error: ${X(q)} cannot be used with ${X(_)}`;this.error($,{code:"commander.conflictingOption"})}unknownOption(q){if(this._allowUnknownOption)return;let _="";if(q.startsWith("--")&&this._showSuggestionAfterError){let X=[],$=this;do{let J=$.createHelp().visibleOptions($).filter((Y)=>Y.long).map((Y)=>Y.long);X=X.concat(J),$=$.parent}while($&&!$._enablePositionalOptions);_=T_(q,X)}let Q=`error: unknown option '${q}'${_}`;this.error(Q,{code:"commander.unknownOption"})}_excessArguments(q){if(this._allowExcessArguments)return;let _=this.registeredArguments.length,Q=_===1?"":"s",$=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${_} argument${Q} but got ${q.length}.`;this.error($,{code:"commander.excessArguments"})}unknownCommand(){let q=this.args[0],_="";if(this._showSuggestionAfterError){let X=[];this.createHelp().visibleCommands(this).forEach(($)=>{if(X.push($.name()),$.alias())X.push($.alias())}),_=T_(q,X)}let Q=`error: unknown command '${q}'${_}`;this.error(Q,{code:"commander.unknownCommand"})}version(q,_,Q){if(q===void 0)return this._version;this._version=q,_=_||"-V, --version",Q=Q||"output the version number";let X=this.createOption(_,Q);return this._versionOptionName=X.attributeName(),this._registerOption(X),this.on("option:"+X.name(),()=>{this._outputConfiguration.writeOut(`${q}
`),this._exit(0,"commander.version",q)}),this}description(q,_){if(q===void 0&&_===void 0)return this._description;if(this._description=q,_)this._argsDescription=_;return this}summary(q){if(q===void 0)return this._summary;return this._summary=q,this}alias(q){if(q===void 0)return this._aliases[0];let _=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)_=this.commands[this.commands.length-1];if(q===_._name)throw Error("Command alias can't be the same as its name");let Q=this.parent?._findCommand(q);if(Q){let X=[Q.name()].concat(Q.aliases()).join("|");throw Error(`cannot add alias '${q}' to command '${this.name()}' as already have command '${X}'`)}return _._aliases.push(q),this}aliases(q){if(q===void 0)return this._aliases;return q.forEach((_)=>this.alias(_)),this}usage(q){if(q===void 0){if(this._usage)return this._usage;let _=this.registeredArguments.map((Q)=>{return WX(Q)});return[].concat(this.options.length||this._helpOption!==null?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?_:[]).join(" ")}return this._usage=q,this}name(q){if(q===void 0)return this._name;return this._name=q,this}helpGroup(q){if(q===void 0)return this._helpGroupHeading??"";return this._helpGroupHeading=q,this}commandsGroup(q){if(q===void 0)return this._defaultCommandGroup??"";return this._defaultCommandGroup=q,this}optionsGroup(q){if(q===void 0)return this._defaultOptionGroup??"";return this._defaultOptionGroup=q,this}_initOptionGroup(q){if(this._defaultOptionGroup&&!q.helpGroupHeading)q.helpGroup(this._defaultOptionGroup)}_initCommandGroup(q){if(this._defaultCommandGroup&&!q.helpGroup())q.helpGroup(this._defaultCommandGroup)}nameFromFilename(q){return this._name=$q.basename(q,$q.extname(q)),this}executableDir(q){if(q===void 0)return this._executableDir;return this._executableDir=q,this}helpInformation(q){let _=this.createHelp(),Q=this._getOutputContext(q);_.prepareContext({error:Q.error,helpWidth:Q.helpWidth,outputHasColors:Q.hasColors});let X=_.formatHelp(this,_);if(Q.hasColors)return X;return this._outputConfiguration.stripColor(X)}_getOutputContext(q){q=q||{};let _=!!q.error,Q,X,$;if(_)Q=(Y)=>this._outputConfiguration.writeErr(Y),X=this._outputConfiguration.getErrHasColors(),$=this._outputConfiguration.getErrHelpWidth();else Q=(Y)=>this._outputConfiguration.writeOut(Y),X=this._outputConfiguration.getOutHasColors(),$=this._outputConfiguration.getOutHelpWidth();return{error:_,write:(Y)=>{if(!X)Y=this._outputConfiguration.stripColor(Y);return Q(Y)},hasColors:X,helpWidth:$}}outputHelp(q){let _;if(typeof q==="function")_=q,q=void 0;let Q=this._getOutputContext(q),X={error:Q.error,write:Q.write,command:this};this._getCommandAndAncestors().reverse().forEach((J)=>J.emit("beforeAllHelp",X)),this.emit("beforeHelp",X);let $=this.helpInformation({error:Q.error});if(_){if($=_($),typeof $!=="string"&&!Buffer.isBuffer($))throw Error("outputHelp callback must return a string or a Buffer")}if(Q.write($),this._getHelpOption()?.long)this.emit(this._getHelpOption().long);this.emit("afterHelp",X),this._getCommandAndAncestors().forEach((J)=>J.emit("afterAllHelp",X))}helpOption(q,_){if(typeof q==="boolean"){if(q){if(this._helpOption===null)this._helpOption=void 0;if(this._defaultOptionGroup)this._initOptionGroup(this._getHelpOption())}else this._helpOption=null;return this}if(this._helpOption=this.createOption(q??"-h, --help",_??"display help for command"),q||_)this._initOptionGroup(this._helpOption);return this}_getHelpOption(){if(this._helpOption===void 0)this.helpOption(void 0,void 0);return this._helpOption}addHelpOption(q){return this._helpOption=q,this._initOptionGroup(q),this}help(q){this.outputHelp(q);let _=Number(I.exitCode??0);if(_===0&&q&&typeof q!=="function"&&q.error)_=1;this._exit(_,"commander.help","(outputHelp)")}addHelpText(q,_){let Q=["beforeAll","before","after","afterAll"];if(!Q.includes(q))throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${Q.join("', '")}'`);let X=`${q}Help`;return this.on(X,($)=>{let J;if(typeof _==="function")J=_({error:$.error,command:$.command});else J=_;if(J)$.write(`${J}
`)}),this}_outputHelpIfRequested(q){let _=this._getHelpOption();if(_&&q.find((X)=>_.is(X)))this.outputHelp(),this._exit(0,"commander.helpDisplayed","(outputHelp)")}}function P_(q){return q.map((_)=>{if(!_.startsWith("--inspect"))return _;let Q,X="127.0.0.1",$="9229",J;if((J=_.match(/^(--inspect(-brk)?)$/))!==null)Q=J[1];else if((J=_.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(Q=J[1],/^\d+$/.test(J[3]))$=J[3];else X=J[3];else if((J=_.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)Q=J[1],X=J[3],$=J[4];if(Q&&$!=="0")return`${Q}=${X}:${parseInt($)+1}`;return _})}function m3(){if(I.env.NO_COLOR||I.env.FORCE_COLOR==="0"||I.env.FORCE_COLOR==="false")return!1;if(I.env.FORCE_COLOR||I.env.CLICOLOR_FORCE!==void 0)return!0;return}MX.Command=d3;MX.useColor=m3});var Z_=Fq((wX)=>{var{Argument:C_}=A3(),{Command:c3}=k_(),{CommanderError:LX,InvalidArgumentError:f_}=J3(),{Help:KX}=g3(),{Option:b_}=h3();wX.program=new c3;wX.createCommand=(q)=>new c3(q);wX.createOption=(q,_)=>new b_(q,_);wX.createArgument=(q,_)=>new C_(q,_);wX.Command=c3;wX.Option=b_;wX.Argument=C_;wX.Help=KX;wX.CommanderError=LX;wX.InvalidArgumentError=f_;wX.InvalidOptionArgumentError=f_});var N3={};A_(N3,{validateBranchName:()=>r3,syncSharedContracts:()=>bX,isPluginInstallation:()=>O3,isMultiRepoChild:()=>o3,hasGit:()=>d_,getTemplatesDir:()=>Y3,getScriptsDir:()=>TX,getRepoRoot:()=>H3,getPluginRoot:()=>S3,getMultiRepoContext:()=>xq,getMemoryDir:()=>PX,getFeaturePaths:()=>i,getFeatureDir:()=>CX,getDefaultWorkflowMode:()=>fX,getCurrentBranch:()=>m_,getChildRepoName:()=>F3,findFeatureDirByPrefix:()=>c_,findChildReposWithNames:()=>s3,findChildRepos:()=>u_,detectSpeckRoot:()=>C,detectSpeckMode:()=>kX,clearSpeckCache:()=>n3,checkFile:()=>yq,checkFeatureBranch:()=>W3,checkDir:()=>a3});import{existsSync as Yq}from"fs";import{readdirSync as p3}from"fs";import T from"fs/promises";import A from"path";var{$:D3}=globalThis.Bun;function O3(){if(process.env.CLAUDE_PLUGIN_ROOT)return!0;let q=import.meta.dir;return q.includes("/.claude/plugins/")||q.includes("/.config/claude-code/plugins/")}function S3(){if(process.env.CLAUDE_PLUGIN_ROOT)return process.env.CLAUDE_PLUGIN_ROOT;let q=import.meta.dir;if(O3())return A.resolve(q,"../../..");else return A.resolve(q,"../../..")}function Y3(){let q=S3();if(O3())return A.join(q,"templates");else return A.join(q,".speck/templates")}function TX(){let q=S3();return A.join(q,".speck/scripts")}function PX(){let q=S3();if(O3())return A.join(q,"memory");else return A.join(q,".speck/memory")}async function H3(){try{return(await D3`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{let q=import.meta.dir;return A.resolve(q,"../../..")}}function n3(){Nq=null}async function C(){if(Nq)return Nq;let q=await H3(),_=A.join(q,".speck","root");try{if(!(await T.lstat(_)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let W={mode:"single-repo",speckRoot:q,repoRoot:q,specsDir:A.join(q,"specs")};return Nq=W,W}let X=await T.realpath(_),$=["/","/etc","/usr","/bin","/sbin","/System","/Library"],J=process.env.HOME||process.env.USERPROFILE||"";if($.some((W)=>X===W||X.startsWith(W+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${X}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(J&&X===A.dirname(J))throw Error(`Security: .speck/root symlink points above home directory: ${X}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await T.access(X);let Y=A.join(q,"specs");try{if((await T.stat(Y)).isDirectory()&&X!==q)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${Y}
  Shared: ${A.join(X,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${Y}/* ${A.join(X,"specs")}/
  2. Remove local specs: rm -rf ${Y}
`)}catch(W){if(W.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${W.message}`)}let H={mode:"multi-repo",speckRoot:X,repoRoot:q,specsDir:A.join(X,"specs")};return Nq=H,H}catch(Q){if(Q.code==="ENOENT"){if((await u_(q)).length>0){let Y={mode:"multi-repo",speckRoot:q,repoRoot:q,specsDir:A.join(q,"specs")};return Nq=Y,Y}let J={mode:"single-repo",speckRoot:q,repoRoot:q,specsDir:A.join(q,"specs")};return Nq=J,J}if(Q.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let X=await T.readlink(_).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${X} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}async function o3(){let q=await C();return q.mode==="multi-repo"&&q.repoRoot!==q.speckRoot}async function F3(q,_){try{let Q=await T.realpath(q),X=await T.readdir(_,{withFileTypes:!0});for(let $ of X)if($.isSymbolicLink()&&$.name.startsWith(".speck-link-")){let J=A.join(_,$.name);try{if(await T.realpath(J)===Q)return $.name.replace(/^\.speck-link-/,"")}catch{continue}}}catch{}return A.basename(q)}async function u_(q){let _=[];try{let Q=await T.readdir(q,{withFileTypes:!0});for(let X of Q)if(X.isSymbolicLink()&&X.name.startsWith(".speck-link-")){let $=A.join(q,X.name);try{let J=await T.realpath($);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((W)=>J===W||J.startsWith(W+"/"))){console.warn(`Security: Skipping ${X.name} - points to system directory: ${J}`);continue}let H=A.join(J,".git");try{await T.access(H),_.push(J)}catch{console.warn(`Warning: ${X.name} points to non-git directory: ${J}`)}}catch(J){console.warn(`Warning: Broken symlink ${X.name}: ${J.message}`)}}}catch(Q){if(Q.code!=="ENOENT")throw Q}return _}async function s3(q){let _=new Map;try{let Q=await T.readdir(q,{withFileTypes:!0});for(let X of Q)if(X.isSymbolicLink()&&X.name.startsWith(".speck-link-")){let $=A.join(q,X.name),J=X.name.substring(12);try{let Y=await T.realpath($);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((G)=>Y===G||Y.startsWith(G+"/"))){console.warn(`Security: Skipping ${X.name} - points to system directory: ${Y}`);continue}let W=A.join(Y,".git");try{await T.access(W),_.set(J,Y)}catch{console.warn(`Warning: ${X.name} points to non-git directory: ${Y}`)}}catch(Y){console.warn(`Warning: Broken symlink ${X.name}: ${Y.message}`)}}}catch(Q){if(Q.code!=="ENOENT")throw Q}return _}async function xq(){let q=await C();if(q.mode==="single-repo")return{...q,context:"single",parentSpecId:null,childRepoName:null};if(q.repoRoot===q.speckRoot)return{...q,context:"root",parentSpecId:null,childRepoName:null};else{let _=await F3(q.repoRoot,q.speckRoot),Q=null;try{let X=A.join(q.repoRoot,".speck","branches.json"),$=await T.readFile(X,"utf-8"),J=JSON.parse($);if(J.branches&&J.branches.length>0)Q=J.branches[0].parentSpecId||null}catch{}if(!Q)try{let{$:X}=awaitPromise.resolve(globalThis.Bun),J=(await X`git -C ${q.speckRoot} rev-parse --abbrev-ref HEAD`.quiet()).stdout.toString().trim();if(/^\d{3}-/.test(J))Q=J}catch{}return{...q,context:"child",parentSpecId:Q,childRepoName:_}}}async function m_(q){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await D3`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let _=A.join(q,"specs");if(Yq(_)){let Q="",X=0,$=p3(_,{withFileTypes:!0});for(let J of $)if(J.isDirectory()){let Y=J.name.match(/^(\d{3})-/);if(Y){let H=parseInt(Y[1],10);if(H>X)X=H,Q=J.name}}if(Q)return Q}return"main"}}async function d_(){try{return await D3`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function r3(q){try{return(await D3`git check-ref-format --branch ${q}`.quiet()).exitCode===0}catch{return!1}}async function W3(q,_,Q){if(!_)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let X=A.join(Q,".speck","branches.json");if(Yq(X))try{let $=await T.readFile(X,"utf-8"),J=JSON.parse($);if(J.branches&&Array.isArray(J.branches)){if(J.branches.some((H)=>H.name===q))return!0}}catch{}if(!/^\d{3}-/.test(q))return console.error(`ERROR: Not on a feature branch. Current branch: ${q}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}function CX(q,_){return A.join(q,"specs",_)}async function c_(q,_,Q){let X=A.join(Q,".speck","branches.json");if(Yq(X))try{let H=await T.readFile(X,"utf-8"),W=JSON.parse(H);if(W.branches&&Array.isArray(W.branches)){let G=W.branches.find((z)=>z.name===_);if(G&&G.specId)return A.join(q,G.specId)}}catch{}let $=_.match(/^(\d{3})-/);if(!$)return A.join(q,_);let J=$[1],Y=[];if(Yq(q)){let H=p3(q,{withFileTypes:!0});for(let W of H)if(W.isDirectory()&&W.name.startsWith(`${J}-`))Y.push(W.name)}if(Y.length===0)return A.join(q,_);else if(Y.length===1)return A.join(q,Y[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${J}': ${Y.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),A.join(q,_)}async function i(){let q=await C(),_=await m_(q.repoRoot),Q=await d_(),X=await c_(q.specsDir,_,q.repoRoot),$=A.basename(X);return{MODE:q.mode,SPECK_ROOT:q.speckRoot,SPECS_DIR:q.specsDir,REPO_ROOT:q.repoRoot,CURRENT_BRANCH:_,HAS_GIT:Q?"true":"false",FEATURE_DIR:X,FEATURE_SPEC:A.join(X,"spec.md"),IMPL_PLAN:A.join(q.repoRoot,"specs",$,"plan.md"),TASKS:A.join(q.repoRoot,"specs",$,"tasks.md"),RESEARCH:A.join(X,"research.md"),DATA_MODEL:A.join(X,"data-model.md"),QUICKSTART:A.join(X,"quickstart.md"),CONTRACTS_DIR:A.join(X,"contracts")}}async function fX(){try{let q=await H3(),_=A.join(q,".speck/memory/constitution.md");if(!Yq(_))return null;let X=(await T.readFile(_,"utf-8")).match(/^\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)\s*$/m);if(X&&(X[1]==="stacked-pr"||X[1]==="single-branch"))return X[1];return null}catch(q){return null}}function yq(q,_){return Yq(q)?`  \u2713 ${_}`:`  \u2717 ${_}`}function a3(q,_){if(!Yq(q))return`  \u2717 ${_}`;try{return p3(q).length>0?`  \u2713 ${_}`:`  \u2717 ${_}`}catch{return`  \u2717 ${_}`}}async function bX(q){let _=await C();if(_.mode!=="multi-repo")return!1;let Q=A.join(_.speckRoot,"specs",q,"contracts");if(!Yq(Q))return!1;let X=A.join(_.repoRoot,"specs",q);if(!Yq(X))return!1;let $=A.join(X,"contracts");try{if((await T.lstat($)).isSymbolicLink()){let H=await T.readlink($);if(await T.realpath($)===Q)return!0;await T.unlink($)}else return console.warn(`WARNING: Local contracts/ directory exists but is not a symlink
  Local: ${$}
  Shared: ${Q}
  Skipping symlink creation to preserve local data.`),!1}catch(Y){if(Y.code!=="ENOENT")throw Y}let J=A.relative(X,Q);try{return await T.symlink(J,$,"dir"),!0}catch(Y){return console.warn(`Warning: Failed to create contracts/ symlink: ${Y.message}`),!1}}var Nq=null,kX;var p=gQ(()=>{kX=C});var x_=E_(Z_(),1),{program:_2,createCommand:Q2,createArgument:X2,createOption:$2,CommanderError:J2,InvalidArgumentError:Y2,InvalidOptionArgumentError:H2,Command:y_,Argument:W2,Option:G2,Help:z2}=x_.default;function Jq(){if(process.argv.includes("--hook"))return"hook";return process.stdin.isTTY===!1?"hook":"cli"}async function g_(){try{let q=await Bun.stdin.text(),_=JSON.parse(q);if(!_.tool_input||typeof _.tool_input.command!=="string")throw Error("Invalid hook input: missing tool_input.command field");return _}catch(q){if(q instanceof SyntaxError)throw Error(`Failed to parse hook input JSON: ${q.message}`);throw q}}function h_(q,_){return{hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"allow",updatedInput:{..._,command:`cat << 'OUTPUT_EOF'
${q}
OUTPUT_EOF`}}}}function i3(){return{}}var l_=async(q)=>{try{return{success:!0,output:q.message||"",errorOutput:null,exitCode:0,metadata:{message:q.message}}}catch(_){return{success:!1,output:"",errorOutput:_ instanceof Error?_.message:String(_),exitCode:1,metadata:null}}};p();var i_=async(q,_)=>{try{let Q=await C();return{success:!0,output:["Speck Environment","================",`Speck Root: ${Q.speckRoot}`,`Repo Root: ${Q.repoRoot}`,`Mode: ${Q.mode}`,`Execution Mode: ${_.mode}`,`Working Directory: ${_.workingDirectory}`,`Interactive: ${_.isInteractive}`].join(`
`),errorOutput:null,exitCode:0,metadata:{speckRoot:Q.speckRoot,repoRoot:Q.repoRoot,configMode:Q.mode,executionMode:_.mode,workingDirectory:_.workingDirectory,isInteractive:_.isInteractive}}}catch(Q){return{success:!1,output:"",errorOutput:Q instanceof Error?Q.message:String(Q),exitCode:1,metadata:null}}};p();import{existsSync as Lq,readdirSync as ZX}from"fs";function xX(q){return{json:q.includes("--json"),requireTasks:q.includes("--require-tasks"),includeTasks:q.includes("--include-tasks"),pathsOnly:q.includes("--paths-only"),skipFeatureCheck:q.includes("--skip-feature-check"),help:q.includes("--help")||q.includes("-h")}}function yX(){console.log(`Usage: check-prerequisites.sh [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json              Output in JSON format
  --require-tasks     Require tasks.md to exist (for implementation phase)
  --include-tasks     Include tasks.md in AVAILABLE_DOCS list
  --paths-only        Only output path variables (no prerequisite validation)
  --skip-feature-check Skip feature directory and plan.md validation (for /speck.specify)
  --help, -h          Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  ./check-prerequisites.sh --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  ./check-prerequisites.sh --json --require-tasks --include-tasks

  # Get feature paths only (no validation)
  ./check-prerequisites.sh --paths-only
`)}function gX(q,_){if(_){let Q={MODE:q.MODE,REPO_ROOT:q.REPO_ROOT,BRANCH:q.CURRENT_BRANCH,FEATURE_DIR:q.FEATURE_DIR,FEATURE_SPEC:q.FEATURE_SPEC,IMPL_PLAN:q.IMPL_PLAN,TASKS:q.TASKS};console.log(JSON.stringify(Q))}else console.log(`MODE: ${q.MODE}`),console.log(`REPO_ROOT: ${q.REPO_ROOT}`),console.log(`BRANCH: ${q.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${q.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${q.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${q.IMPL_PLAN}`),console.log(`TASKS: ${q.TASKS}`)}function hX(q){let _=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--help","-h"];for(let Q of q)if(Q.startsWith("--")||Q.startsWith("-")){if(!_.includes(Q))console.error(`ERROR: Unknown option '${Q}'. Use --help for usage information.`),process.exit(1)}}async function n_(q){hX(q);let _=xX(q);if(_.help)return yX(),0;let Q=await i(),X=Q.HAS_GIT==="true";if(!_.skipFeatureCheck){if(!await W3(Q.CURRENT_BRANCH,X,Q.REPO_ROOT))return 1}if(_.pathsOnly||_.skipFeatureCheck)return gX(Q,_.json),0;if(!Lq(Q.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${Q.FEATURE_DIR}`),console.error("Run /speckit.specify first to create the feature structure."),1;if(!Lq(Q.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${Q.FEATURE_DIR}`),console.error("Run /speckit.plan first to create the implementation plan."),1;if(_.requireTasks&&!Lq(Q.TASKS))return console.error(`ERROR: tasks.md not found in ${Q.FEATURE_DIR}`),console.error("Run /speckit.tasks first to create the task list."),1;let $=[];if(Lq(Q.RESEARCH))$.push("research.md");if(Lq(Q.DATA_MODEL))$.push("data-model.md");if(Lq(Q.CONTRACTS_DIR))try{if(ZX(Q.CONTRACTS_DIR).length>0)$.push("contracts/")}catch{}if(Lq(Q.QUICKSTART))$.push("quickstart.md");if(_.includeTasks&&Lq(Q.TASKS))$.push("tasks.md");if(_.json){let J={MODE:Q.MODE,FEATURE_DIR:Q.FEATURE_DIR,AVAILABLE_DOCS:$};console.log(JSON.stringify(J))}else if(console.log(`FEATURE_DIR:${Q.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:"),console.log(yq(Q.RESEARCH,"research.md")),console.log(yq(Q.DATA_MODEL,"data-model.md")),console.log(a3(Q.CONTRACTS_DIR,"contracts/")),console.log(yq(Q.QUICKSTART,"quickstart.md")),_.includeTasks)console.log(yq(Q.TASKS,"tasks.md"));return 0}import{existsSync as gq,mkdirSync as t3,readdirSync as o_,copyFileSync as lX,symlinkSync as uX}from"fs";import h from"path";var{$:Hq}=globalThis.Bun;p();function mX(q){let _={json:!1,sharedSpec:!1,localSpec:!1,help:!1,featureDescription:""},Q=[],X=0;while(X<q.length){let $=q[X];if($==="--json")_.json=!0,X++;else if($==="--short-name"){if(X+1>=q.length||q[X+1].startsWith("--"))console.error("Error: --short-name requires a value"),process.exit(1);_.shortName=q[X+1],X+=2}else if($==="--number"){if(X+1>=q.length||q[X+1].startsWith("--"))console.error("Error: --number requires a value"),process.exit(1);let J=parseInt(q[X+1],10);if(isNaN(J))console.error("Error: --number requires a numeric value"),process.exit(1);_.number=J,X+=2}else if($==="--shared-spec")_.sharedSpec=!0,X++;else if($==="--local-spec")_.localSpec=!0,X++;else if($==="--help"||$==="-h")_.help=!0,X++;else Q.push($),X++}return _.featureDescription=Q.join(" "),_}function dX(){let q=h.basename(process.argv[1]);console.log(`Usage: ${q} [--json] [--short-name <name>] [--number N] [--shared-spec | --local-spec] <feature_description>

Options:
  --json              Output in JSON format
  --short-name <name> Provide a custom short name (2-4 words) for the branch
  --number N          Specify branch number manually (overrides auto-detection)
  --shared-spec       Create spec at speckRoot (multi-repo shared spec with local symlinks)
  --local-spec        Create spec locally in child repo (single-repo or child-only spec)
  --help, -h          Show this help message

Examples:
  ${q} 'Add user authentication system' --short-name 'user-auth'
  ${q} 'Implement OAuth2 integration for API' --number 5 --shared-spec`)}function cX(q){let _=q;while(_!=="/"){if(gq(h.join(_,".git"))||gq(h.join(_,".specify"))||gq(h.join(_,".speck")))return _;_=h.dirname(_)}return null}function iX(q){let _=0;if(gq(q)){let Q=o_(q,{withFileTypes:!0});for(let X of Q)if(X.isDirectory()){let $=X.name.match(/^(\d+)/);if($){let J=parseInt($[1],10);if(J>_)_=J}}}return _}async function pX(q,_){try{await Hq`git fetch --all --prune`.quiet()}catch{}let Q=0;try{let $=(await Hq`git ls-remote --heads origin`.quiet()).text().split(`
`);for(let J of $){let Y=J.match(new RegExp(`refs/heads/(\\d+)-${q}$`));if(Y){let H=parseInt(Y[1],10);if(H>Q)Q=H}}}catch{}try{let $=(await Hq`git branch`.quiet()).text().split(`
`);for(let J of $){let Y=J.match(new RegExp(`^[* ]*?(\\d+)-${q}$`));if(Y){let H=parseInt(Y[1],10);if(H>Q)Q=H}}}catch{}if(gq(_)){let X=o_(_,{withFileTypes:!0});for(let $ of X)if($.isDirectory()){let J=$.name.match(new RegExp(`^(\\d+)-${q}$`));if(J){let Y=parseInt(J[1],10);if(Y>Q)Q=Y}}}return Q+1}function s_(q){return q.toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/-+/g,"-").replace(/^-/,"").replace(/-$/,"")}function nX(q){let _=new Set(["i","a","an","the","to","for","of","in","on","at","by","with","from","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","should","could","can","may","might","must","shall","this","that","these","those","my","your","our","their","want","need","add","get","set"]),X=q.toLowerCase().replace(/[^a-z0-9]+/g," ").split(/\s+/).filter((Y)=>Y.length>0),$=[];for(let Y of X){if(_.has(Y))continue;if(Y.length>=3)$.push(Y);else{let H=Y.toUpperCase();if(q.includes(H))$.push(Y)}}if($.length>0){let Y=$.length===4?4:3;return $.slice(0,Y).join("-")}return s_(q).split("-").filter((Y)=>Y.length>0).slice(0,3).join("-")}async function r_(q){let _=mX(q);if(_.help)return dX(),0;if(!_.featureDescription)return console.error("Usage: create-new-feature [--json] [--short-name <name>] [--number N] <feature_description>"),1;let Q,X=!1;try{Q=(await Hq`git rev-parse --show-toplevel`.quiet()).text().trim(),X=!0}catch{let S=cX(import.meta.dir);if(!S)return console.error("Error: Could not determine repository root. Please run this script from within the repository."),1;Q=S,X=!1}let $=await C(),J,Y=!1;if(_.sharedSpec&&$.mode==="multi-repo")J=h.join($.speckRoot,"specs"),Y=!0;else J=h.join(Q,"specs");t3(J,{recursive:!0});let H;if(_.shortName)H=s_(_.shortName);else H=nX(_.featureDescription);let W;if(_.number!==void 0)W=_.number;else if(X)W=await pX(H,J);else W=iX(J)+1;let G=W.toString().padStart(3,"0"),z=`${G}-${H}`,M=244;if(z.length>M){let B=M-4,S=H.substring(0,B).replace(/-$/,"");console.error("[specify] Warning: Branch name exceeded GitHub's 244-byte limit"),console.error(`[specify] Original: ${z} (${z.length} bytes)`),z=`${G}-${S}`,console.error(`[specify] Truncated to: ${z} (${z.length} bytes)`)}if(X)try{await Hq`git checkout -b ${z}`}catch(B){return console.error(`Error: Failed to create git branch: ${B}`),1}else console.error(`[specify] Warning: Git repository not detected; skipped branch creation for ${z}`);if(Y&&$.mode==="multi-repo"){let B=$.speckRoot,S=!1;try{if((await Hq`git -C ${B} rev-parse --git-dir`.quiet()).exitCode===0)S=!0}catch{}if(!S)console.error(`[specify] Notice: Parent directory is not a git repository: ${B}`),console.error("[specify] To enable branch coordination, initialize it as a git repo:"),console.error(`[specify]   cd ${B} && git init`),console.error("[specify] Skipping parent branch creation for now.");else try{let k=!1;try{k=(await Hq`git -C ${B} rev-parse --verify ${z}`.quiet()).exitCode===0}catch{k=!1}if(k){if(await Hq`git -C ${B} checkout ${z}`.quiet(),!_.json)console.log(`[specify] Checked out existing branch in parent repo: ${z}`)}else{let f=await Hq`git -C ${B} checkout -b ${z}`.quiet();if(f.exitCode!==0)throw Error(`git checkout -b failed with exit code ${f.exitCode}: ${f.stderr}`);if(!_.json)console.log(`[specify] Created branch in parent repo: ${z}`)}}catch(k){console.error(`[specify] Warning: Failed to create branch in parent repo: ${k}`),console.error(`[specify] Parent repo: ${B}`),console.error(`[specify] You may need to manually create the branch: git -C ${B} checkout -b ${z}`)}}let E=h.join(J,z);t3(E,{recursive:!0});let v=h.join(Y3(),"spec-template.md"),R=h.join(E,"spec.md");if(gq(v))lX(v,R);else await Bun.write(R,"");if(_.sharedSpec&&$.mode==="multi-repo"){let B=h.join(Q,"specs",z);t3(B,{recursive:!0});let S=h.join(B,"spec.md"),k=h.relative(B,R);try{uX(k,S,"file")}catch(y){if(y.code!=="EEXIST")console.error(`Warning: Failed to create symlink for spec.md: ${y.message}`),console.error(`  From: ${S}`),console.error(`  To: ${R}`)}let f=h.join(E,"contracts"),c=h.join(B,"contracts")}if(process.env.SPECIFY_FEATURE=z,_.json)console.log(JSON.stringify({BRANCH_NAME:z,SPEC_FILE:R,FEATURE_NUM:G}));else console.log(`BRANCH_NAME: ${z}`),console.log(`SPEC_FILE: ${R}`),console.log(`FEATURE_NUM: ${G}`),console.log(`SPECIFY_FEATURE environment variable set to: ${z}`);return 0}p();import{existsSync as a_,mkdirSync as oX,copyFileSync as sX}from"fs";import rX from"path";var{$:G3}=globalThis.Bun;function aX(q){return{json:q.includes("--json"),help:q.includes("--help")||q.includes("-h")}}function tX(){console.log(`Usage: setup-plan [--json]
  --json    Output results in JSON format
  --help    Show this help message`)}async function t_(q){let _=aX(q);if(_.help)return tX(),0;let Q=await i(),X=Q.HAS_GIT==="true";if(!await W3(Q.CURRENT_BRANCH,X,Q.REPO_ROOT))return 1;oX(Q.FEATURE_DIR,{recursive:!0});let $=Q.CURRENT_BRANCH,J=await C();if(X){try{if((await G3`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()!==$)try{await G3`git checkout ${$}`.quiet(),console.log(`[specify] Checked out branch: ${$}`)}catch{await G3`git checkout -b ${$}`.quiet(),console.log(`[specify] Created and checked out branch: ${$}`)}}catch(G){console.error(`[specify] Warning: Could not manage git branch: ${G}`)}let H=Q.FEATURE_SPEC;if(J.mode==="multi-repo"&&a_(H)){let G=J.speckRoot,z=!1;try{if((await G3`git -C ${G} rev-parse --git-dir`.quiet()).exitCode===0)z=!0}catch{}if(z)try{let E=(await G3`git -C ${G} rev-parse --abbrev-ref HEAD`.quiet()).text().trim();if(E!==$)console.error("[specify] Warning: Parent repo branch mismatch!"),console.error(`[specify]   Child repo (current): ${$}`),console.error(`[specify]   Parent repo: ${E}`),console.error(`[specify]   Parent location: ${G}`),console.error("[specify] Consider checking out matching branch in parent:"),console.error(`[specify]   git -C ${G} checkout ${$}`)}catch(M){console.error(`[specify] Warning: Could not check parent repo branch: ${M}`)}}}let Y=rX.join(Y3(),"plan-template.md");if(a_(Y))sX(Y,Q.IMPL_PLAN),console.log(`Copied plan template to ${Q.IMPL_PLAN}`);else console.log(`Warning: Plan template not found at ${Y}`),await Bun.write(Q.IMPL_PLAN,"");if(_.json){let H={FEATURE_SPEC:Q.FEATURE_SPEC,IMPL_PLAN:Q.IMPL_PLAN,SPECS_DIR:Q.FEATURE_DIR,BRANCH:Q.CURRENT_BRANCH,HAS_GIT:Q.HAS_GIT};console.log(JSON.stringify(H))}else console.log(`FEATURE_SPEC: ${Q.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${Q.IMPL_PLAN}`),console.log(`SPECS_DIR: ${Q.FEATURE_DIR}`),console.log(`BRANCH: ${Q.CURRENT_BRANCH}`),console.log(`HAS_GIT: ${Q.HAS_GIT}`);return 0}p();import n from"fs/promises";import z3 from"path";async function eX(q){if(!q||q.trim()==="")throw Error(`Missing required argument: path-to-speck-root
Usage: /speck.link <path>
Examples:
  /speck.link ..          (parent directory)
  /speck.link ../..       (grandparent, for monorepo)
  /speck.link /abs/path   (absolute path)`);let _=await H3(),Q=z3.resolve(_,q);try{if(!(await n.stat(Q)).isDirectory())throw Error(`Target is not a directory: ${Q}`)}catch(H){if(H.code==="ENOENT")throw Error(`Target does not exist: ${Q}`);throw H}let X=z3.join(_,".speck","root"),$=z3.dirname(X),J=z3.relative($,Q);try{if(!(await n.lstat(X)).isSymbolicLink())throw Error(`.speck/root exists but is not a symlink
Fix: mv .speck/root .speck/root.backup && /speck.link `+q);let W=await n.readlink(X);if(await n.realpath(X)===Q){console.log(`\u2713 Already linked to ${J}`),console.log(`  Speck Root: ${Q}`);return}console.log(`Updating link from ${W} to ${J}`),await n.unlink(X)}catch(H){if(H.code!=="ENOENT")throw H}try{await n.symlink(J,X,"dir")}catch(H){if(process.platform==="win32"&&(H.code==="EPERM"||H.code==="EACCES"))throw Error(`Symlink creation failed (Windows requires Developer Mode or WSL)

Fix options:
  1. Enable Developer Mode:
`+`     - Settings \u2192 Update & Security \u2192 For developers \u2192 Developer Mode
`+`  2. Use WSL (Windows Subsystem for Linux):
     - Run Speck commands from WSL terminal
  3. Create symlink manually with admin privileges:
     - mklink /D .speck\\root `+q.replace(/\//g,"\\"));throw H}n3();let Y=await C();if(Y.mode!=="multi-repo")throw Error(`Link created but detection failed - this is a bug
Please report at https://github.com/nprbst/speck/issues`);await q8(_),console.log("\u2713 Multi-repo mode enabled"),console.log(`  Speck Root: ${Y.speckRoot}`),console.log(`  Repo Root: ${Y.repoRoot}`),console.log(`  Specs: ${Y.specsDir}`),console.log(`
Next steps:`),console.log('  1. Create shared spec: /speck.specify "Feature description"'),console.log("  2. Generate local plan: /speck.plan"),console.log("  3. Check configuration: /speck.env")}async function q8(q){let _=z3.join(q,".gitignore"),Q=["","# Speck multi-repo: ignore symlinked shared files","specs/*/spec.md","specs/*/contracts/"];try{let X="";try{X=await n.readFile(_,"utf-8")}catch(H){if(H.code!=="ENOENT")throw H}let $=X.includes("specs/*/spec.md"),J=X.includes("specs/*/contracts/");if($&&J)return;let Y=[];if(!X.endsWith(`
`)&&X.length>0)Y.push("");if(!$||!J)Y.push("# Speck multi-repo: ignore symlinked shared files");if(!$)Y.push("specs/*/spec.md");if(!J)Y.push("specs/*/contracts/");if(Y.length>0){let H=X+`
`+Y.join(`
`)+`
`;await n.writeFile(_,H,"utf-8"),console.log("\u2713 Added .gitignore patterns for symlinked files")}}catch(X){console.warn(`Warning: Could not update .gitignore: ${X.message}`)}}async function e_(q){if(q.length===0)return console.error(`ERROR: Missing argument
`),console.error(`Usage: bun run .speck/scripts/link-repo.ts <path>
`),console.error("Examples:"),console.error("  bun run .speck/scripts/link-repo.ts .."),console.error("  bun run .speck/scripts/link-repo.ts ../.."),1;try{return await eX(q[0]),0}catch(_){return console.error("ERROR:",_.message),1}}import f3 from"path";import b3 from"fs/promises";import P3 from"fs/promises";import{existsSync as UQ}from"fs";import Q_ from"path";var b={};A_(b,{void:()=>g8,util:()=>F,unknown:()=>x8,union:()=>m8,undefined:()=>f8,tuple:()=>i8,transformer:()=>_9,symbol:()=>C8,string:()=>WQ,strictObject:()=>u8,setErrorMap:()=>X8,set:()=>o8,record:()=>p8,quotelessJson:()=>_8,promise:()=>q9,preprocess:()=>$9,pipeline:()=>J9,ostring:()=>Y9,optional:()=>Q9,onumber:()=>H9,oboolean:()=>W9,objectUtil:()=>e3,object:()=>l8,number:()=>GQ,nullable:()=>X9,null:()=>b8,never:()=>y8,nativeEnum:()=>e8,nan:()=>T8,map:()=>n8,makeIssue:()=>j3,literal:()=>a8,lazy:()=>r8,late:()=>I8,isValid:()=>Kq,isDirty:()=>I3,isAsync:()=>lq,isAborted:()=>v3,intersection:()=>c8,instanceof:()=>R8,getParsedType:()=>qq,getErrorMap:()=>hq,function:()=>s8,enum:()=>t8,effect:()=>_9,discriminatedUnion:()=>d8,defaultErrorMap:()=>Wq,datetimeRegex:()=>JQ,date:()=>k8,custom:()=>HQ,coerce:()=>G9,boolean:()=>zQ,bigint:()=>P8,array:()=>h8,any:()=>Z8,addIssueToContext:()=>V,ZodVoid:()=>U3,ZodUnknown:()=>wq,ZodUnion:()=>pq,ZodUndefined:()=>cq,ZodType:()=>O,ZodTuple:()=>Qq,ZodTransformer:()=>t,ZodSymbol:()=>M3,ZodString:()=>o,ZodSet:()=>Tq,ZodSchema:()=>O,ZodRecord:()=>V3,ZodReadonly:()=>eq,ZodPromise:()=>Pq,ZodPipeline:()=>w3,ZodParsedType:()=>U,ZodOptional:()=>r,ZodObject:()=>P,ZodNumber:()=>Eq,ZodNullable:()=>zq,ZodNull:()=>iq,ZodNever:()=>_q,ZodNativeEnum:()=>rq,ZodNaN:()=>K3,ZodMap:()=>L3,ZodLiteral:()=>sq,ZodLazy:()=>oq,ZodIssueCode:()=>j,ZodIntersection:()=>nq,ZodFunction:()=>mq,ZodFirstPartyTypeKind:()=>w,ZodError:()=>m,ZodEnum:()=>Bq,ZodEffects:()=>t,ZodDiscriminatedUnion:()=>R3,ZodDefault:()=>aq,ZodDate:()=>Iq,ZodCatch:()=>tq,ZodBranded:()=>T3,ZodBoolean:()=>dq,ZodBigInt:()=>Aq,ZodArray:()=>s,ZodAny:()=>Rq,Schema:()=>O,ParseStatus:()=>Z,OK:()=>g,NEVER:()=>z9,INVALID:()=>K,EMPTY_PATH:()=>$8,DIRTY:()=>vq,BRAND:()=>v8});var F;(function(q){q.assertEqual=($)=>{};function _($){}q.assertIs=_;function Q($){throw Error()}q.assertNever=Q,q.arrayToEnum=($)=>{let J={};for(let Y of $)J[Y]=Y;return J},q.getValidEnumValues=($)=>{let J=q.objectKeys($).filter((H)=>typeof $[$[H]]!=="number"),Y={};for(let H of J)Y[H]=$[H];return q.objectValues(Y)},q.objectValues=($)=>{return q.objectKeys($).map(function(J){return $[J]})},q.objectKeys=typeof Object.keys==="function"?($)=>Object.keys($):($)=>{let J=[];for(let Y in $)if(Object.prototype.hasOwnProperty.call($,Y))J.push(Y);return J},q.find=($,J)=>{for(let Y of $)if(J(Y))return Y;return},q.isInteger=typeof Number.isInteger==="function"?($)=>Number.isInteger($):($)=>typeof $==="number"&&Number.isFinite($)&&Math.floor($)===$;function X($,J=" | "){return $.map((Y)=>typeof Y==="string"?`'${Y}'`:Y).join(J)}q.joinValues=X,q.jsonStringifyReplacer=($,J)=>{if(typeof J==="bigint")return J.toString();return J}})(F||(F={}));var e3;(function(q){q.mergeShapes=(_,Q)=>{return{..._,...Q}}})(e3||(e3={}));var U=F.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),qq=(q)=>{switch(typeof q){case"undefined":return U.undefined;case"string":return U.string;case"number":return Number.isNaN(q)?U.nan:U.number;case"boolean":return U.boolean;case"function":return U.function;case"bigint":return U.bigint;case"symbol":return U.symbol;case"object":if(Array.isArray(q))return U.array;if(q===null)return U.null;if(q.then&&typeof q.then==="function"&&q.catch&&typeof q.catch==="function")return U.promise;if(typeof Map<"u"&&q instanceof Map)return U.map;if(typeof Set<"u"&&q instanceof Set)return U.set;if(typeof Date<"u"&&q instanceof Date)return U.date;return U.object;default:return U.unknown}};var j=F.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]),_8=(q)=>{return JSON.stringify(q,null,2).replace(/"([^"]+)":/g,"$1:")};class m extends Error{get errors(){return this.issues}constructor(q){super();this.issues=[],this.addIssue=(Q)=>{this.issues=[...this.issues,Q]},this.addIssues=(Q=[])=>{this.issues=[...this.issues,...Q]};let _=new.target.prototype;if(Object.setPrototypeOf)Object.setPrototypeOf(this,_);else this.__proto__=_;this.name="ZodError",this.issues=q}format(q){let _=q||function($){return $.message},Q={_errors:[]},X=($)=>{for(let J of $.issues)if(J.code==="invalid_union")J.unionErrors.map(X);else if(J.code==="invalid_return_type")X(J.returnTypeError);else if(J.code==="invalid_arguments")X(J.argumentsError);else if(J.path.length===0)Q._errors.push(_(J));else{let Y=Q,H=0;while(H<J.path.length){let W=J.path[H];if(H!==J.path.length-1)Y[W]=Y[W]||{_errors:[]};else Y[W]=Y[W]||{_errors:[]},Y[W]._errors.push(_(J));Y=Y[W],H++}}};return X(this),Q}static assert(q){if(!(q instanceof m))throw Error(`Not a ZodError: ${q}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,F.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten(q=(_)=>_.message){let _={},Q=[];for(let X of this.issues)if(X.path.length>0){let $=X.path[0];_[$]=_[$]||[],_[$].push(q(X))}else Q.push(q(X));return{formErrors:Q,fieldErrors:_}}get formErrors(){return this.flatten()}}m.create=(q)=>{return new m(q)};var Q8=(q,_)=>{let Q;switch(q.code){case j.invalid_type:if(q.received===U.undefined)Q="Required";else Q=`Expected ${q.expected}, received ${q.received}`;break;case j.invalid_literal:Q=`Invalid literal value, expected ${JSON.stringify(q.expected,F.jsonStringifyReplacer)}`;break;case j.unrecognized_keys:Q=`Unrecognized key(s) in object: ${F.joinValues(q.keys,", ")}`;break;case j.invalid_union:Q="Invalid input";break;case j.invalid_union_discriminator:Q=`Invalid discriminator value. Expected ${F.joinValues(q.options)}`;break;case j.invalid_enum_value:Q=`Invalid enum value. Expected ${F.joinValues(q.options)}, received '${q.received}'`;break;case j.invalid_arguments:Q="Invalid function arguments";break;case j.invalid_return_type:Q="Invalid function return type";break;case j.invalid_date:Q="Invalid date";break;case j.invalid_string:if(typeof q.validation==="object")if("includes"in q.validation){if(Q=`Invalid input: must include "${q.validation.includes}"`,typeof q.validation.position==="number")Q=`${Q} at one or more positions greater than or equal to ${q.validation.position}`}else if("startsWith"in q.validation)Q=`Invalid input: must start with "${q.validation.startsWith}"`;else if("endsWith"in q.validation)Q=`Invalid input: must end with "${q.validation.endsWith}"`;else F.assertNever(q.validation);else if(q.validation!=="regex")Q=`Invalid ${q.validation}`;else Q="Invalid";break;case j.too_small:if(q.type==="array")Q=`Array must contain ${q.exact?"exactly":q.inclusive?"at least":"more than"} ${q.minimum} element(s)`;else if(q.type==="string")Q=`String must contain ${q.exact?"exactly":q.inclusive?"at least":"over"} ${q.minimum} character(s)`;else if(q.type==="number")Q=`Number must be ${q.exact?"exactly equal to ":q.inclusive?"greater than or equal to ":"greater than "}${q.minimum}`;else if(q.type==="bigint")Q=`Number must be ${q.exact?"exactly equal to ":q.inclusive?"greater than or equal to ":"greater than "}${q.minimum}`;else if(q.type==="date")Q=`Date must be ${q.exact?"exactly equal to ":q.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(q.minimum))}`;else Q="Invalid input";break;case j.too_big:if(q.type==="array")Q=`Array must contain ${q.exact?"exactly":q.inclusive?"at most":"less than"} ${q.maximum} element(s)`;else if(q.type==="string")Q=`String must contain ${q.exact?"exactly":q.inclusive?"at most":"under"} ${q.maximum} character(s)`;else if(q.type==="number")Q=`Number must be ${q.exact?"exactly":q.inclusive?"less than or equal to":"less than"} ${q.maximum}`;else if(q.type==="bigint")Q=`BigInt must be ${q.exact?"exactly":q.inclusive?"less than or equal to":"less than"} ${q.maximum}`;else if(q.type==="date")Q=`Date must be ${q.exact?"exactly":q.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(q.maximum))}`;else Q="Invalid input";break;case j.custom:Q="Invalid input";break;case j.invalid_intersection_types:Q="Intersection results could not be merged";break;case j.not_multiple_of:Q=`Number must be a multiple of ${q.multipleOf}`;break;case j.not_finite:Q="Number must be finite";break;default:Q=_.defaultError,F.assertNever(q)}return{message:Q}},Wq=Q8;var qQ=Wq;function X8(q){qQ=q}function hq(){return qQ}var j3=(q)=>{let{data:_,path:Q,errorMaps:X,issueData:$}=q,J=[...Q,...$.path||[]],Y={...$,path:J};if($.message!==void 0)return{...$,path:J,message:$.message};let H="",W=X.filter((G)=>!!G).slice().reverse();for(let G of W)H=G(Y,{data:_,defaultError:H}).message;return{...$,path:J,message:H}},$8=[];function V(q,_){let Q=hq(),X=j3({issueData:_,data:q.data,path:q.path,errorMaps:[q.common.contextualErrorMap,q.schemaErrorMap,Q,Q===Wq?void 0:Wq].filter(($)=>!!$)});q.common.issues.push(X)}class Z{constructor(){this.value="valid"}dirty(){if(this.value==="valid")this.value="dirty"}abort(){if(this.value!=="aborted")this.value="aborted"}static mergeArray(q,_){let Q=[];for(let X of _){if(X.status==="aborted")return K;if(X.status==="dirty")q.dirty();Q.push(X.value)}return{status:q.value,value:Q}}static async mergeObjectAsync(q,_){let Q=[];for(let X of _){let $=await X.key,J=await X.value;Q.push({key:$,value:J})}return Z.mergeObjectSync(q,Q)}static mergeObjectSync(q,_){let Q={};for(let X of _){let{key:$,value:J}=X;if($.status==="aborted")return K;if(J.status==="aborted")return K;if($.status==="dirty")q.dirty();if(J.status==="dirty")q.dirty();if($.value!=="__proto__"&&(typeof J.value<"u"||X.alwaysSet))Q[$.value]=J.value}return{status:q.value,value:Q}}}var K=Object.freeze({status:"aborted"}),vq=(q)=>({status:"dirty",value:q}),g=(q)=>({status:"valid",value:q}),v3=(q)=>q.status==="aborted",I3=(q)=>q.status==="dirty",Kq=(q)=>q.status==="valid",lq=(q)=>typeof Promise<"u"&&q instanceof Promise;var L;(function(q){q.errToObj=(_)=>typeof _==="string"?{message:_}:_||{},q.toString=(_)=>typeof _==="string"?_:_?.message})(L||(L={}));class a{constructor(q,_,Q,X){this._cachedPath=[],this.parent=q,this.data=_,this._path=Q,this._key=X}get path(){if(!this._cachedPath.length)if(Array.isArray(this._key))this._cachedPath.push(...this._path,...this._key);else this._cachedPath.push(...this._path,this._key);return this._cachedPath}}var _Q=(q,_)=>{if(Kq(_))return{success:!0,data:_.value};else{if(!q.common.issues.length)throw Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;let Q=new m(q.common.issues);return this._error=Q,this._error}}}};function D(q){if(!q)return{};let{errorMap:_,invalid_type_error:Q,required_error:X,description:$}=q;if(_&&(Q||X))throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);if(_)return{errorMap:_,description:$};return{errorMap:(Y,H)=>{let{message:W}=q;if(Y.code==="invalid_enum_value")return{message:W??H.defaultError};if(typeof H.data>"u")return{message:W??X??H.defaultError};if(Y.code!=="invalid_type")return{message:H.defaultError};return{message:W??Q??H.defaultError}},description:$}}class O{get description(){return this._def.description}_getType(q){return qq(q.data)}_getOrReturnCtx(q,_){return _||{common:q.parent.common,data:q.data,parsedType:qq(q.data),schemaErrorMap:this._def.errorMap,path:q.path,parent:q.parent}}_processInputParams(q){return{status:new Z,ctx:{common:q.parent.common,data:q.data,parsedType:qq(q.data),schemaErrorMap:this._def.errorMap,path:q.path,parent:q.parent}}}_parseSync(q){let _=this._parse(q);if(lq(_))throw Error("Synchronous parse encountered promise.");return _}_parseAsync(q){let _=this._parse(q);return Promise.resolve(_)}parse(q,_){let Q=this.safeParse(q,_);if(Q.success)return Q.data;throw Q.error}safeParse(q,_){let Q={common:{issues:[],async:_?.async??!1,contextualErrorMap:_?.errorMap},path:_?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:q,parsedType:qq(q)},X=this._parseSync({data:q,path:Q.path,parent:Q});return _Q(Q,X)}"~validate"(q){let _={common:{issues:[],async:!!this["~standard"].async},path:[],schemaErrorMap:this._def.errorMap,parent:null,data:q,parsedType:qq(q)};if(!this["~standard"].async)try{let Q=this._parseSync({data:q,path:[],parent:_});return Kq(Q)?{value:Q.value}:{issues:_.common.issues}}catch(Q){if(Q?.message?.toLowerCase()?.includes("encountered"))this["~standard"].async=!0;_.common={issues:[],async:!0}}return this._parseAsync({data:q,path:[],parent:_}).then((Q)=>Kq(Q)?{value:Q.value}:{issues:_.common.issues})}async parseAsync(q,_){let Q=await this.safeParseAsync(q,_);if(Q.success)return Q.data;throw Q.error}async safeParseAsync(q,_){let Q={common:{issues:[],contextualErrorMap:_?.errorMap,async:!0},path:_?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:q,parsedType:qq(q)},X=this._parse({data:q,path:Q.path,parent:Q}),$=await(lq(X)?X:Promise.resolve(X));return _Q(Q,$)}refine(q,_){let Q=(X)=>{if(typeof _==="string"||typeof _>"u")return{message:_};else if(typeof _==="function")return _(X);else return _};return this._refinement((X,$)=>{let J=q(X),Y=()=>$.addIssue({code:j.custom,...Q(X)});if(typeof Promise<"u"&&J instanceof Promise)return J.then((H)=>{if(!H)return Y(),!1;else return!0});if(!J)return Y(),!1;else return!0})}refinement(q,_){return this._refinement((Q,X)=>{if(!q(Q))return X.addIssue(typeof _==="function"?_(Q,X):_),!1;else return!0})}_refinement(q){return new t({schema:this,typeName:w.ZodEffects,effect:{type:"refinement",refinement:q}})}superRefine(q){return this._refinement(q)}constructor(q){this.spa=this.safeParseAsync,this._def=q,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this),this["~standard"]={version:1,vendor:"zod",validate:(_)=>this["~validate"](_)}}optional(){return r.create(this,this._def)}nullable(){return zq.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return s.create(this)}promise(){return Pq.create(this,this._def)}or(q){return pq.create([this,q],this._def)}and(q){return nq.create(this,q,this._def)}transform(q){return new t({...D(this._def),schema:this,typeName:w.ZodEffects,effect:{type:"transform",transform:q}})}default(q){let _=typeof q==="function"?q:()=>q;return new aq({...D(this._def),innerType:this,defaultValue:_,typeName:w.ZodDefault})}brand(){return new T3({typeName:w.ZodBranded,type:this,...D(this._def)})}catch(q){let _=typeof q==="function"?q:()=>q;return new tq({...D(this._def),innerType:this,catchValue:_,typeName:w.ZodCatch})}describe(q){return new this.constructor({...this._def,description:q})}pipe(q){return w3.create(this,q)}readonly(){return eq.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}var J8=/^c[^\s-]{8,}$/i,Y8=/^[0-9a-z]+$/,H8=/^[0-9A-HJKMNP-TV-Z]{26}$/i,W8=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,G8=/^[a-z0-9_-]{21}$/i,z8=/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,j8=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,M8=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,U8="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",q_,V8=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,L8=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,K8=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,w8=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,E8=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,A8=/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,XQ="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",B8=new RegExp(`^${XQ}$`);function $Q(q){let _="[0-5]\\d";if(q.precision)_=`${_}\\.\\d{${q.precision}}`;else if(q.precision==null)_=`${_}(\\.\\d+)?`;let Q=q.precision?"+":"?";return`([01]\\d|2[0-3]):[0-5]\\d(:${_})${Q}`}function D8(q){return new RegExp(`^${$Q(q)}$`)}function JQ(q){let _=`${XQ}T${$Q(q)}`,Q=[];if(Q.push(q.local?"Z?":"Z"),q.offset)Q.push("([+-]\\d{2}:?\\d{2})");return _=`${_}(${Q.join("|")})`,new RegExp(`^${_}$`)}function O8(q,_){if((_==="v4"||!_)&&V8.test(q))return!0;if((_==="v6"||!_)&&K8.test(q))return!0;return!1}function S8(q,_){if(!z8.test(q))return!1;try{let[Q]=q.split(".");if(!Q)return!1;let X=Q.replace(/-/g,"+").replace(/_/g,"/").padEnd(Q.length+(4-Q.length%4)%4,"="),$=JSON.parse(atob(X));if(typeof $!=="object"||$===null)return!1;if("typ"in $&&$?.typ!=="JWT")return!1;if(!$.alg)return!1;if(_&&$.alg!==_)return!1;return!0}catch{return!1}}function F8(q,_){if((_==="v4"||!_)&&L8.test(q))return!0;if((_==="v6"||!_)&&w8.test(q))return!0;return!1}class o extends O{_parse(q){if(this._def.coerce)q.data=String(q.data);if(this._getType(q)!==U.string){let $=this._getOrReturnCtx(q);return V($,{code:j.invalid_type,expected:U.string,received:$.parsedType}),K}let Q=new Z,X=void 0;for(let $ of this._def.checks)if($.kind==="min"){if(q.data.length<$.value)X=this._getOrReturnCtx(q,X),V(X,{code:j.too_small,minimum:$.value,type:"string",inclusive:!0,exact:!1,message:$.message}),Q.dirty()}else if($.kind==="max"){if(q.data.length>$.value)X=this._getOrReturnCtx(q,X),V(X,{code:j.too_big,maximum:$.value,type:"string",inclusive:!0,exact:!1,message:$.message}),Q.dirty()}else if($.kind==="length"){let J=q.data.length>$.value,Y=q.data.length<$.value;if(J||Y){if(X=this._getOrReturnCtx(q,X),J)V(X,{code:j.too_big,maximum:$.value,type:"string",inclusive:!0,exact:!0,message:$.message});else if(Y)V(X,{code:j.too_small,minimum:$.value,type:"string",inclusive:!0,exact:!0,message:$.message});Q.dirty()}}else if($.kind==="email"){if(!M8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"email",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="emoji"){if(!q_)q_=new RegExp(U8,"u");if(!q_.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"emoji",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="uuid"){if(!W8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"uuid",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="nanoid"){if(!G8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"nanoid",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="cuid"){if(!J8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"cuid",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="cuid2"){if(!Y8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"cuid2",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="ulid"){if(!H8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"ulid",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="url")try{new URL(q.data)}catch{X=this._getOrReturnCtx(q,X),V(X,{validation:"url",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="regex"){if($.regex.lastIndex=0,!$.regex.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"regex",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="trim")q.data=q.data.trim();else if($.kind==="includes"){if(!q.data.includes($.value,$.position))X=this._getOrReturnCtx(q,X),V(X,{code:j.invalid_string,validation:{includes:$.value,position:$.position},message:$.message}),Q.dirty()}else if($.kind==="toLowerCase")q.data=q.data.toLowerCase();else if($.kind==="toUpperCase")q.data=q.data.toUpperCase();else if($.kind==="startsWith"){if(!q.data.startsWith($.value))X=this._getOrReturnCtx(q,X),V(X,{code:j.invalid_string,validation:{startsWith:$.value},message:$.message}),Q.dirty()}else if($.kind==="endsWith"){if(!q.data.endsWith($.value))X=this._getOrReturnCtx(q,X),V(X,{code:j.invalid_string,validation:{endsWith:$.value},message:$.message}),Q.dirty()}else if($.kind==="datetime"){if(!JQ($).test(q.data))X=this._getOrReturnCtx(q,X),V(X,{code:j.invalid_string,validation:"datetime",message:$.message}),Q.dirty()}else if($.kind==="date"){if(!B8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{code:j.invalid_string,validation:"date",message:$.message}),Q.dirty()}else if($.kind==="time"){if(!D8($).test(q.data))X=this._getOrReturnCtx(q,X),V(X,{code:j.invalid_string,validation:"time",message:$.message}),Q.dirty()}else if($.kind==="duration"){if(!j8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"duration",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="ip"){if(!O8(q.data,$.version))X=this._getOrReturnCtx(q,X),V(X,{validation:"ip",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="jwt"){if(!S8(q.data,$.alg))X=this._getOrReturnCtx(q,X),V(X,{validation:"jwt",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="cidr"){if(!F8(q.data,$.version))X=this._getOrReturnCtx(q,X),V(X,{validation:"cidr",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="base64"){if(!E8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"base64",code:j.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="base64url"){if(!A8.test(q.data))X=this._getOrReturnCtx(q,X),V(X,{validation:"base64url",code:j.invalid_string,message:$.message}),Q.dirty()}else F.assertNever($);return{status:Q.value,value:q.data}}_regex(q,_,Q){return this.refinement((X)=>q.test(X),{validation:_,code:j.invalid_string,...L.errToObj(Q)})}_addCheck(q){return new o({...this._def,checks:[...this._def.checks,q]})}email(q){return this._addCheck({kind:"email",...L.errToObj(q)})}url(q){return this._addCheck({kind:"url",...L.errToObj(q)})}emoji(q){return this._addCheck({kind:"emoji",...L.errToObj(q)})}uuid(q){return this._addCheck({kind:"uuid",...L.errToObj(q)})}nanoid(q){return this._addCheck({kind:"nanoid",...L.errToObj(q)})}cuid(q){return this._addCheck({kind:"cuid",...L.errToObj(q)})}cuid2(q){return this._addCheck({kind:"cuid2",...L.errToObj(q)})}ulid(q){return this._addCheck({kind:"ulid",...L.errToObj(q)})}base64(q){return this._addCheck({kind:"base64",...L.errToObj(q)})}base64url(q){return this._addCheck({kind:"base64url",...L.errToObj(q)})}jwt(q){return this._addCheck({kind:"jwt",...L.errToObj(q)})}ip(q){return this._addCheck({kind:"ip",...L.errToObj(q)})}cidr(q){return this._addCheck({kind:"cidr",...L.errToObj(q)})}datetime(q){if(typeof q==="string")return this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:q});return this._addCheck({kind:"datetime",precision:typeof q?.precision>"u"?null:q?.precision,offset:q?.offset??!1,local:q?.local??!1,...L.errToObj(q?.message)})}date(q){return this._addCheck({kind:"date",message:q})}time(q){if(typeof q==="string")return this._addCheck({kind:"time",precision:null,message:q});return this._addCheck({kind:"time",precision:typeof q?.precision>"u"?null:q?.precision,...L.errToObj(q?.message)})}duration(q){return this._addCheck({kind:"duration",...L.errToObj(q)})}regex(q,_){return this._addCheck({kind:"regex",regex:q,...L.errToObj(_)})}includes(q,_){return this._addCheck({kind:"includes",value:q,position:_?.position,...L.errToObj(_?.message)})}startsWith(q,_){return this._addCheck({kind:"startsWith",value:q,...L.errToObj(_)})}endsWith(q,_){return this._addCheck({kind:"endsWith",value:q,...L.errToObj(_)})}min(q,_){return this._addCheck({kind:"min",value:q,...L.errToObj(_)})}max(q,_){return this._addCheck({kind:"max",value:q,...L.errToObj(_)})}length(q,_){return this._addCheck({kind:"length",value:q,...L.errToObj(_)})}nonempty(q){return this.min(1,L.errToObj(q))}trim(){return new o({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new o({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new o({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find((q)=>q.kind==="datetime")}get isDate(){return!!this._def.checks.find((q)=>q.kind==="date")}get isTime(){return!!this._def.checks.find((q)=>q.kind==="time")}get isDuration(){return!!this._def.checks.find((q)=>q.kind==="duration")}get isEmail(){return!!this._def.checks.find((q)=>q.kind==="email")}get isURL(){return!!this._def.checks.find((q)=>q.kind==="url")}get isEmoji(){return!!this._def.checks.find((q)=>q.kind==="emoji")}get isUUID(){return!!this._def.checks.find((q)=>q.kind==="uuid")}get isNANOID(){return!!this._def.checks.find((q)=>q.kind==="nanoid")}get isCUID(){return!!this._def.checks.find((q)=>q.kind==="cuid")}get isCUID2(){return!!this._def.checks.find((q)=>q.kind==="cuid2")}get isULID(){return!!this._def.checks.find((q)=>q.kind==="ulid")}get isIP(){return!!this._def.checks.find((q)=>q.kind==="ip")}get isCIDR(){return!!this._def.checks.find((q)=>q.kind==="cidr")}get isBase64(){return!!this._def.checks.find((q)=>q.kind==="base64")}get isBase64url(){return!!this._def.checks.find((q)=>q.kind==="base64url")}get minLength(){let q=null;for(let _ of this._def.checks)if(_.kind==="min"){if(q===null||_.value>q)q=_.value}return q}get maxLength(){let q=null;for(let _ of this._def.checks)if(_.kind==="max"){if(q===null||_.value<q)q=_.value}return q}}o.create=(q)=>{return new o({checks:[],typeName:w.ZodString,coerce:q?.coerce??!1,...D(q)})};function N8(q,_){let Q=(q.toString().split(".")[1]||"").length,X=(_.toString().split(".")[1]||"").length,$=Q>X?Q:X,J=Number.parseInt(q.toFixed($).replace(".","")),Y=Number.parseInt(_.toFixed($).replace(".",""));return J%Y/10**$}class Eq extends O{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(q){if(this._def.coerce)q.data=Number(q.data);if(this._getType(q)!==U.number){let $=this._getOrReturnCtx(q);return V($,{code:j.invalid_type,expected:U.number,received:$.parsedType}),K}let Q=void 0,X=new Z;for(let $ of this._def.checks)if($.kind==="int"){if(!F.isInteger(q.data))Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.invalid_type,expected:"integer",received:"float",message:$.message}),X.dirty()}else if($.kind==="min"){if($.inclusive?q.data<$.value:q.data<=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.too_small,minimum:$.value,type:"number",inclusive:$.inclusive,exact:!1,message:$.message}),X.dirty()}else if($.kind==="max"){if($.inclusive?q.data>$.value:q.data>=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.too_big,maximum:$.value,type:"number",inclusive:$.inclusive,exact:!1,message:$.message}),X.dirty()}else if($.kind==="multipleOf"){if(N8(q.data,$.value)!==0)Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.not_multiple_of,multipleOf:$.value,message:$.message}),X.dirty()}else if($.kind==="finite"){if(!Number.isFinite(q.data))Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.not_finite,message:$.message}),X.dirty()}else F.assertNever($);return{status:X.value,value:q.data}}gte(q,_){return this.setLimit("min",q,!0,L.toString(_))}gt(q,_){return this.setLimit("min",q,!1,L.toString(_))}lte(q,_){return this.setLimit("max",q,!0,L.toString(_))}lt(q,_){return this.setLimit("max",q,!1,L.toString(_))}setLimit(q,_,Q,X){return new Eq({...this._def,checks:[...this._def.checks,{kind:q,value:_,inclusive:Q,message:L.toString(X)}]})}_addCheck(q){return new Eq({...this._def,checks:[...this._def.checks,q]})}int(q){return this._addCheck({kind:"int",message:L.toString(q)})}positive(q){return this._addCheck({kind:"min",value:0,inclusive:!1,message:L.toString(q)})}negative(q){return this._addCheck({kind:"max",value:0,inclusive:!1,message:L.toString(q)})}nonpositive(q){return this._addCheck({kind:"max",value:0,inclusive:!0,message:L.toString(q)})}nonnegative(q){return this._addCheck({kind:"min",value:0,inclusive:!0,message:L.toString(q)})}multipleOf(q,_){return this._addCheck({kind:"multipleOf",value:q,message:L.toString(_)})}finite(q){return this._addCheck({kind:"finite",message:L.toString(q)})}safe(q){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:L.toString(q)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:L.toString(q)})}get minValue(){let q=null;for(let _ of this._def.checks)if(_.kind==="min"){if(q===null||_.value>q)q=_.value}return q}get maxValue(){let q=null;for(let _ of this._def.checks)if(_.kind==="max"){if(q===null||_.value<q)q=_.value}return q}get isInt(){return!!this._def.checks.find((q)=>q.kind==="int"||q.kind==="multipleOf"&&F.isInteger(q.value))}get isFinite(){let q=null,_=null;for(let Q of this._def.checks)if(Q.kind==="finite"||Q.kind==="int"||Q.kind==="multipleOf")return!0;else if(Q.kind==="min"){if(_===null||Q.value>_)_=Q.value}else if(Q.kind==="max"){if(q===null||Q.value<q)q=Q.value}return Number.isFinite(_)&&Number.isFinite(q)}}Eq.create=(q)=>{return new Eq({checks:[],typeName:w.ZodNumber,coerce:q?.coerce||!1,...D(q)})};class Aq extends O{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte}_parse(q){if(this._def.coerce)try{q.data=BigInt(q.data)}catch{return this._getInvalidInput(q)}if(this._getType(q)!==U.bigint)return this._getInvalidInput(q);let Q=void 0,X=new Z;for(let $ of this._def.checks)if($.kind==="min"){if($.inclusive?q.data<$.value:q.data<=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.too_small,type:"bigint",minimum:$.value,inclusive:$.inclusive,message:$.message}),X.dirty()}else if($.kind==="max"){if($.inclusive?q.data>$.value:q.data>=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.too_big,type:"bigint",maximum:$.value,inclusive:$.inclusive,message:$.message}),X.dirty()}else if($.kind==="multipleOf"){if(q.data%$.value!==BigInt(0))Q=this._getOrReturnCtx(q,Q),V(Q,{code:j.not_multiple_of,multipleOf:$.value,message:$.message}),X.dirty()}else F.assertNever($);return{status:X.value,value:q.data}}_getInvalidInput(q){let _=this._getOrReturnCtx(q);return V(_,{code:j.invalid_type,expected:U.bigint,received:_.parsedType}),K}gte(q,_){return this.setLimit("min",q,!0,L.toString(_))}gt(q,_){return this.setLimit("min",q,!1,L.toString(_))}lte(q,_){return this.setLimit("max",q,!0,L.toString(_))}lt(q,_){return this.setLimit("max",q,!1,L.toString(_))}setLimit(q,_,Q,X){return new Aq({...this._def,checks:[...this._def.checks,{kind:q,value:_,inclusive:Q,message:L.toString(X)}]})}_addCheck(q){return new Aq({...this._def,checks:[...this._def.checks,q]})}positive(q){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:L.toString(q)})}negative(q){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:L.toString(q)})}nonpositive(q){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:L.toString(q)})}nonnegative(q){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:L.toString(q)})}multipleOf(q,_){return this._addCheck({kind:"multipleOf",value:q,message:L.toString(_)})}get minValue(){let q=null;for(let _ of this._def.checks)if(_.kind==="min"){if(q===null||_.value>q)q=_.value}return q}get maxValue(){let q=null;for(let _ of this._def.checks)if(_.kind==="max"){if(q===null||_.value<q)q=_.value}return q}}Aq.create=(q)=>{return new Aq({checks:[],typeName:w.ZodBigInt,coerce:q?.coerce??!1,...D(q)})};class dq extends O{_parse(q){if(this._def.coerce)q.data=Boolean(q.data);if(this._getType(q)!==U.boolean){let Q=this._getOrReturnCtx(q);return V(Q,{code:j.invalid_type,expected:U.boolean,received:Q.parsedType}),K}return g(q.data)}}dq.create=(q)=>{return new dq({typeName:w.ZodBoolean,coerce:q?.coerce||!1,...D(q)})};class Iq extends O{_parse(q){if(this._def.coerce)q.data=new Date(q.data);if(this._getType(q)!==U.date){let $=this._getOrReturnCtx(q);return V($,{code:j.invalid_type,expected:U.date,received:$.parsedType}),K}if(Number.isNaN(q.data.getTime())){let $=this._getOrReturnCtx(q);return V($,{code:j.invalid_date}),K}let Q=new Z,X=void 0;for(let $ of this._def.checks)if($.kind==="min"){if(q.data.getTime()<$.value)X=this._getOrReturnCtx(q,X),V(X,{code:j.too_small,message:$.message,inclusive:!0,exact:!1,minimum:$.value,type:"date"}),Q.dirty()}else if($.kind==="max"){if(q.data.getTime()>$.value)X=this._getOrReturnCtx(q,X),V(X,{code:j.too_big,message:$.message,inclusive:!0,exact:!1,maximum:$.value,type:"date"}),Q.dirty()}else F.assertNever($);return{status:Q.value,value:new Date(q.data.getTime())}}_addCheck(q){return new Iq({...this._def,checks:[...this._def.checks,q]})}min(q,_){return this._addCheck({kind:"min",value:q.getTime(),message:L.toString(_)})}max(q,_){return this._addCheck({kind:"max",value:q.getTime(),message:L.toString(_)})}get minDate(){let q=null;for(let _ of this._def.checks)if(_.kind==="min"){if(q===null||_.value>q)q=_.value}return q!=null?new Date(q):null}get maxDate(){let q=null;for(let _ of this._def.checks)if(_.kind==="max"){if(q===null||_.value<q)q=_.value}return q!=null?new Date(q):null}}Iq.create=(q)=>{return new Iq({checks:[],coerce:q?.coerce||!1,typeName:w.ZodDate,...D(q)})};class M3 extends O{_parse(q){if(this._getType(q)!==U.symbol){let Q=this._getOrReturnCtx(q);return V(Q,{code:j.invalid_type,expected:U.symbol,received:Q.parsedType}),K}return g(q.data)}}M3.create=(q)=>{return new M3({typeName:w.ZodSymbol,...D(q)})};class cq extends O{_parse(q){if(this._getType(q)!==U.undefined){let Q=this._getOrReturnCtx(q);return V(Q,{code:j.invalid_type,expected:U.undefined,received:Q.parsedType}),K}return g(q.data)}}cq.create=(q)=>{return new cq({typeName:w.ZodUndefined,...D(q)})};class iq extends O{_parse(q){if(this._getType(q)!==U.null){let Q=this._getOrReturnCtx(q);return V(Q,{code:j.invalid_type,expected:U.null,received:Q.parsedType}),K}return g(q.data)}}iq.create=(q)=>{return new iq({typeName:w.ZodNull,...D(q)})};class Rq extends O{constructor(){super(...arguments);this._any=!0}_parse(q){return g(q.data)}}Rq.create=(q)=>{return new Rq({typeName:w.ZodAny,...D(q)})};class wq extends O{constructor(){super(...arguments);this._unknown=!0}_parse(q){return g(q.data)}}wq.create=(q)=>{return new wq({typeName:w.ZodUnknown,...D(q)})};class _q extends O{_parse(q){let _=this._getOrReturnCtx(q);return V(_,{code:j.invalid_type,expected:U.never,received:_.parsedType}),K}}_q.create=(q)=>{return new _q({typeName:w.ZodNever,...D(q)})};class U3 extends O{_parse(q){if(this._getType(q)!==U.undefined){let Q=this._getOrReturnCtx(q);return V(Q,{code:j.invalid_type,expected:U.void,received:Q.parsedType}),K}return g(q.data)}}U3.create=(q)=>{return new U3({typeName:w.ZodVoid,...D(q)})};class s extends O{_parse(q){let{ctx:_,status:Q}=this._processInputParams(q),X=this._def;if(_.parsedType!==U.array)return V(_,{code:j.invalid_type,expected:U.array,received:_.parsedType}),K;if(X.exactLength!==null){let J=_.data.length>X.exactLength.value,Y=_.data.length<X.exactLength.value;if(J||Y)V(_,{code:J?j.too_big:j.too_small,minimum:Y?X.exactLength.value:void 0,maximum:J?X.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:X.exactLength.message}),Q.dirty()}if(X.minLength!==null){if(_.data.length<X.minLength.value)V(_,{code:j.too_small,minimum:X.minLength.value,type:"array",inclusive:!0,exact:!1,message:X.minLength.message}),Q.dirty()}if(X.maxLength!==null){if(_.data.length>X.maxLength.value)V(_,{code:j.too_big,maximum:X.maxLength.value,type:"array",inclusive:!0,exact:!1,message:X.maxLength.message}),Q.dirty()}if(_.common.async)return Promise.all([..._.data].map((J,Y)=>{return X.type._parseAsync(new a(_,J,_.path,Y))})).then((J)=>{return Z.mergeArray(Q,J)});let $=[..._.data].map((J,Y)=>{return X.type._parseSync(new a(_,J,_.path,Y))});return Z.mergeArray(Q,$)}get element(){return this._def.type}min(q,_){return new s({...this._def,minLength:{value:q,message:L.toString(_)}})}max(q,_){return new s({...this._def,maxLength:{value:q,message:L.toString(_)}})}length(q,_){return new s({...this._def,exactLength:{value:q,message:L.toString(_)}})}nonempty(q){return this.min(1,q)}}s.create=(q,_)=>{return new s({type:q,minLength:null,maxLength:null,exactLength:null,typeName:w.ZodArray,...D(_)})};function uq(q){if(q instanceof P){let _={};for(let Q in q.shape){let X=q.shape[Q];_[Q]=r.create(uq(X))}return new P({...q._def,shape:()=>_})}else if(q instanceof s)return new s({...q._def,type:uq(q.element)});else if(q instanceof r)return r.create(uq(q.unwrap()));else if(q instanceof zq)return zq.create(uq(q.unwrap()));else if(q instanceof Qq)return Qq.create(q.items.map((_)=>uq(_)));else return q}class P extends O{constructor(){super(...arguments);this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;let q=this._def.shape(),_=F.objectKeys(q);return this._cached={shape:q,keys:_},this._cached}_parse(q){if(this._getType(q)!==U.object){let W=this._getOrReturnCtx(q);return V(W,{code:j.invalid_type,expected:U.object,received:W.parsedType}),K}let{status:Q,ctx:X}=this._processInputParams(q),{shape:$,keys:J}=this._getCached(),Y=[];if(!(this._def.catchall instanceof _q&&this._def.unknownKeys==="strip")){for(let W in X.data)if(!J.includes(W))Y.push(W)}let H=[];for(let W of J){let G=$[W],z=X.data[W];H.push({key:{status:"valid",value:W},value:G._parse(new a(X,z,X.path,W)),alwaysSet:W in X.data})}if(this._def.catchall instanceof _q){let W=this._def.unknownKeys;if(W==="passthrough")for(let G of Y)H.push({key:{status:"valid",value:G},value:{status:"valid",value:X.data[G]}});else if(W==="strict"){if(Y.length>0)V(X,{code:j.unrecognized_keys,keys:Y}),Q.dirty()}else if(W==="strip");else throw Error("Internal ZodObject error: invalid unknownKeys value.")}else{let W=this._def.catchall;for(let G of Y){let z=X.data[G];H.push({key:{status:"valid",value:G},value:W._parse(new a(X,z,X.path,G)),alwaysSet:G in X.data})}}if(X.common.async)return Promise.resolve().then(async()=>{let W=[];for(let G of H){let z=await G.key,M=await G.value;W.push({key:z,value:M,alwaysSet:G.alwaysSet})}return W}).then((W)=>{return Z.mergeObjectSync(Q,W)});else return Z.mergeObjectSync(Q,H)}get shape(){return this._def.shape()}strict(q){return L.errToObj,new P({...this._def,unknownKeys:"strict",...q!==void 0?{errorMap:(_,Q)=>{let X=this._def.errorMap?.(_,Q).message??Q.defaultError;if(_.code==="unrecognized_keys")return{message:L.errToObj(q).message??X};return{message:X}}}:{}})}strip(){return new P({...this._def,unknownKeys:"strip"})}passthrough(){return new P({...this._def,unknownKeys:"passthrough"})}extend(q){return new P({...this._def,shape:()=>({...this._def.shape(),...q})})}merge(q){return new P({unknownKeys:q._def.unknownKeys,catchall:q._def.catchall,shape:()=>({...this._def.shape(),...q._def.shape()}),typeName:w.ZodObject})}setKey(q,_){return this.augment({[q]:_})}catchall(q){return new P({...this._def,catchall:q})}pick(q){let _={};for(let Q of F.objectKeys(q))if(q[Q]&&this.shape[Q])_[Q]=this.shape[Q];return new P({...this._def,shape:()=>_})}omit(q){let _={};for(let Q of F.objectKeys(this.shape))if(!q[Q])_[Q]=this.shape[Q];return new P({...this._def,shape:()=>_})}deepPartial(){return uq(this)}partial(q){let _={};for(let Q of F.objectKeys(this.shape)){let X=this.shape[Q];if(q&&!q[Q])_[Q]=X;else _[Q]=X.optional()}return new P({...this._def,shape:()=>_})}required(q){let _={};for(let Q of F.objectKeys(this.shape))if(q&&!q[Q])_[Q]=this.shape[Q];else{let $=this.shape[Q];while($ instanceof r)$=$._def.innerType;_[Q]=$}return new P({...this._def,shape:()=>_})}keyof(){return YQ(F.objectKeys(this.shape))}}P.create=(q,_)=>{return new P({shape:()=>q,unknownKeys:"strip",catchall:_q.create(),typeName:w.ZodObject,...D(_)})};P.strictCreate=(q,_)=>{return new P({shape:()=>q,unknownKeys:"strict",catchall:_q.create(),typeName:w.ZodObject,...D(_)})};P.lazycreate=(q,_)=>{return new P({shape:q,unknownKeys:"strip",catchall:_q.create(),typeName:w.ZodObject,...D(_)})};class pq extends O{_parse(q){let{ctx:_}=this._processInputParams(q),Q=this._def.options;function X($){for(let Y of $)if(Y.result.status==="valid")return Y.result;for(let Y of $)if(Y.result.status==="dirty")return _.common.issues.push(...Y.ctx.common.issues),Y.result;let J=$.map((Y)=>new m(Y.ctx.common.issues));return V(_,{code:j.invalid_union,unionErrors:J}),K}if(_.common.async)return Promise.all(Q.map(async($)=>{let J={..._,common:{..._.common,issues:[]},parent:null};return{result:await $._parseAsync({data:_.data,path:_.path,parent:J}),ctx:J}})).then(X);else{let $=void 0,J=[];for(let H of Q){let W={..._,common:{..._.common,issues:[]},parent:null},G=H._parseSync({data:_.data,path:_.path,parent:W});if(G.status==="valid")return G;else if(G.status==="dirty"&&!$)$={result:G,ctx:W};if(W.common.issues.length)J.push(W.common.issues)}if($)return _.common.issues.push(...$.ctx.common.issues),$.result;let Y=J.map((H)=>new m(H));return V(_,{code:j.invalid_union,unionErrors:Y}),K}}get options(){return this._def.options}}pq.create=(q,_)=>{return new pq({options:q,typeName:w.ZodUnion,...D(_)})};var Gq=(q)=>{if(q instanceof oq)return Gq(q.schema);else if(q instanceof t)return Gq(q.innerType());else if(q instanceof sq)return[q.value];else if(q instanceof Bq)return q.options;else if(q instanceof rq)return F.objectValues(q.enum);else if(q instanceof aq)return Gq(q._def.innerType);else if(q instanceof cq)return[void 0];else if(q instanceof iq)return[null];else if(q instanceof r)return[void 0,...Gq(q.unwrap())];else if(q instanceof zq)return[null,...Gq(q.unwrap())];else if(q instanceof T3)return Gq(q.unwrap());else if(q instanceof eq)return Gq(q.unwrap());else if(q instanceof tq)return Gq(q._def.innerType);else return[]};class R3 extends O{_parse(q){let{ctx:_}=this._processInputParams(q);if(_.parsedType!==U.object)return V(_,{code:j.invalid_type,expected:U.object,received:_.parsedType}),K;let Q=this.discriminator,X=_.data[Q],$=this.optionsMap.get(X);if(!$)return V(_,{code:j.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[Q]}),K;if(_.common.async)return $._parseAsync({data:_.data,path:_.path,parent:_});else return $._parseSync({data:_.data,path:_.path,parent:_})}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(q,_,Q){let X=new Map;for(let $ of _){let J=Gq($.shape[q]);if(!J.length)throw Error(`A discriminator value for key \`${q}\` could not be extracted from all schema options`);for(let Y of J){if(X.has(Y))throw Error(`Discriminator property ${String(q)} has duplicate value ${String(Y)}`);X.set(Y,$)}}return new R3({typeName:w.ZodDiscriminatedUnion,discriminator:q,options:_,optionsMap:X,...D(Q)})}}function __(q,_){let Q=qq(q),X=qq(_);if(q===_)return{valid:!0,data:q};else if(Q===U.object&&X===U.object){let $=F.objectKeys(_),J=F.objectKeys(q).filter((H)=>$.indexOf(H)!==-1),Y={...q,..._};for(let H of J){let W=__(q[H],_[H]);if(!W.valid)return{valid:!1};Y[H]=W.data}return{valid:!0,data:Y}}else if(Q===U.array&&X===U.array){if(q.length!==_.length)return{valid:!1};let $=[];for(let J=0;J<q.length;J++){let Y=q[J],H=_[J],W=__(Y,H);if(!W.valid)return{valid:!1};$.push(W.data)}return{valid:!0,data:$}}else if(Q===U.date&&X===U.date&&+q===+_)return{valid:!0,data:q};else return{valid:!1}}class nq extends O{_parse(q){let{status:_,ctx:Q}=this._processInputParams(q),X=($,J)=>{if(v3($)||v3(J))return K;let Y=__($.value,J.value);if(!Y.valid)return V(Q,{code:j.invalid_intersection_types}),K;if(I3($)||I3(J))_.dirty();return{status:_.value,value:Y.data}};if(Q.common.async)return Promise.all([this._def.left._parseAsync({data:Q.data,path:Q.path,parent:Q}),this._def.right._parseAsync({data:Q.data,path:Q.path,parent:Q})]).then(([$,J])=>X($,J));else return X(this._def.left._parseSync({data:Q.data,path:Q.path,parent:Q}),this._def.right._parseSync({data:Q.data,path:Q.path,parent:Q}))}}nq.create=(q,_,Q)=>{return new nq({left:q,right:_,typeName:w.ZodIntersection,...D(Q)})};class Qq extends O{_parse(q){let{status:_,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==U.array)return V(Q,{code:j.invalid_type,expected:U.array,received:Q.parsedType}),K;if(Q.data.length<this._def.items.length)return V(Q,{code:j.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),K;if(!this._def.rest&&Q.data.length>this._def.items.length)V(Q,{code:j.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),_.dirty();let $=[...Q.data].map((J,Y)=>{let H=this._def.items[Y]||this._def.rest;if(!H)return null;return H._parse(new a(Q,J,Q.path,Y))}).filter((J)=>!!J);if(Q.common.async)return Promise.all($).then((J)=>{return Z.mergeArray(_,J)});else return Z.mergeArray(_,$)}get items(){return this._def.items}rest(q){return new Qq({...this._def,rest:q})}}Qq.create=(q,_)=>{if(!Array.isArray(q))throw Error("You must pass an array of schemas to z.tuple([ ... ])");return new Qq({items:q,typeName:w.ZodTuple,rest:null,...D(_)})};class V3 extends O{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(q){let{status:_,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==U.object)return V(Q,{code:j.invalid_type,expected:U.object,received:Q.parsedType}),K;let X=[],$=this._def.keyType,J=this._def.valueType;for(let Y in Q.data)X.push({key:$._parse(new a(Q,Y,Q.path,Y)),value:J._parse(new a(Q,Q.data[Y],Q.path,Y)),alwaysSet:Y in Q.data});if(Q.common.async)return Z.mergeObjectAsync(_,X);else return Z.mergeObjectSync(_,X)}get element(){return this._def.valueType}static create(q,_,Q){if(_ instanceof O)return new V3({keyType:q,valueType:_,typeName:w.ZodRecord,...D(Q)});return new V3({keyType:o.create(),valueType:q,typeName:w.ZodRecord,...D(_)})}}class L3 extends O{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(q){let{status:_,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==U.map)return V(Q,{code:j.invalid_type,expected:U.map,received:Q.parsedType}),K;let X=this._def.keyType,$=this._def.valueType,J=[...Q.data.entries()].map(([Y,H],W)=>{return{key:X._parse(new a(Q,Y,Q.path,[W,"key"])),value:$._parse(new a(Q,H,Q.path,[W,"value"]))}});if(Q.common.async){let Y=new Map;return Promise.resolve().then(async()=>{for(let H of J){let W=await H.key,G=await H.value;if(W.status==="aborted"||G.status==="aborted")return K;if(W.status==="dirty"||G.status==="dirty")_.dirty();Y.set(W.value,G.value)}return{status:_.value,value:Y}})}else{let Y=new Map;for(let H of J){let{key:W,value:G}=H;if(W.status==="aborted"||G.status==="aborted")return K;if(W.status==="dirty"||G.status==="dirty")_.dirty();Y.set(W.value,G.value)}return{status:_.value,value:Y}}}}L3.create=(q,_,Q)=>{return new L3({valueType:_,keyType:q,typeName:w.ZodMap,...D(Q)})};class Tq extends O{_parse(q){let{status:_,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==U.set)return V(Q,{code:j.invalid_type,expected:U.set,received:Q.parsedType}),K;let X=this._def;if(X.minSize!==null){if(Q.data.size<X.minSize.value)V(Q,{code:j.too_small,minimum:X.minSize.value,type:"set",inclusive:!0,exact:!1,message:X.minSize.message}),_.dirty()}if(X.maxSize!==null){if(Q.data.size>X.maxSize.value)V(Q,{code:j.too_big,maximum:X.maxSize.value,type:"set",inclusive:!0,exact:!1,message:X.maxSize.message}),_.dirty()}let $=this._def.valueType;function J(H){let W=new Set;for(let G of H){if(G.status==="aborted")return K;if(G.status==="dirty")_.dirty();W.add(G.value)}return{status:_.value,value:W}}let Y=[...Q.data.values()].map((H,W)=>$._parse(new a(Q,H,Q.path,W)));if(Q.common.async)return Promise.all(Y).then((H)=>J(H));else return J(Y)}min(q,_){return new Tq({...this._def,minSize:{value:q,message:L.toString(_)}})}max(q,_){return new Tq({...this._def,maxSize:{value:q,message:L.toString(_)}})}size(q,_){return this.min(q,_).max(q,_)}nonempty(q){return this.min(1,q)}}Tq.create=(q,_)=>{return new Tq({valueType:q,minSize:null,maxSize:null,typeName:w.ZodSet,...D(_)})};class mq extends O{constructor(){super(...arguments);this.validate=this.implement}_parse(q){let{ctx:_}=this._processInputParams(q);if(_.parsedType!==U.function)return V(_,{code:j.invalid_type,expected:U.function,received:_.parsedType}),K;function Q(Y,H){return j3({data:Y,path:_.path,errorMaps:[_.common.contextualErrorMap,_.schemaErrorMap,hq(),Wq].filter((W)=>!!W),issueData:{code:j.invalid_arguments,argumentsError:H}})}function X(Y,H){return j3({data:Y,path:_.path,errorMaps:[_.common.contextualErrorMap,_.schemaErrorMap,hq(),Wq].filter((W)=>!!W),issueData:{code:j.invalid_return_type,returnTypeError:H}})}let $={errorMap:_.common.contextualErrorMap},J=_.data;if(this._def.returns instanceof Pq){let Y=this;return g(async function(...H){let W=new m([]),G=await Y._def.args.parseAsync(H,$).catch((E)=>{throw W.addIssue(Q(H,E)),W}),z=await Reflect.apply(J,this,G);return await Y._def.returns._def.type.parseAsync(z,$).catch((E)=>{throw W.addIssue(X(z,E)),W})})}else{let Y=this;return g(function(...H){let W=Y._def.args.safeParse(H,$);if(!W.success)throw new m([Q(H,W.error)]);let G=Reflect.apply(J,this,W.data),z=Y._def.returns.safeParse(G,$);if(!z.success)throw new m([X(G,z.error)]);return z.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...q){return new mq({...this._def,args:Qq.create(q).rest(wq.create())})}returns(q){return new mq({...this._def,returns:q})}implement(q){return this.parse(q)}strictImplement(q){return this.parse(q)}static create(q,_,Q){return new mq({args:q?q:Qq.create([]).rest(wq.create()),returns:_||wq.create(),typeName:w.ZodFunction,...D(Q)})}}class oq extends O{get schema(){return this._def.getter()}_parse(q){let{ctx:_}=this._processInputParams(q);return this._def.getter()._parse({data:_.data,path:_.path,parent:_})}}oq.create=(q,_)=>{return new oq({getter:q,typeName:w.ZodLazy,...D(_)})};class sq extends O{_parse(q){if(q.data!==this._def.value){let _=this._getOrReturnCtx(q);return V(_,{received:_.data,code:j.invalid_literal,expected:this._def.value}),K}return{status:"valid",value:q.data}}get value(){return this._def.value}}sq.create=(q,_)=>{return new sq({value:q,typeName:w.ZodLiteral,...D(_)})};function YQ(q,_){return new Bq({values:q,typeName:w.ZodEnum,...D(_)})}class Bq extends O{_parse(q){if(typeof q.data!=="string"){let _=this._getOrReturnCtx(q),Q=this._def.values;return V(_,{expected:F.joinValues(Q),received:_.parsedType,code:j.invalid_type}),K}if(!this._cache)this._cache=new Set(this._def.values);if(!this._cache.has(q.data)){let _=this._getOrReturnCtx(q),Q=this._def.values;return V(_,{received:_.data,code:j.invalid_enum_value,options:Q}),K}return g(q.data)}get options(){return this._def.values}get enum(){let q={};for(let _ of this._def.values)q[_]=_;return q}get Values(){let q={};for(let _ of this._def.values)q[_]=_;return q}get Enum(){let q={};for(let _ of this._def.values)q[_]=_;return q}extract(q,_=this._def){return Bq.create(q,{...this._def,..._})}exclude(q,_=this._def){return Bq.create(this.options.filter((Q)=>!q.includes(Q)),{...this._def,..._})}}Bq.create=YQ;class rq extends O{_parse(q){let _=F.getValidEnumValues(this._def.values),Q=this._getOrReturnCtx(q);if(Q.parsedType!==U.string&&Q.parsedType!==U.number){let X=F.objectValues(_);return V(Q,{expected:F.joinValues(X),received:Q.parsedType,code:j.invalid_type}),K}if(!this._cache)this._cache=new Set(F.getValidEnumValues(this._def.values));if(!this._cache.has(q.data)){let X=F.objectValues(_);return V(Q,{received:Q.data,code:j.invalid_enum_value,options:X}),K}return g(q.data)}get enum(){return this._def.values}}rq.create=(q,_)=>{return new rq({values:q,typeName:w.ZodNativeEnum,...D(_)})};class Pq extends O{unwrap(){return this._def.type}_parse(q){let{ctx:_}=this._processInputParams(q);if(_.parsedType!==U.promise&&_.common.async===!1)return V(_,{code:j.invalid_type,expected:U.promise,received:_.parsedType}),K;let Q=_.parsedType===U.promise?_.data:Promise.resolve(_.data);return g(Q.then((X)=>{return this._def.type.parseAsync(X,{path:_.path,errorMap:_.common.contextualErrorMap})}))}}Pq.create=(q,_)=>{return new Pq({type:q,typeName:w.ZodPromise,...D(_)})};class t extends O{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===w.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(q){let{status:_,ctx:Q}=this._processInputParams(q),X=this._def.effect||null,$={addIssue:(J)=>{if(V(Q,J),J.fatal)_.abort();else _.dirty()},get path(){return Q.path}};if($.addIssue=$.addIssue.bind($),X.type==="preprocess"){let J=X.transform(Q.data,$);if(Q.common.async)return Promise.resolve(J).then(async(Y)=>{if(_.value==="aborted")return K;let H=await this._def.schema._parseAsync({data:Y,path:Q.path,parent:Q});if(H.status==="aborted")return K;if(H.status==="dirty")return vq(H.value);if(_.value==="dirty")return vq(H.value);return H});else{if(_.value==="aborted")return K;let Y=this._def.schema._parseSync({data:J,path:Q.path,parent:Q});if(Y.status==="aborted")return K;if(Y.status==="dirty")return vq(Y.value);if(_.value==="dirty")return vq(Y.value);return Y}}if(X.type==="refinement"){let J=(Y)=>{let H=X.refinement(Y,$);if(Q.common.async)return Promise.resolve(H);if(H instanceof Promise)throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return Y};if(Q.common.async===!1){let Y=this._def.schema._parseSync({data:Q.data,path:Q.path,parent:Q});if(Y.status==="aborted")return K;if(Y.status==="dirty")_.dirty();return J(Y.value),{status:_.value,value:Y.value}}else return this._def.schema._parseAsync({data:Q.data,path:Q.path,parent:Q}).then((Y)=>{if(Y.status==="aborted")return K;if(Y.status==="dirty")_.dirty();return J(Y.value).then(()=>{return{status:_.value,value:Y.value}})})}if(X.type==="transform")if(Q.common.async===!1){let J=this._def.schema._parseSync({data:Q.data,path:Q.path,parent:Q});if(!Kq(J))return K;let Y=X.transform(J.value,$);if(Y instanceof Promise)throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:_.value,value:Y}}else return this._def.schema._parseAsync({data:Q.data,path:Q.path,parent:Q}).then((J)=>{if(!Kq(J))return K;return Promise.resolve(X.transform(J.value,$)).then((Y)=>({status:_.value,value:Y}))});F.assertNever(X)}}t.create=(q,_,Q)=>{return new t({schema:q,typeName:w.ZodEffects,effect:_,...D(Q)})};t.createWithPreprocess=(q,_,Q)=>{return new t({schema:_,effect:{type:"preprocess",transform:q},typeName:w.ZodEffects,...D(Q)})};class r extends O{_parse(q){if(this._getType(q)===U.undefined)return g(void 0);return this._def.innerType._parse(q)}unwrap(){return this._def.innerType}}r.create=(q,_)=>{return new r({innerType:q,typeName:w.ZodOptional,...D(_)})};class zq extends O{_parse(q){if(this._getType(q)===U.null)return g(null);return this._def.innerType._parse(q)}unwrap(){return this._def.innerType}}zq.create=(q,_)=>{return new zq({innerType:q,typeName:w.ZodNullable,...D(_)})};class aq extends O{_parse(q){let{ctx:_}=this._processInputParams(q),Q=_.data;if(_.parsedType===U.undefined)Q=this._def.defaultValue();return this._def.innerType._parse({data:Q,path:_.path,parent:_})}removeDefault(){return this._def.innerType}}aq.create=(q,_)=>{return new aq({innerType:q,typeName:w.ZodDefault,defaultValue:typeof _.default==="function"?_.default:()=>_.default,...D(_)})};class tq extends O{_parse(q){let{ctx:_}=this._processInputParams(q),Q={..._,common:{..._.common,issues:[]}},X=this._def.innerType._parse({data:Q.data,path:Q.path,parent:{...Q}});if(lq(X))return X.then(($)=>{return{status:"valid",value:$.status==="valid"?$.value:this._def.catchValue({get error(){return new m(Q.common.issues)},input:Q.data})}});else return{status:"valid",value:X.status==="valid"?X.value:this._def.catchValue({get error(){return new m(Q.common.issues)},input:Q.data})}}removeCatch(){return this._def.innerType}}tq.create=(q,_)=>{return new tq({innerType:q,typeName:w.ZodCatch,catchValue:typeof _.catch==="function"?_.catch:()=>_.catch,...D(_)})};class K3 extends O{_parse(q){if(this._getType(q)!==U.nan){let Q=this._getOrReturnCtx(q);return V(Q,{code:j.invalid_type,expected:U.nan,received:Q.parsedType}),K}return{status:"valid",value:q.data}}}K3.create=(q)=>{return new K3({typeName:w.ZodNaN,...D(q)})};var v8=Symbol("zod_brand");class T3 extends O{_parse(q){let{ctx:_}=this._processInputParams(q),Q=_.data;return this._def.type._parse({data:Q,path:_.path,parent:_})}unwrap(){return this._def.type}}class w3 extends O{_parse(q){let{status:_,ctx:Q}=this._processInputParams(q);if(Q.common.async)return(async()=>{let $=await this._def.in._parseAsync({data:Q.data,path:Q.path,parent:Q});if($.status==="aborted")return K;if($.status==="dirty")return _.dirty(),vq($.value);else return this._def.out._parseAsync({data:$.value,path:Q.path,parent:Q})})();else{let X=this._def.in._parseSync({data:Q.data,path:Q.path,parent:Q});if(X.status==="aborted")return K;if(X.status==="dirty")return _.dirty(),{status:"dirty",value:X.value};else return this._def.out._parseSync({data:X.value,path:Q.path,parent:Q})}}static create(q,_){return new w3({in:q,out:_,typeName:w.ZodPipeline})}}class eq extends O{_parse(q){let _=this._def.innerType._parse(q),Q=(X)=>{if(Kq(X))X.value=Object.freeze(X.value);return X};return lq(_)?_.then((X)=>Q(X)):Q(_)}unwrap(){return this._def.innerType}}eq.create=(q,_)=>{return new eq({innerType:q,typeName:w.ZodReadonly,...D(_)})};function QQ(q,_){let Q=typeof q==="function"?q(_):typeof q==="string"?{message:q}:q;return typeof Q==="string"?{message:Q}:Q}function HQ(q,_={},Q){if(q)return Rq.create().superRefine((X,$)=>{let J=q(X);if(J instanceof Promise)return J.then((Y)=>{if(!Y){let H=QQ(_,X),W=H.fatal??Q??!0;$.addIssue({code:"custom",...H,fatal:W})}});if(!J){let Y=QQ(_,X),H=Y.fatal??Q??!0;$.addIssue({code:"custom",...Y,fatal:H})}return});return Rq.create()}var I8={object:P.lazycreate},w;(function(q){q.ZodString="ZodString",q.ZodNumber="ZodNumber",q.ZodNaN="ZodNaN",q.ZodBigInt="ZodBigInt",q.ZodBoolean="ZodBoolean",q.ZodDate="ZodDate",q.ZodSymbol="ZodSymbol",q.ZodUndefined="ZodUndefined",q.ZodNull="ZodNull",q.ZodAny="ZodAny",q.ZodUnknown="ZodUnknown",q.ZodNever="ZodNever",q.ZodVoid="ZodVoid",q.ZodArray="ZodArray",q.ZodObject="ZodObject",q.ZodUnion="ZodUnion",q.ZodDiscriminatedUnion="ZodDiscriminatedUnion",q.ZodIntersection="ZodIntersection",q.ZodTuple="ZodTuple",q.ZodRecord="ZodRecord",q.ZodMap="ZodMap",q.ZodSet="ZodSet",q.ZodFunction="ZodFunction",q.ZodLazy="ZodLazy",q.ZodLiteral="ZodLiteral",q.ZodEnum="ZodEnum",q.ZodEffects="ZodEffects",q.ZodNativeEnum="ZodNativeEnum",q.ZodOptional="ZodOptional",q.ZodNullable="ZodNullable",q.ZodDefault="ZodDefault",q.ZodCatch="ZodCatch",q.ZodPromise="ZodPromise",q.ZodBranded="ZodBranded",q.ZodPipeline="ZodPipeline",q.ZodReadonly="ZodReadonly"})(w||(w={}));var R8=(q,_={message:`Input not instance of ${q.name}`})=>HQ((Q)=>Q instanceof q,_),WQ=o.create,GQ=Eq.create,T8=K3.create,P8=Aq.create,zQ=dq.create,k8=Iq.create,C8=M3.create,f8=cq.create,b8=iq.create,Z8=Rq.create,x8=wq.create,y8=_q.create,g8=U3.create,h8=s.create,l8=P.create,u8=P.strictCreate,m8=pq.create,d8=R3.create,c8=nq.create,i8=Qq.create,p8=V3.create,n8=L3.create,o8=Tq.create,s8=mq.create,r8=oq.create,a8=sq.create,t8=Bq.create,e8=rq.create,q9=Pq.create,_9=t.create,Q9=r.create,X9=zq.create,$9=t.createWithPreprocess,J9=w3.create,Y9=()=>WQ().optional(),H9=()=>GQ().optional(),W9=()=>zQ().optional(),G9={string:(q)=>o.create({...q,coerce:!0}),number:(q)=>Eq.create({...q,coerce:!0}),boolean:(q)=>dq.create({...q,coerce:!0}),bigint:(q)=>Aq.create({...q,coerce:!0}),date:(q)=>Iq.create({...q,coerce:!0})};var z9=K;var VQ=b.object({name:b.string().min(1,"Branch name cannot be empty"),specId:b.string().regex(/^\d{3}-.+$/,"Spec ID must match pattern NNN-feature-name"),baseBranch:b.string().min(1,"Base branch cannot be empty"),status:b.enum(["active","submitted","merged","abandoned"]),pr:b.number().int().positive().nullable(),createdAt:b.string().datetime({message:"Invalid ISO 8601 timestamp"}),updatedAt:b.string().datetime({message:"Invalid ISO 8601 timestamp"}),parentSpecId:b.string().regex(/^\d{3}-.+$/,"Parent spec ID must match pattern NNN-feature-name").optional()}),X_=b.object({version:b.string().regex(/^\d+\.\d+\.\d+$/,"Version must be semver format"),branches:b.array(VQ),specIndex:b.record(b.string(),b.array(b.string()))}),LQ="1.1.0",KQ=".speck/branches.json";async function l(q){let _=Q_.join(q,KQ);if(!UQ(_))return{version:LQ,branches:[],specIndex:{}};try{let Q=await P3.readFile(_,"utf-8"),X=JSON.parse(Q),$=X_.safeParse(X);if(!$.success){let J=await M9(X,q);if(J)return console.warn("[WARN] Auto-repaired branches.json - review changes"),await kq(q,J),J;throw Error(`Corrupted branches.json - restore from git history:
  git show HEAD:.speck/branches.json > .speck/branches.json

Validation errors:
${$.error.message}`)}return $.data}catch(Q){if(Q instanceof SyntaxError)throw Error(`Corrupted branches.json (invalid JSON) - restore from git history:
  git show HEAD:.speck/branches.json > .speck/branches.json`);throw Q}}async function kq(q,_){let Q=Q_.join(q,KQ),X=`${Q}.tmp`,$=X_.safeParse(_);if(!$.success)throw Error(`Invalid branch mapping: ${$.error.message}`);let J=Q_.join(q,".speck");if(!UQ(J))await P3.mkdir(J,{recursive:!0});let Y=JSON.stringify(_,null,2);await P3.writeFile(X,Y,"utf-8"),await P3.rename(X,Q)}function $_(q){let _={};for(let Q of q.branches){if(!_[Q.specId])_[Q.specId]=[];_[Q.specId].push(Q.name)}return{...q,specIndex:_}}function J_(q,_){let Q=q.branches.find((X)=>X.name===_);return Q?Q.specId:null}function q3(q,_){return q.branches.find((Q)=>Q.name===_)||null}function Y_(q,_){let Q=VQ.safeParse(_);if(!Q.success)throw Error(`Invalid branch entry: ${Q.error.message}`);if(q.branches.some(($)=>$.name===_.name))throw Error(`Branch '${_.name}' already exists in mapping`);let X=[...q.branches,_];return $_({...q,branches:X})}function H_(q,_,Q,X){let $=q3(q,_);if(!$)throw Error(`Branch '${_}' not found in mapping`);if(j9($.status,Q),Q==="submitted"&&!X&&!$.pr)throw Error("PR number required for 'submitted' status");let J=q.branches.map((Y)=>Y.name===_?{...Y,status:Q,pr:X!==void 0?X:Y.pr,updatedAt:new Date().toISOString()}:Y);return{...q,branches:J}}function wQ(q,_){if(!q3(q,_))throw Error(`Branch '${_}' not found in mapping`);let X=q.branches.filter(($)=>$.name!==_);return $_({...q,branches:X})}function k3(q,_){let Q=new Set,X=new Set,$=[];function J(Y){if(X.has(Y)){let W=$.indexOf(Y);return[...$.slice(W),Y]}if(Q.has(Y))return null;Q.add(Y),X.add(Y),$.push(Y);let H=_.branches.find((W)=>W.name===Y);if(H&&H.baseBranch){if(_.branches.some((G)=>G.name===H.baseBranch)){let G=J(H.baseBranch);if(G)return G}}return $.pop(),X.delete(Y),null}return J(q)}function j9(q,_){if(q==="merged")throw Error("Cannot transition from 'merged' (terminal state)");if(q==="abandoned")throw Error("Cannot transition from 'abandoned' (terminal state)")}async function M9(q,_){try{if(!q.version)q.version=LQ;if(!Array.isArray(q.branches))q.branches=[];for(let $ of q.branches){if(!$.createdAt||!jQ($.createdAt))$.createdAt=new Date().toISOString();if(!$.updatedAt||!jQ($.updatedAt))$.updatedAt=new Date().toISOString()}if(!q.specIndex||typeof q.specIndex!=="object")q.specIndex={};let Q=$_(q),X=X_.safeParse(Q);if(X.success)return X.data;return null}catch{return null}}function jQ(q){try{return new Date(q).toISOString()===q}catch{return!1}}async function _3(q,_){let{findChildReposWithNames:Q}=await Promise.resolve().then(() => (p(),N3)),X=null;try{let W=await l(q);if(W.branches.length>0)X=MQ(q,"root",W)}catch(W){}let $=new Map,J=await Q(q),Y=Array.from(J.entries()).map(async([W,G])=>{try{let z=await l(G);if(z.branches.length>0){let M=MQ(G,W,z);return{childName:W,summary:M}}}catch(z){}return null}),H=await Promise.all(Y);for(let W of H)if(W)$.set(W.childName,W.summary);return{rootRepo:X,childRepos:$}}function MQ(q,_,Q){let X={active:0,submitted:0,merged:0,abandoned:0};for(let H of Q.branches)X[H.status]++;let $=[...new Set(Q.branches.map((H)=>H.specId))],J=$.length===1?$[0]:null,Y=U9(Q);return{repoPath:q,repoName:_,specId:J,branchCount:Q.branches.length,statusCounts:X,chains:Y,branches:Q.branches}}function U9(q){let _=[],Q=new Set,X=new Set(q.branches.map((J)=>J.name)),$=q.branches.filter((J)=>!X.has(J.baseBranch));for(let J of $)if(!Q.has(J.name)){let Y=EQ(J.name,q,Q);if(Y.length>0)_.push({branches:Y})}return _}function EQ(q,_,Q){Q.add(q);let X=_.branches.filter((J)=>J.baseBranch===q);if(X.length===0)return[q];let $=X[0];if(!Q.has($.name))return[q,...EQ($.name,_,Q)];return[q]}var{$:e}=globalThis.Bun;class W_ extends Error{constructor(q){super(q);this.name="ValidationError"}}class x extends Error{constructor(q){super(q);this.name="GitError"}}var E3=new Map;async function AQ(q,_,Q){if((await e`git -C ${Q} rev-parse --verify ${_}`.quiet()).exitCode!==0)throw new x(`Base branch '${_}' does not exist`);if((await e`git check-ref-format --branch ${q}`.quiet()).exitCode!==0)throw new x(`Invalid branch name: '${q}'`);let J=await e`git -C ${Q} branch ${q} ${_}`.quiet();if(J.exitCode!==0){let Y=await J.stderr.text();throw new x(`Failed to create branch: ${Y}`)}}async function BQ(q,_,Q){try{let X=await e`git -C ${Q} branch --merged ${_}`.quiet();if(X.exitCode!==0)throw new x(`Failed to check merged status for '${q}'`);return X.text().split(`
`).map((Y)=>Y.trim().replace(/^\*\s*/,"")).filter(Boolean).includes(q)}catch(X){if(X instanceof x)throw X;throw new x(`Failed to check merged status: ${X}`)}}async function DQ(q,_){try{let Q=_?`git -C ${q} branch --list --format='%(refname:short)|%(upstream:short)' ${_}`:`git -C ${q} branch --list --format='%(refname:short)|%(upstream:short)'`,X=await e`sh -c ${Q}`.quiet();if(X.exitCode!==0){let J=X.stderr.toString();throw new x(`Failed to list branches: ${J}`)}return X.stdout.toString().split(`
`).filter(Boolean).map((J)=>{let[Y,H]=J.split("|");return{name:Y.trim(),upstream:H?.trim()||null}})}catch(Q){if(Q instanceof x)throw Q;throw new x(`Failed to list branches: ${Q}`)}}async function OQ(q,_){let Q=await e`git -C ${_} checkout ${q}`.quiet();if(Q.exitCode!==0){let X=await Q.stderr.text();throw new x(`Failed to checkout branch '${q}': ${X}`)}}async function Q3(q){let _=await e`git -C ${q} rev-parse --abbrev-ref HEAD`.quiet();if(_.exitCode!==0)throw new x("Failed to get current branch");let Q=_.stdout.toString().trim();if(Q==="HEAD")throw new x("Currently in detached HEAD state");return Q}async function C3(q,_){try{return(await e`git -C ${_} rev-parse --verify ${q}`.quiet()).exitCode===0}catch{return!1}}async function SQ(q,_){let Q=await e`git -C ${_} branch --list ${q}`.quiet();if(Q.exitCode!==0||!Q.stdout.toString().trim())throw new x(`Base branch '${q}' does not exist in current repository.

Cross-repo branch dependencies are not supported.

Alternatives:
  1. Complete work in other repo first and merge to main
  2. Use shared contracts/APIs for coordination
  3. Manually coordinate PR merge order across repos`)}async function G_(q){if(E3.has(q))return E3.get(q);try{let Q=await e`git -C ${q} symbolic-ref refs/remotes/origin/HEAD`.quiet();if(Q.exitCode===0){let $=Q.stdout.toString().trim().match(/refs\/remotes\/origin\/(.+)/);if($){let J=$[1];return E3.set(q,J),J}}}catch{}let _=["main","master","develop"];for(let Q of _)if(await C3(Q,q))return E3.set(q,Q),Q;return E3.set(q,null),null}async function FQ(q){try{let _=await e`git -C ${q} remote get-url origin`.quiet();if(_.exitCode===0)return _.stdout.toString().trim();return null}catch{return null}}p();var{$:Dq}=globalThis.Bun;async function IQ(q){try{let Q=(await Dq`git -C ${q} symbolic-ref --short HEAD 2>/dev/null || git -C ${q} rev-parse --short HEAD 2>/dev/null`.quiet()).text().trim();if(Q&&/^\d{3}-.+$/.test(Q)){let Y=f3.join(q,"specs",Q);try{return await b3.access(Y),Q}catch{}}let X=f3.join(q,"specs"),J=(await b3.readdir(X)).filter((Y)=>/^\d{3}-.+$/.test(Y));if(J.length===0)return null;return J.sort(),J[J.length-1]}catch{return null}}async function V9(){try{return(await Dq`which gh`.quiet()).exitCode===0}catch{return!1}}async function L9(q,_,Q){try{let X=await Dq`git -C ${Q} log ${q}..${_} --format=%s%n%b`.quiet();if(X.exitCode!==0)return[];return X.stdout.toString().trim().split(`
`).filter(($)=>$.trim())}catch{return[]}}function K9(q){let _=[/^wip/i,/^fix$/i,/^tmp/i,/^temp/i,/^test/i,/^update$/i,/^merge/i,/^rebase/i,/^\./],Q=q.trim().toLowerCase();return!_.some((X)=>X.test(Q))&&Q.length>5}function w9(q){if(q.length===0)return null;let _=q.filter(($)=>$.trim()&&K9($));if(_.length===0)return null;let Q=_[0].split(`
`)[0],X=_.map(($)=>`- ${$.split(`
`)[0]}`).join(`
`);return{title:Q,body:X}}async function E9(q,_,Q){try{let $=(await Dq`git -C ${Q} diff ${q}...${_} --stat`.quiet()).stdout.toString().trim(),Y=(await Dq`git -C ${Q} diff ${q}...${_} --name-status`.quiet()).stdout.toString().trim().split(`
`).filter((G)=>G.trim()),H=`Update ${_} (${Y.length} files changed)`,W=`## Changes

${$}

## Files Modified
${Y.map((G)=>`- ${G}`).join(`
`)}`;return{title:H,body:W}}catch{return{title:`Update ${_}`,body:"Changes made on this branch"}}}function A9(q,_,Q){if(_)return _;return"main"}async function B9(q,_,Q,X,$){if($?.context==="child"){if(!await FQ(X))return console.warn(`
\u26A0\uFE0F  WARNING: No remote configured for this repository.`),console.warn("Branch created locally. PR creation unavailable."),console.warn(`
To configure remote:`),console.warn("  git remote add origin <url>"),console.warn(`  git push -u origin <branch-name>
`),null}if(!await V9())return null;let Y=q3(Q,q),H;if($?.context==="child")H=await G_(X)||"main";else H=A9(q,Y?.baseBranch||null,X);let W=await L9(H,q,X);if(W.length===0)return null;let G=w9(W);if(!G)G=await E9(H,q,X);let z=G.title;if($?.childRepoName)z=`[${$.childRepoName}] ${G.title}`;return{title:z,body:G.body,prBase:H}}function z_(q,_,Q){let X=q.branches.filter((Y)=>Y.specId===_),$=X.filter((Y)=>!X.some((H)=>H.name===Y.baseBranch));function J(Y,H,W){let G=X.find((B)=>B.name===Y);if(!G)return;let z="  ".repeat(H),M=H===0?"":W?"\u2514\u2500 ":"\u251C\u2500 ",E=Y===Q?" (current)":"",v=G.status!=="active"?` (${G.status}${G.pr?`, PR #${G.pr}`:""})`:"";console.log(`${z}${M}${Y}${E}${v}`);let R=X.filter((B)=>B.baseBranch===Y);R.forEach((B,S)=>{J(B.name,H+1,S===R.length-1)})}$.forEach((Y)=>{console.log(`  ${Y.baseBranch}`),J(Y.name,1,!0)})}function NQ(q,_){let Q=_;while(Q){let X=q.branches.find(($)=>$.name===Q.baseBranch);if(!X)return Q.baseBranch;Q=X}return"main"}async function D9(q){let _=q.findIndex((N)=>!N.startsWith("--"));if(_===-1)throw Error("Branch name required: /speck.branch create <name> [--base <base>]");let Q=q[_],X=q.indexOf("--base"),$=q.indexOf("--spec"),J=q.includes("--skip-pr-prompt"),Y=q.includes("--create-pr"),H=q.indexOf("--title"),W=q.indexOf("--description"),G=q.indexOf("--pr-base"),z=q.includes("--json"),M=await i(),E=M.REPO_ROOT,v=await C(),R=await o3(),B=null;if(v.mode==="multi-repo"){let N=R?"child":"root",Vq=R?await IQ(v.speckRoot):null,fq=R?await F3(v.repoRoot,v.speckRoot):null;B={...v,context:N,parentSpecId:Vq,childRepoName:fq}}let S="";try{S=await Q3(E)}catch(N){S=""}let k;if(X!==-1&&q[X+1])k=q[X+1];else{if(!S)return console.error("Error: No commits in repository. Cannot determine current branch."),console.error("Please create an initial commit first, or specify --base explicitly."),1;k=S,console.log(`Defaulting base to current branch: ${k}`)}let f=$!==-1?q[$+1]:null;if(!await r3(Q))throw Error(`Invalid branch name: '${Q}'. Must be a valid git ref name.`);try{await SQ(k,E)}catch(N){if(N instanceof Error)throw Error(N.message);throw N}if(!f){if(M.FEATURE_DIR&&M.FEATURE_DIR.includes("/specs/")){let N=M.FEATURE_DIR.match(/\/specs\/([^\/]+)/);if(N){if(f=N[1],!z)console.log(`Auto-detected spec: ${f}`)}}if(!f)throw Error(`Could not auto-detect spec ID. Please specify with --spec flag:
  /speck.branch create <name> [--base <base>] --spec <spec-id>`)}let y=B?v.specsDir:f3.join(E,"specs"),d=f3.join(y,f);try{await b3.access(d)}catch{throw Error(`Spec directory not found: specs/${f}/`)}if((await Dq`git -C ${E} status --porcelain`.quiet()).stdout.toString().split(`
`).filter((N)=>N.trim().length>0).filter((N)=>!N.includes(".speck/branches.json")).length>0){console.log(`
${"\u26A0".repeat(30)}`),console.log(`\u26A0 Warning: Current branch '${S}' has uncommitted changes`),console.log(`${"\u26A0".repeat(30)}
`);let N=await Dq`git -C ${E} diff --stat`.quiet();throw console.log("Changed files:"),console.log(N.stdout.toString()),console.log(`
Options:`),console.log("  1. Commit changes now (recommended)"),console.log("  2. Stash changes (saves for later)"),console.log("  3. Carry changes to new branch (creates new branch with changes)"),console.log("  4. Abort branch creation"),console.log(`
Choose an option or run one of these commands first:`),console.log('  git add . && git commit -m "message"  # Commit changes'),console.log("  git stash                              # Stash changes"),console.log(`
Then re-run: /speck.branch create `+q.join(" ")),Error("Uncommitted changes detected. Please commit or stash changes before creating a new branch.")}let u=await l(E);if(!J&&!Y){let N=await B9(S,k,u,E,B);if(N){if(z){let Vq={branch:S,title:N.title,body:N.body,base:N.prBase};console.log(JSON.stringify(Vq))}else{let Vq={type:"pr-suggestion",branch:S,suggestedTitle:N.title,suggestedDescription:N.body,suggestedBase:N.prBase,newBranch:Q};console.error(JSON.stringify(Vq)),console.log(`
${"=".repeat(60)}`),console.log(`\uD83D\uDCA1 PR Opportunity: Create PR for '${S}' before switching`),console.log(`${"=".repeat(60)}`),console.log(`
Suggested PR details:`),console.log(`  Title: ${N.title}`),console.log(`  Base: ${N.prBase}`),console.log(`
Description:`),console.log(N.body.split(`
`).map((fq)=>`  ${fq}`).join(`
`)),console.log(`
${"-".repeat(60)}`),console.log("Option 1: Create PR with gh CLI:"),console.log(`  gh pr create --base ${N.prBase} --title "${N.title}" --body "${N.body.replace(/"/g,"\\\"")}"`),console.log(`
Option 2: Create PR via GitHub URL:`),console.log(`  https://github.com/OWNER/REPO/compare/${N.prBase}...${S}?expand=1&title=${encodeURIComponent(N.title)}`),console.log(`
Option 3: Skip and create branch without PR`),console.log(`${"=".repeat(60)}
`)}return 2}}if(Y){let N=H!==-1?q[H+1]:null,Vq=W!==-1?q[W+1]:null,fq=G!==-1?q[G+1]:null;if(!N||!Vq||!fq)throw Error("--create-pr requires --title, --description, and --pr-base flags");console.log(`Creating PR for '${S}'...`);try{let Sq=await Dq`gh pr create --base ${fq} --title ${N} --body ${Vq}`.quiet();if(Sq.exitCode!==0)throw Error(`gh pr create failed: ${Sq.stderr.toString()}`);let w_=Sq.stdout.toString().match(/\/pull\/(\d+)/),Z3=w_?parseInt(w_[1],10):null;if(Z3){if(console.log(`\u2713 Created PR #${Z3} for '${S}'`),q3(u,S))u=H_(u,S,"submitted",Z3),await kq(E,u)}else console.log(`\u2713 PR created for '${S}' (could not parse PR number from output)`)}catch(Sq){let bq=Sq instanceof Error?Sq.message:String(Sq);if(bq.includes("gh: command not found")||bq.includes("not found"))return console.error(`
\u274C Error: GitHub CLI (gh) is not installed`),console.error(`
To install gh:`),console.error("  brew install gh           # macOS"),console.error("  sudo apt install gh       # Ubuntu/Debian"),console.error("  winget install GitHub.cli # Windows"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${Q} --skip-pr-prompt`),1;if(bq.includes("authentication")||bq.includes("401"))return console.error(`
\u274C Error: GitHub CLI is not authenticated`),console.error(`
To authenticate:`),console.error("  gh auth login"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${Q} --skip-pr-prompt`),1;return console.error(`
\u274C Error creating PR: ${bq}`),console.error(`
You can:`),console.error("  1. Check your network connection and try again"),console.error("  2. Create the PR manually via GitHub web UI"),console.error("  3. Use --skip-pr-prompt to create branch without PR"),1}}let $3=new Date().toISOString(),Uq={name:Q,specId:f,baseBranch:k,status:"active",pr:null,createdAt:$3,updatedAt:$3,...B?.parentSpecId&&{parentSpecId:B.parentSpecId}},K_=k3(Q,{...u,branches:[...u.branches,Uq]});if(K_)throw Error(`Circular dependency detected: ${K_.join(" \u2192 ")}`);if(u=Y_(u,Uq),await AQ(Q,k,E),await OQ(Q,E),await kq(E,u),!z)console.log(`\u2713 Created stacked branch '${Q}'`),console.log(`\u2713 Based on: ${k}`),console.log(`\u2713 Linked to spec: ${f}`),console.log(),console.log("Branch stack:"),z_(u,f,Q),console.log(),console.log("Next steps:"),console.log("  - Implement feature on this branch"),console.log(`  - Run /speck.tasks --branch ${Q} to generate tasks`),console.log(`  - When ready: /speck.branch create <next-branch> --base ${Q}`)}async function O9(q){let _=q.includes("--all"),Q=await i(),X=await C(),$=Q.REPO_ROOT;if(_&&X.mode==="multi-repo"){await S9(X.speckRoot,$);return}let J=await l($);if(J.branches.length===0){console.log("No stacked branches found."),console.log("Create your first stacked branch with:"),console.log("  /speck.branch create <name> --base main");return}let Y="";try{Y=await Q3($)}catch(H){Y=""}if(_){let H=Object.keys(J.specIndex);for(let W of H)console.log(`
Spec: ${W}`),console.log("Branch Stack:"),z_(J,W,Y);console.log(`
Total: ${J.branches.length} branches across ${H.length} specs`)}else{let H=J_(J,Y);if(!H){console.log("Current branch is not in stacked mode."),console.log("Use --all to see all stacked branches.");return}console.log(`Spec: ${H}
`),console.log("Branch Stack:"),z_(J,H,Y),console.log(`
Legend:`),console.log("  (current) = checked out branch"),console.log("  (active) = development in progress"),console.log("  (submitted) = PR open for review")}}async function S9(q,_){let Q=await _3(q,_);if(console.log(`Branch List (All Repositories)
`),Q.rootRepo&&Q.rootRepo.branchCount>0){console.log("Root Repository:"),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let $=await l(q);for(let J of $.branches){let Y=J.pr?String(J.pr).padEnd(5):"-".padEnd(5);console.log(`${J.name.padEnd(18)} ${J.baseBranch.padEnd(14)} ${J.specId.padEnd(23)} ${Y} ${J.status}`)}console.log("")}let X=Array.from(Q.childRepos.keys()).sort();for(let $ of X){let J=Q.childRepos.get($);console.log(`Child: ${$}`),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let Y=await l(J.repoPath);for(let H of Y.branches){let W=H.pr?String(H.pr).padEnd(5):"-".padEnd(5);console.log(`${H.name.padEnd(18)} ${H.baseBranch.padEnd(14)} ${H.specId.padEnd(23)} ${W} ${H.status}`)}console.log("")}if(X.length===0&&!Q.rootRepo)console.log("No branches found in any repository.")}async function F9(q=[]){let _=q.includes("--all"),Q=await i(),X=await C(),$=Q.REPO_ROOT;if(_&&X.mode==="multi-repo"){await N9(X.speckRoot,$);return}let J=await l($),Y="";try{Y=await Q3($)}catch(M){Y=""}let H=J_(J,Y);if(!H){console.log("Current branch is not in stacked mode.");return}let W=J.branches.filter((M)=>M.specId===H),G=0;console.log(`Spec: ${H}
`);for(let M of W){if(!await C3(M.name,$)){console.log(`${M.name} (${M.status}${M.pr?`, PR #${M.pr}`:""})`),console.log("  \u26A0 ORPHANED: Branch no longer exists in git"),console.log(`  \u2192 Run: /speck.branch delete ${M.name} (cleanup metadata)`),G++;continue}let v=await BQ(M.name,M.baseBranch,$);if(v&&M.status!=="merged")console.log(`${M.name} (${M.status}${M.pr?`, PR #${M.pr}`:""})`),console.log(`  \u26A0 MERGED: Branch merged into base but status is '${M.status}'`),console.log(`  \u2192 Run: /speck.branch update ${M.name} --status merged`),G++;if(v&&M.status==="merged"){let R=W.filter((B)=>B.baseBranch===M.name&&B.status!=="merged");if(R.length>0)for(let B of R)console.log(`
${B.name} (${B.status})`),console.log(`  \u26A0 REBASE NEEDED: Base branch '${M.name}' has been merged`),console.log(`  \u2192 Run: git rebase ${NQ(J,M)}`),console.log(`  \u2192 Update base: /speck.branch update ${B.name} --base ${NQ(J,M)}`),G++}}if(G===0)console.log("\u2713 Branch stack is healthy - no warnings");else console.log(`
\u26A0 ${G} warning(s) found`);let z=await xq();if(z.mode==="child"&&J.branches.length>0)try{let{findChildRepos:M}=await Promise.resolve().then(() => (p(),N3)),E=z.speckRoot||"";if(!(await M(E)).includes($))console.log(`
\u26A0 Orphaned tracking detected:`),console.log(`  ${J.branches.length} branch(es) tracked but repo unlinked from parent spec`),console.log(`  Parent: ${E}`),console.log("  Fix: Re-link with /speck.link or archive .speck/branches.json")}catch{}}async function N9(q,_){let Q=await _3(q,_);if(console.log(`Branch Status (All Repositories)
`),Q.rootRepo&&Q.rootRepo.branchCount>0)console.log("Root Repository:"),await vQ(q,Q.rootRepo),console.log("");let X=Array.from(Q.childRepos.keys()).sort();for(let $ of X){let J=Q.childRepos.get($);console.log(`Child: ${$}`),await vQ(J.repoPath,J),console.log("")}if(X.length===0&&!Q.rootRepo)console.log("No branches found in any repository.")}async function vQ(q,_){let Q=await l(q),X=[];if(_.statusCounts.active>0)X.push(`${_.statusCounts.active} active`);if(_.statusCounts.submitted>0)X.push(`${_.statusCounts.submitted} submitted`);if(_.statusCounts.merged>0)X.push(`${_.statusCounts.merged} merged`);if(_.statusCounts.abandoned>0)X.push(`${_.statusCounts.abandoned} abandoned`);if(X.length>0)console.log(`  Total: ${_.branchCount} branches (${X.join(", ")})`);console.log("  Dependency Tree:");for(let $ of _.chains)if($.branches.length>0)v9($.branches,Q)}function v9(q,_){q.forEach((Q,X)=>{let $=_.branches.find((H)=>H.name===Q);if(!$)return;let Y=`${X===0?"    \u2514\u2500":"       \u2514\u2500"} ${Q}`;if($.pr)Y+=` (${$.status}, PR #${$.pr})`;else if($.status!=="active")Y+=` (${$.status})`;console.log(Y)})}async function I9(q){let _=q[0];if(!_)throw Error("Branch name required: /speck.branch update <name> [options]");let Q=q.indexOf("--status"),X=q.indexOf("--pr"),$=q.indexOf("--base"),Y=(await i()).REPO_ROOT,H=await l(Y);if(!q3(H,_))throw Error(`Branch '${_}' not found in mapping`);if(Q!==-1){let G=q[Q+1];if(!["active","submitted","merged","abandoned"].includes(G))throw Error(`Invalid status: '${G}'. Must be: active, submitted, merged, or abandoned`);let z=X!==-1?parseInt(q[X+1],10):void 0;H=H_(H,_,G,z)}if($!==-1){let G=q[$+1];if(!await C3(G,Y))throw Error(`Base branch '${G}' does not exist`);let M=H.branches.map((v)=>v.name===_?{...v,baseBranch:G,updatedAt:new Date().toISOString()}:v),E=k3(_,{...H,branches:M});if(E)throw Error(`Cannot update base: circular dependency detected: ${E.join(" \u2192 ")}`);H={...H,branches:M}}await kq(Y,H),console.log(`\u2713 Updated branch '${_}'`)}async function R9(q){let _=q[0];if(!_)throw Error("Branch name required: /speck.branch delete <name>");let Q=q.includes("--force"),$=(await i()).REPO_ROOT,J=await l($),Y=J.branches.filter((W)=>W.baseBranch===_);if(Y.length>0&&!Q)throw console.error(`Error: Branch '${_}' has child branches:`),Y.forEach((W)=>console.error(`  - ${W.name}`)),console.error(`
Use --force to delete anyway (will orphan children)`),Error("Branch has children");let H=wQ(J,_);await kq($,H),console.log(`\u2713 Removed branch '${_}' from metadata`),console.log(),console.log("Note: Git branch still exists. To delete it, run:"),console.log(`  git branch -D ${_}`)}async function T9(q){let _=q.indexOf("--pattern"),Q=_!==-1?q[_+1]:void 0,X=q.indexOf("--batch"),$=X!==-1,Y=(await i()).REPO_ROOT,H=await xq(),W=H.context==="child"?await IQ(H.speckRoot):null,G=await DQ(Y,Q);if(G.length===0){console.log("No branches found to import.");return}let z=await l(Y),M=await G_(Y),E=G.filter(({name:c})=>!z.branches.some((y)=>y.name===c)&&c!==M);if(E.length===0){console.log("All branches are already in stacked mode.");return}let v=H.specsDir,B=(await b3.readdir(v)).filter((c)=>/^\d{3}-/.test(c));if(!$){let c=E.map(({name:d,upstream:Xq})=>{let Cq="main";if(Xq){let Oq=Xq.replace(/^origin\//,"");if(Oq&&Oq!==d)Cq=Oq}return{name:d,upstream:Xq||null,inferredBase:Cq}});return console.error(JSON.stringify({type:"import-prompt",branches:c,availableSpecs:B})),console.log(`Found ${E.length} branches to import:
`),c.forEach((d)=>{console.log(`\u2022 ${d.name}`),console.log(`  Upstream: ${d.upstream||"(none)"}`),console.log(`  Inferred base: ${d.inferredBase}`),console.log()}),console.log(`Available specs: ${B.join(", ")}
`),console.log("Agent interaction required: Map each branch to a spec."),3}let S=q.slice(X+1),k=0,f=0;for(let c of S){let[y,d]=c.split(":");if(!y||!d){console.log(`\u26A0 Invalid mapping format: ${c}`);continue}if(d==="skip"){console.log(`\u2298 Skipped ${y}`),f++;continue}let Xq=E.find((Uq)=>Uq.name===y);if(!Xq){console.log(`\u26A0 Branch not found: ${y}`);continue}let Cq="main";if(Xq.upstream){let Uq=Xq.upstream.replace(/^origin\//,"");if(Uq&&Uq!==Xq.name)Cq=Uq}let Oq=new Date().toISOString(),u={name:y,specId:d,baseBranch:Cq,status:"active",pr:null,createdAt:Oq,updatedAt:Oq,...W&&{parentSpecId:W}},$3=k3(y,{...z,branches:[...z.branches,u]});if($3){console.log(`\u26A0 Skipped ${y} (would create cycle: ${$3.join(" \u2192 ")})`),f++;continue}z=Y_(z,u),console.log(`\u2713 Imported ${y} \u2192 ${d}`),k++}await kq(Y,z),console.log(`
\u2713 Import complete:`),console.log(`  Imported: ${k}`),console.log(`  Skipped: ${f}`)}async function RQ(q=process.argv.slice(2)){if(q.length===0)return console.log("Usage: /speck.branch <command> [args]"),console.log(),console.log("Commands:"),console.log("  create <name> [--base <base>] [--spec <spec-id>]"),console.log("  list [--all]"),console.log("  status"),console.log("  update <name> [--status <status>] [--pr <number>] [--base <branch>]"),console.log("  delete <name> [--force]"),console.log("  import [--pattern <pattern>]"),1;let _=q[0],Q=q.slice(1);try{switch(_){case"create":await D9(Q);break;case"list":await O9(Q);break;case"status":await F9(Q);break;case"update":await I9(Q);break;case"delete":await R9(Q);break;case"import":await T9(Q);break;default:return console.error(`Unknown command: ${_}`),console.error("Run '/speck.branch' for usage"),1}}catch(X){if(X instanceof x||X instanceof W_)return console.error(`Error: ${X.message}`),1;if(X instanceof Error){if(console.error(`Error: ${X.message}`),X.stack)console.error(`Stack trace: ${X.stack}`);return 1}return console.error(`Unknown error: ${String(X)}`),1}return 0}p();import P9 from"fs/promises";import k9 from"path";async function PQ(q=process.argv.slice(2)){if(q.includes("--help"))return C9(),0;let _=q.includes("--json");try{return await f9(_),0}catch(Q){if(_)console.error(JSON.stringify({error:Q instanceof Error?Q.message:String(Q)}));else console.error(`Error: ${Q instanceof Error?Q.message:String(Q)}`);return 1}}function C9(){console.log(`
Speck Environment Check

Usage:
  bun run .speck/scripts/env-command.ts [options]

Options:
  --help     Show this help message
  --json     Output as JSON (for programmatic use)

Description:
  Displays comprehensive environment information including:
  - Multi-repo configuration
  - Branch stack status (single-repo or aggregate)
  - Feature detection
  - System diagnostics
  `.trim())}async function f9(q){let _=await C(),Q=await xq();if(q)await l9(_,Q);else await b9(_,Q)}async function b9(q,_){console.log(`=== Speck Environment Status ===
`),Z9(_),await x9(q,_)}function Z9(q){if(q.mode==="single-repo")console.log("Mode: Single-repo"),console.log(`  Repo Root: ${q.repoRoot}`),console.log(`  Specs Directory: ${q.specsDir}`),console.log("");else if(q.context==="root")console.log("Mode: Multi-repo (Root)"),console.log(`  Speck Root: ${q.speckRoot}`),console.log(`  Specs Directory: ${q.specsDir}`),console.log("");else if(q.context==="child")console.log("Mode: Multi-repo (Child Repository)"),console.log(`  Context: Child repo (${q.childRepoName})`),console.log(`  Parent Spec: ${q.parentSpecId||"Unknown"}`),console.log(`  Repo Root: ${q.repoRoot}`),console.log(`  Speck Root: ${q.speckRoot}`),console.log("")}async function x9(q,_){let X=(await s3(q.speckRoot)).size>0,$=k9.join(q.repoRoot,".speck","branches.json"),J=!1;try{await P9.access($),J=!0}catch{}if(!J&&!X){console.log("Branch Stack Status: Not enabled"),console.log(""),console.log("To enable stacked PRs:"),console.log("  /speck.branch create <branch-name> --base <base-branch>"),console.log("");return}if(_.mode==="multi-repo"&&_.context==="root"||_.mode==="single-repo"&&X)await y9(q.speckRoot,q.repoRoot);else await h9(q.repoRoot)}async function y9(q,_){console.log(`=== Branch Stack Status (Multi-Repo) ===
`);let Q=await _3(q,_);if(Q.rootRepo)TQ("Root",Q.rootRepo);else console.log("Root Repository: (no branches)"),console.log("");let X=Array.from(Q.childRepos.keys()).sort();for(let $ of X){let J=Q.childRepos.get($);TQ(`Child: ${$}`,J)}if(X.length===0&&!Q.rootRepo)console.log("No branches found in any repository."),console.log("")}function TQ(q,_){console.log(`${q}${_.specId?` (${_.specId})`:""}:`);let Q=[];if(_.statusCounts.active>0)Q.push(`${_.statusCounts.active} active`);if(_.statusCounts.submitted>0)Q.push(`${_.statusCounts.submitted} submitted`);if(_.statusCounts.merged>0)Q.push(`${_.statusCounts.merged} merged`);if(_.statusCounts.abandoned>0)Q.push(`${_.statusCounts.abandoned} abandoned`);if(Q.length>0)console.log(`  ${Q.join(", ")}`);for(let X of _.chains)if(X.branches.length>0)g9(X.branches,_.branches);console.log("")}function g9(q,_){if(q.length===0)return;q.forEach((Q,X)=>{let $=X===0?"\u2514\u2500":"   \u2514\u2500",J=_.find((H)=>H.name===Q),Y=`  ${$} ${Q}`;if(J){if(J.pr)Y+=` (${J.status}, PR #${J.pr})`;else if(J.status!=="active")Y+=` (${J.status})`}console.log(Y)})}async function h9(q){console.log(`=== Branch Stack Status ===
`);let _=await l(q);if(_.branches.length===0){console.log("No branches tracked yet."),console.log("");return}let Q="";try{Q=await Q3(q)}catch(J){Q=""}let X=Object.keys(_.specIndex);for(let J of X){console.log(`Spec: ${J}`),console.log("Branch Stack:");let Y=_.specIndex[J]||[],H=Y.map((G)=>_.branches.find((z)=>z.name===G)).filter(Boolean);H.filter((G)=>!Y.includes(G.baseBranch)).forEach((G)=>{console.log(`  ${G.baseBranch}`),kQ(G.name,"  ",!0,H,Q)}),console.log("")}let $=_.branches.filter((J)=>J.status==="active"&&J.pr===null).length;if($>0)console.log(`\u26A0 ${$} branch(es) may need attention`),console.log("Run /speck.branch status for details"),console.log("");if(context.mode==="child"&&_.branches.length>0)try{let{findChildRepos:J}=await Promise.resolve().then(() => (p(),N3)),Y=context.speckRoot||"";if(!(await J(Y)).includes(q))console.log("\u26A0 Orphaned tracking detected:"),console.log(`  ${_.branches.length} branch(es) tracked but repo unlinked from parent spec`),console.log(`  Parent: ${Y}`),console.log("  Fix: Re-link with /speck.link or archive .speck/branches.json"),console.log("")}catch{}}function kQ(q,_,Q,X,$){let J=X.find((z)=>z.name===q);if(!J)return;let Y=Q?"\u2514\u2500":"\u251C\u2500",H=q===$,W=`${_}${Y} ${q}`;if(J.pr)W+=` (${J.status}, PR #${J.pr})`;else if(J.status!=="active")W+=` (${J.status})`;if(H)W+=" (current)";console.log(W);let G=X.filter((z)=>z.baseBranch===q);G.forEach((z,M)=>{let E=_+(Q?"  ":"\u2502 ");kQ(z.name,E,M===G.length-1,X,$)})}async function l9(q,_){let Q={mode:_.mode,context:_.context,speckRoot:_.speckRoot,repoRoot:_.repoRoot,specsDir:_.specsDir};if(_.context==="child")Q.childRepoName=_.childRepoName,Q.parentSpecId=_.parentSpecId;if(_.mode==="multi-repo"&&_.context==="root"){let X=await _3(_.speckRoot,_.repoRoot);Q.branchStatus={type:"aggregate",rootRepo:X.rootRepo,childRepos:Object.fromEntries(X.childRepos)}}else try{let X=await l(_.repoRoot);Q.branchStatus={type:"local",branches:X.branches,specIndex:X.specIndex}}catch{Q.branchStatus={type:"none"}}console.log(JSON.stringify(Q,null,2))}var jq={echo:{handler:l_,description:"Echo back the provided message",version:"1.0.0"},env:{handler:i_,main:PQ,description:"Show Speck environment and configuration info",version:"1.0.0"},branch:{main:RQ,description:"Manage stacked feature branches",version:"1.0.0"},"check-prerequisites":{main:n_,description:"Validate feature directory structure and prerequisites",version:"1.0.0"},"create-new-feature":{main:r_,description:"Create new feature specification directory",version:"1.0.0"},"setup-plan":{main:t_,description:"Initialize planning workflow",version:"1.0.0"},"link-repo":{main:e_,description:"Link repository to multi-repo speck root",version:"1.0.0"}};import{appendFile as u9}from"fs/promises";var m9="/private/tmp/.claude-hook-test/speck-hook-log.txt",X3=async(q)=>{await u9(m9,`[${new Date().toISOString()}] ${q}
`)},Mq=new y_;Mq.name("speck").description("Speck unified CLI for feature specification workflow").version("0.1.0");var CQ=jq.echo;Mq.command("echo <message...>").description(CQ.description).action(async(q)=>{let _=Array.isArray(q)?q.join(" "):String(q),Q={mode:Jq(),rawCommand:`echo ${_}`,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},X=await CQ.handler({message:_},Q);if(X.success)console.log(X.output);else console.error(X.errorOutput),process.exit(X.exitCode)});var fQ=jq.env;Mq.command("env").description(fQ.description).action(async()=>{let q={mode:Jq(),rawCommand:"env",workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},_=await fQ.handler({},q);if(_.success)console.log(_.output);else console.error(_.errorOutput),process.exit(_.exitCode)});var j_=jq.branch;Mq.command("branch [args...]").description(j_.description).allowUnknownOption().action(async(q)=>{let Q=`branch ${(Array.isArray(q)?q:[q]).join(" ")}`,X={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=j_.parseArgs(Q),J=await j_.handler($,X);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)});var M_=jq["check-prerequisites"];Mq.command("check-prerequisites [args...]").description(M_.description).allowUnknownOption().action(async(q)=>{let Q=`check-prerequisites ${(Array.isArray(q)?q:[q]).join(" ")}`,X={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=M_.parseArgs(Q),J=await M_.handler($,X);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)});var U_=jq["create-new-feature"];Mq.command("create-new-feature [args...]").description(U_.description).allowUnknownOption().action(async(q)=>{let Q=`create-new-feature ${(Array.isArray(q)?q:[q]).join(" ")}`,X={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=U_.parseArgs(Q),J=await U_.handler($,X);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)});var V_=jq["setup-plan"];Mq.command("setup-plan [args...]").description(V_.description).allowUnknownOption().action(async(q)=>{let Q=`setup-plan ${(Array.isArray(q)?q:[q]).join(" ")}`,X={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=V_.parseArgs(Q),J=await V_.handler($,X);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)});var L_=jq["link-repo"];Mq.command("link-repo [args...]").description(L_.description).allowUnknownOption().action(async(q)=>{let Q=`link-repo ${(Array.isArray(q)?q:[q]).join(" ")}`,X={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=L_.parseArgs(Q),J=await L_.handler($,X);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)});async function d9(){if(Jq()==="hook")await c9();else await i9()}async function c9(){try{let q=await g_(),{command:_}=q.tool_input;if(await X3(`Speck hook called - Command: ${_}`),!_.match(/^speck-/)){await X3(`Skip (not speck-*): ${_}`),console.log(JSON.stringify(i3()));return}await X3(`Intercepting speck command: ${_}`);let Q=_.match(/^speck-(.+?)(?:\s+(.*))?$/);if(!Q)console.error("Failed to parse command:",_),process.exit(1);let[,X,$=""]=Q,J=$.split(/\s+/).filter((R)=>R.length>0),Y=jq[X];if(!Y){await X3(`Unknown command: ${X}`),console.error(`Unknown command: ${X}`),console.log(JSON.stringify(i3()));return}let{log:H,error:W}=console,G="",z="";console.log=(...R)=>{G+=R.join(" ")+`
`},console.error=(...R)=>{z+=R.join(" ")+`
`};let M=0;try{if(Y.main)M=await Y.main(J);else if(Y.handler){let R={mode:"hook",rawCommand:_,workingDirectory:process.cwd(),isInteractive:!1},B=Y.parseArgs?Y.parseArgs(_):{},S=await Y.handler(B,R);if(M=S.exitCode,S.success&&S.output)G+=S.output;if(!S.success&&S.errorOutput)z+=S.errorOutput}else throw Error(`Command ${X} has neither main nor handler`)}catch(R){z+=R instanceof Error?R.message:String(R),M=1}console.log=H,console.error=W;let E=G.trim()||z.trim()||"",v=h_(E,q.tool_input);await X3(`Returning result: ${E.substring(0,100)}`),console.log(JSON.stringify(v))}catch(q){await X3(`Hook error: ${q instanceof Error?q.message:String(q)}`),console.error("Hook error:",q instanceof Error?q.message:String(q)),console.log("{}"),process.exit(1)}}async function i9(){try{await Mq.parseAsync(process.argv)}catch(q){console.error("Error:",q instanceof Error?q.message:String(q)),process.exit(1)}}if(import.meta.main)d9();
