// @bun
var $=Object.create;var{getPrototypeOf:B,defineProperty:T,getOwnPropertyNames:M}=Object;var I=Object.prototype.hasOwnProperty;var F=(j,w,A)=>{A=j!=null?$(B(j)):{};let q=w||!j||!j.__esModule?T(A,"default",{value:j,enumerable:!0}):A;for(let U of M(j))if(!I.call(q,U))T(q,U,{get:()=>j[U],enumerable:!0});return q};var k=(j,w)=>()=>(w||j((w={exports:{}}).exports,w),w.exports);var D=(j,w)=>{for(var A in w)T(j,A,{get:w[A],enumerable:!0,configurable:!0,set:(q)=>w[A]=()=>q})};var x=import.meta.require;import{existsSync as _}from"fs";import{readdirSync as X}from"fs";import V from"fs/promises";import z from"path";var{$:O}=globalThis.Bun;function v(){if(process.env.CLAUDE_PLUGIN_ROOT)return!0;let j=import.meta.dir;return j.includes("/.claude/plugins/")||j.includes("/.config/claude-code/plugins/")}function E(){if(process.env.CLAUDE_PLUGIN_ROOT)return process.env.CLAUDE_PLUGIN_ROOT;let j=import.meta.dir;if(v())return z.resolve(j,"../../..");else return z.resolve(j,"../../..")}function l(){let j=E();if(v())return z.join(j,"templates");else return z.join(j,".speck/templates")}function g(){let j=E();return z.join(j,".speck/scripts")}function h(){let j=E();if(v())return z.join(j,"memory");else return z.join(j,".speck/memory")}async function G(){try{return(await O`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{let j=import.meta.dir;return z.resolve(j,"../../..")}}var J=null;function p(){J=null}async function K(){if(J)return J;let j=await G(),w=z.join(j,".speck","root");try{if(!(await V.lstat(w)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let Y={mode:"single-repo",speckRoot:j,repoRoot:j,specsDir:z.join(j,"specs")};return J=Y,Y}let q=await V.realpath(w),U=["/","/etc","/usr","/bin","/sbin","/System","/Library"],Q=process.env.HOME||process.env.USERPROFILE||"";if(U.some((Y)=>q===Y||q.startsWith(Y+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${q}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(Q&&q===z.dirname(Q))throw Error(`Security: .speck/root symlink points above home directory: ${q}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await V.access(q);let H=z.join(j,"specs");try{if((await V.stat(H)).isDirectory()&&q!==j)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${H}
  Shared: ${z.join(q,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${H}/* ${z.join(q,"specs")}/
  2. Remove local specs: rm -rf ${H}
`)}catch(Y){let Z=Y;if(Z.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${Z.message}`)}let W={mode:"multi-repo",speckRoot:q,repoRoot:j,specsDir:z.join(q,"specs")};return J=W,W}catch(A){let q=A;if(q.code==="ENOENT"){if((await N(j)).length>0){let W={mode:"multi-repo",speckRoot:j,repoRoot:j,specsDir:z.join(j,"specs")};return J=W,W}let H={mode:"single-repo",speckRoot:j,repoRoot:j,specsDir:z.join(j,"specs")};return J=H,H}if(q.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let U=await V.readlink(w).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${U} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}var i=K;async function s(){let j=await K();return j.mode==="multi-repo"&&j.repoRoot!==j.speckRoot}async function C(j,w){try{let A=await V.realpath(j),q=await V.readdir(w,{withFileTypes:!0});for(let U of q)if(U.isSymbolicLink()&&U.name.startsWith(".speck-link-")){let Q=z.join(w,U.name);try{if(await V.realpath(Q)===A)return U.name.replace(/^\.speck-link-/,"")}catch{continue}}}catch{}return z.basename(j)}async function N(j){let w=[];try{let A=await V.readdir(j,{withFileTypes:!0});for(let q of A)if(q.isSymbolicLink()&&q.name.startsWith(".speck-link-")){let U=z.join(j,q.name);try{let Q=await V.realpath(U);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((Y)=>Q===Y||Q.startsWith(Y+"/"))){console.warn(`Security: Skipping ${q.name} - points to system directory: ${Q}`);continue}let W=z.join(Q,".git");try{await V.access(W),w.push(Q)}catch{console.warn(`Warning: ${q.name} points to non-git directory: ${Q}`)}}catch(Q){let H=Q instanceof Error?Q.message:String(Q);console.warn(`Warning: Broken symlink ${q.name}: ${H}`)}}}catch(A){if(A.code!=="ENOENT")throw A}return w}async function n(j){let w=new Map;try{let A=await V.readdir(j,{withFileTypes:!0});for(let q of A)if(q.isSymbolicLink()&&q.name.startsWith(".speck-link-")){let U=z.join(j,q.name),Q=q.name.substring(12);try{let H=await V.realpath(U);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((Z)=>H===Z||H.startsWith(Z+"/"))){console.warn(`Security: Skipping ${q.name} - points to system directory: ${H}`);continue}let Y=z.join(H,".git");try{await V.access(Y),w.set(Q,H)}catch{console.warn(`Warning: ${q.name} points to non-git directory: ${H}`)}}catch(H){let W=H instanceof Error?H.message:String(H);console.warn(`Warning: Broken symlink ${q.name}: ${W}`)}}}catch(A){if(A.code!=="ENOENT")throw A}return w}async function c(){let j=await K();if(j.mode==="single-repo")return{...j,context:"single",parentSpecId:null,childRepoName:null};if(j.repoRoot===j.speckRoot)return{...j,context:"root",parentSpecId:null,childRepoName:null};else{let w=await C(j.repoRoot,j.speckRoot),A=null;try{let q=z.join(j.repoRoot,".speck","branches.json"),U=await V.readFile(q,"utf-8"),Q=JSON.parse(U);if(Q.branches&&Q.branches.length>0)A=Q.branches[0]?.parentSpecId||null}catch{}if(!A)try{let{$:q}=awaitPromise.resolve(globalThis.Bun),Q=(await q`git -C ${j.speckRoot} rev-parse --abbrev-ref HEAD`.quiet()).stdout.toString().trim();if(/^\d{3}-/.test(Q))A=Q}catch{}return{...j,context:"child",parentSpecId:A,childRepoName:w}}}async function S(j){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await O`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let w=z.join(j,"specs");if(_(w)){let A="",q=0,U=X(w,{withFileTypes:!0});for(let Q of U)if(Q.isDirectory()){let H=Q.name.match(/^(\d{3})-/);if(H&&H[1]){let W=parseInt(H[1],10);if(W>q)q=W,A=Q.name}}if(A)return A}return"main"}}async function P(){try{return await O`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function a(j){try{return(await O`git check-ref-format --branch ${j}`.quiet()).exitCode===0}catch{return!1}}async function o(j,w,A){if(!w)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let q=z.join(A,".speck","branches.json");if(_(q))try{let U=await V.readFile(q,"utf-8"),Q=JSON.parse(U);if(Q.branches&&Array.isArray(Q.branches)){if(Q.branches.some((W)=>W.name===j))return!0}}catch{}if(!/^\d{3}-/.test(j))return console.error(`ERROR: Not on a feature branch. Current branch: ${j}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}function r(j,w){return z.join(j,"specs",w)}async function y(j,w,A){let q=z.join(A,".speck","branches.json");if(_(q))try{let W=await V.readFile(q,"utf-8"),Y=JSON.parse(W);if(Y.branches&&Array.isArray(Y.branches)){let Z=Y.branches.find((L)=>L.name===w);if(Z&&Z.specId)return z.join(j,Z.specId)}}catch{}let U=w.match(/^(\d{3})-/);if(!U)return z.join(j,w);let Q=U[1],H=[];if(_(j)){let W=X(j,{withFileTypes:!0});for(let Y of W)if(Y.isDirectory()&&Y.name.startsWith(`${Q}-`))H.push(Y.name)}if(H.length===0)return z.join(j,w);else if(H.length===1&&H[0])return z.join(j,H[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${Q}': ${H.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),z.join(j,w)}async function t(){let j=await K(),w=await S(j.repoRoot),A=await P(),q=await y(j.specsDir,w,j.repoRoot),U=z.basename(q);return{MODE:j.mode,SPECK_ROOT:j.speckRoot,SPECS_DIR:j.specsDir,REPO_ROOT:j.repoRoot,CURRENT_BRANCH:w,HAS_GIT:A?"true":"false",FEATURE_DIR:q,FEATURE_SPEC:z.join(q,"spec.md"),IMPL_PLAN:z.join(j.repoRoot,"specs",U,"plan.md"),TASKS:z.join(j.repoRoot,"specs",U,"tasks.md"),RESEARCH:z.join(q,"research.md"),DATA_MODEL:z.join(q,"data-model.md"),QUICKSTART:z.join(q,"quickstart.md"),CONTRACTS_DIR:z.join(q,"contracts")}}async function e(){try{let j=await G(),w=z.join(j,".speck/memory/constitution.md");if(!_(w))return null;let q=(await V.readFile(w,"utf-8")).match(/^\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)\s*$/m);if(q&&(q[1]==="stacked-pr"||q[1]==="single-branch"))return q[1];return null}catch(j){return null}}function jj(j,w){return _(j)?`  \u2713 ${w}`:`  \u2717 ${w}`}function qj(j,w){if(!_(j))return`  \u2717 ${w}`;try{return X(j).length>0?`  \u2713 ${w}`:`  \u2717 ${w}`}catch{return`  \u2717 ${w}`}}async function wj(j){let w=await K();if(w.mode!=="multi-repo")return!1;let A=z.join(w.speckRoot,"specs",j,"contracts");if(!_(A))return!1;let q=z.join(w.repoRoot,"specs",j);if(!_(q))return!1;let U=z.join(q,"contracts");try{if((await V.lstat(U)).isSymbolicLink()){if(await V.realpath(U)===A)return!0;await V.unlink(U)}else return console.warn(`WARNING: Local contracts/ directory exists but is not a symlink
  Local: ${U}
  Shared: ${A}
  Skipping symlink creation to preserve local data.`),!1}catch(H){if(H.code!=="ENOENT")throw H}let Q=z.relative(q,A);try{return await V.symlink(Q,U,"dir"),!0}catch(H){let W=H instanceof Error?H.message:String(H);return console.warn(`Warning: Failed to create contracts/ symlink: ${W}`),!1}}export{a as validateBranchName,wj as syncSharedContracts,v as isPluginInstallation,s as isMultiRepoChild,P as hasGit,l as getTemplatesDir,g as getScriptsDir,G as getRepoRoot,E as getPluginRoot,c as getMultiRepoContext,h as getMemoryDir,t as getFeaturePaths,r as getFeatureDir,e as getDefaultWorkflowMode,S as getCurrentBranch,C as getChildRepoName,y as findFeatureDirByPrefix,n as findChildReposWithNames,N as findChildRepos,K as detectSpeckRoot,i as detectSpeckMode,p as clearSpeckCache,jj as checkFile,o as checkFeatureBranch,qj as checkDir};
export{F as u,k as v,D as w,x,l as y,G as z,p as A,K as B,s as C,C as D,n as E,c as F,a as G,o as H,t as I,jj as J,qj as K};
