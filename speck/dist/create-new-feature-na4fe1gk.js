#!/usr/bin/env bun
// @bun
import"./speck-ac2ebaf8.js";import{B as C,y as W}from"./paths-x5kskk5z.js";import{existsSync as v,mkdirSync as P,readdirSync as $,copyFileSync as E,symlinkSync as F}from"fs";import Z from"path";var{$:Y}=globalThis.Bun;function y(z){let j={json:!1,sharedSpec:!1,localSpec:!1,help:!1,featureDescription:""},X=[],J=0;while(J<z.length){let q=z[J];if(q==="--json")j.json=!0,J++;else if(q==="--short-name"){if(J+1>=z.length||z[J+1].startsWith("--"))console.error("Error: --short-name requires a value"),process.exit(1);j.shortName=z[J+1],J+=2}else if(q==="--number"){if(J+1>=z.length||z[J+1].startsWith("--"))console.error("Error: --number requires a value"),process.exit(1);let Q=parseInt(z[J+1],10);if(isNaN(Q))console.error("Error: --number requires a numeric value"),process.exit(1);j.number=Q,J+=2}else if(q==="--shared-spec")j.sharedSpec=!0,J++;else if(q==="--local-spec")j.localSpec=!0,J++;else if(q==="--help"||q==="-h")j.help=!0,J++;else X.push(q),J++}return j.featureDescription=X.join(" "),j}function D(){let z=Z.basename(process.argv[1]);console.log(`Usage: ${z} [--json] [--short-name <name>] [--number N] [--shared-spec | --local-spec] <feature_description>

Options:
  --json              Output in JSON format
  --short-name <name> Provide a custom short name (2-4 words) for the branch
  --number N          Specify branch number manually (overrides auto-detection)
  --shared-spec       Create spec at speckRoot (multi-repo shared spec with local symlinks)
  --local-spec        Create spec locally in child repo (single-repo or child-only spec)
  --help, -h          Show this help message

Examples:
  ${z} 'Add user authentication system' --short-name 'user-auth'
  ${z} 'Implement OAuth2 integration for API' --number 5 --shared-spec`)}function R(z){let j=z;while(j!=="/"){if(v(Z.join(j,".git"))||v(Z.join(j,".specify"))||v(Z.join(j,".speck")))return j;j=Z.dirname(j)}return null}function S(z){let j=0;if(v(z)){let X=$(z,{withFileTypes:!0});for(let J of X)if(J.isDirectory()){let q=J.name.match(/^(\d+)/);if(q){let Q=parseInt(q[1],10);if(Q>j)j=Q}}}return j}async function x(z,j){try{await Y`git fetch --all --prune`.quiet()}catch{}let X=0;try{let q=(await Y`git ls-remote --heads origin`.quiet()).text().split(`
`);for(let Q of q){let K=Q.match(new RegExp(`refs/heads/(\\d+)-${z}$`));if(K){let O=parseInt(K[1],10);if(O>X)X=O}}}catch{}try{let q=(await Y`git branch`.quiet()).text().split(`
`);for(let Q of q){let K=Q.match(new RegExp(`^[* ]*?(\\d+)-${z}$`));if(K){let O=parseInt(K[1],10);if(O>X)X=O}}}catch{}if(v(j)){let J=$(j,{withFileTypes:!0});for(let q of J)if(q.isDirectory()){let Q=q.name.match(new RegExp(`^(\\d+)-${z}$`));if(Q){let K=parseInt(Q[1],10);if(K>X)X=K}}}return X+1}function w(z){return z.toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/-+/g,"-").replace(/^-/,"").replace(/-$/,"")}function f(z){let j=new Set(["i","a","an","the","to","for","of","in","on","at","by","with","from","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","should","could","can","may","might","must","shall","this","that","these","those","my","your","our","their","want","need","add","get","set"]),J=z.toLowerCase().replace(/[^a-z0-9]+/g," ").split(/\s+/).filter((K)=>K.length>0),q=[];for(let K of J){if(j.has(K))continue;if(K.length>=3)q.push(K);else{let O=K.toUpperCase();if(z.includes(O))q.push(K)}}if(q.length>0){let K=q.length===4?4:3;return q.slice(0,K).join("-")}return w(z).split("-").filter((K)=>K.length>0).slice(0,3).join("-")}async function h(z){let j=y(z);if(j.help)return D(),0;if(!j.featureDescription)return console.error("Usage: create-new-feature [--json] [--short-name <name>] [--number N] <feature_description>"),1;let X,J=!1;try{X=(await Y`git rev-parse --show-toplevel`.quiet()).text().trim(),J=!0}catch{let U=R(import.meta.dir);if(!U)return console.error("Error: Could not determine repository root. Please run this script from within the repository."),1;X=U,J=!1}let q=await C(),Q,K=!1;if(j.sharedSpec&&q.mode==="multi-repo")Q=Z.join(q.speckRoot,"specs"),K=!0;else Q=Z.join(X,"specs");P(Q,{recursive:!0});let O;if(j.shortName)O=w(j.shortName);else O=f(j.featureDescription);let A;if(j.number!==void 0)A=j.number;else if(J)A=await x(O,Q);else A=S(Q)+1;let H=A.toString().padStart(3,"0"),V=`${H}-${O}`,k=244;if(V.length>k){let M=k-4,U=O.substring(0,M).replace(/-$/,"");console.error("[specify] Warning: Branch name exceeded GitHub's 244-byte limit"),console.error(`[specify] Original: ${V} (${V.length} bytes)`),V=`${H}-${U}`,console.error(`[specify] Truncated to: ${V} (${V.length} bytes)`)}if(J)try{await Y`git checkout -b ${V}`}catch(M){return console.error(`Error: Failed to create git branch: ${M}`),1}else console.error(`[specify] Warning: Git repository not detected; skipped branch creation for ${V}`);if(K&&q.mode==="multi-repo"){let M=q.speckRoot,U=!1;try{if((await Y`git -C ${M} rev-parse --git-dir`.quiet()).exitCode===0)U=!0}catch{}if(!U)console.error(`[specify] Notice: Parent directory is not a git repository: ${M}`),console.error("[specify] To enable branch coordination, initialize it as a git repo:"),console.error(`[specify]   cd ${M} && git init`),console.error("[specify] Skipping parent branch creation for now.");else try{let _=!1;try{_=(await Y`git -C ${M} rev-parse --verify ${V}`.quiet()).exitCode===0}catch{_=!1}if(_){if(await Y`git -C ${M} checkout ${V}`.quiet(),!j.json)console.log(`[specify] Checked out existing branch in parent repo: ${V}`)}else{let L=await Y`git -C ${M} checkout -b ${V}`.quiet();if(L.exitCode!==0)throw Error(`git checkout -b failed with exit code ${L.exitCode}: ${L.stderr}`);if(!j.json)console.log(`[specify] Created branch in parent repo: ${V}`)}}catch(_){console.error(`[specify] Warning: Failed to create branch in parent repo: ${_}`),console.error(`[specify] Parent repo: ${M}`),console.error(`[specify] You may need to manually create the branch: git -C ${M} checkout -b ${V}`)}}let I=Z.join(Q,V);P(I,{recursive:!0});let B=Z.join(W(),"spec-template.md"),T=Z.join(I,"spec.md");if(v(B))E(B,T);else await Bun.write(T,"");if(j.sharedSpec&&q.mode==="multi-repo"){let M=Z.join(X,"specs",V);P(M,{recursive:!0});let U=Z.join(M,"spec.md"),_=Z.relative(M,T);try{F(_,U,"file")}catch(G){if(G.code!=="EEXIST")console.error(`Warning: Failed to create symlink for spec.md: ${G.message}`),console.error(`  From: ${U}`),console.error(`  To: ${T}`)}let L=Z.join(I,"contracts"),b=Z.join(M,"contracts")}if(process.env.SPECIFY_FEATURE=V,j.json)console.log(JSON.stringify({BRANCH_NAME:V,SPEC_FILE:T,FEATURE_NUM:H}));else console.log(`BRANCH_NAME: ${V}`),console.log(`SPEC_FILE: ${T}`),console.log(`FEATURE_NUM: ${H}`),console.log(`SPECIFY_FEATURE environment variable set to: ${V}`);return 0}export{h as main};
