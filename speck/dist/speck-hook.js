#!/usr/bin/env bun
// @bun
import"./speck-ac2ebaf8.js";import{B as PX,H as AX,I as EX,J as x,K as wX,u as D,v as P,x as K}from"./paths-qqmkr5wb.js";var C=P((bX)=>{class c extends Error{constructor(X,Y,Q){super(Q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=Y,this.exitCode=X,this.nestedError=void 0}}class r extends c{constructor(X){super(1,"commander.invalidArgument",X);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}bX.CommanderError=c;bX.InvalidArgumentError=r});var v=P((vX)=>{var{InvalidArgumentError:xX}=C();class e{constructor(X,Y){switch(this.description=Y||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,X[0]){case"<":this.required=!0,this._name=X.slice(1,-1);break;case"[":this.required=!1,this._name=X.slice(1,-1);break;default:this.required=!0,this._name=X;break}if(this._name.endsWith("..."))this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_collectValue(X,Y){if(Y===this.defaultValue||!Array.isArray(Y))return[X];return Y.push(X),Y}default(X,Y){return this.defaultValue=X,this.defaultValueDescription=Y,this}argParser(X){return this.parseArg=X,this}choices(X){return this.argChoices=X.slice(),this.parseArg=(Y,Q)=>{if(!this.argChoices.includes(Y))throw new xX(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue(Y,Q);return Y},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function fX(X){let Y=X.name()+(X.variadic===!0?"...":"");return X.required?"<"+Y+">":"["+Y+"]"}vX.Argument=e;vX.humanReadableArgName=fX});var l=P((cX)=>{var{humanReadableArgName:gX}=v();class XX{constructor(){this.helpWidth=void 0,this.minWidthToWrap=40,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}prepareContext(X){this.helpWidth=this.helpWidth??X.helpWidth??80}visibleCommands(X){let Y=X.commands.filter((J)=>!J._hidden),Q=X._getHelpCommand();if(Q&&!Q._hidden)Y.push(Q);if(this.sortSubcommands)Y.sort((J,Z)=>{return J.name().localeCompare(Z.name())});return Y}compareOptions(X,Y){let Q=(J)=>{return J.short?J.short.replace(/^-/,""):J.long.replace(/^--/,"")};return Q(X).localeCompare(Q(Y))}visibleOptions(X){let Y=X.options.filter((J)=>!J.hidden),Q=X._getHelpOption();if(Q&&!Q.hidden){let J=Q.short&&X._findOption(Q.short),Z=Q.long&&X._findOption(Q.long);if(!J&&!Z)Y.push(Q);else if(Q.long&&!Z)Y.push(X.createOption(Q.long,Q.description));else if(Q.short&&!J)Y.push(X.createOption(Q.short,Q.description))}if(this.sortOptions)Y.sort(this.compareOptions);return Y}visibleGlobalOptions(X){if(!this.showGlobalOptions)return[];let Y=[];for(let Q=X.parent;Q;Q=Q.parent){let J=Q.options.filter((Z)=>!Z.hidden);Y.push(...J)}if(this.sortOptions)Y.sort(this.compareOptions);return Y}visibleArguments(X){if(X._argsDescription)X.registeredArguments.forEach((Y)=>{Y.description=Y.description||X._argsDescription[Y.name()]||""});if(X.registeredArguments.find((Y)=>Y.description))return X.registeredArguments;return[]}subcommandTerm(X){let Y=X.registeredArguments.map((Q)=>gX(Q)).join(" ");return X._name+(X._aliases[0]?"|"+X._aliases[0]:"")+(X.options.length?" [options]":"")+(Y?" "+Y:"")}optionTerm(X){return X.flags}argumentTerm(X){return X.name()}longestSubcommandTermLength(X,Y){return Y.visibleCommands(X).reduce((Q,J)=>{return Math.max(Q,this.displayWidth(Y.styleSubcommandTerm(Y.subcommandTerm(J))))},0)}longestOptionTermLength(X,Y){return Y.visibleOptions(X).reduce((Q,J)=>{return Math.max(Q,this.displayWidth(Y.styleOptionTerm(Y.optionTerm(J))))},0)}longestGlobalOptionTermLength(X,Y){return Y.visibleGlobalOptions(X).reduce((Q,J)=>{return Math.max(Q,this.displayWidth(Y.styleOptionTerm(Y.optionTerm(J))))},0)}longestArgumentTermLength(X,Y){return Y.visibleArguments(X).reduce((Q,J)=>{return Math.max(Q,this.displayWidth(Y.styleArgumentTerm(Y.argumentTerm(J))))},0)}commandUsage(X){let Y=X._name;if(X._aliases[0])Y=Y+"|"+X._aliases[0];let Q="";for(let J=X.parent;J;J=J.parent)Q=J.name()+" "+Q;return Q+Y+" "+X.usage()}commandDescription(X){return X.description()}subcommandDescription(X){return X.summary()||X.description()}optionDescription(X){let Y=[];if(X.argChoices)Y.push(`choices: ${X.argChoices.map((Q)=>JSON.stringify(Q)).join(", ")}`);if(X.defaultValue!==void 0){if(X.required||X.optional||X.isBoolean()&&typeof X.defaultValue==="boolean")Y.push(`default: ${X.defaultValueDescription||JSON.stringify(X.defaultValue)}`)}if(X.presetArg!==void 0&&X.optional)Y.push(`preset: ${JSON.stringify(X.presetArg)}`);if(X.envVar!==void 0)Y.push(`env: ${X.envVar}`);if(Y.length>0){let Q=`(${Y.join(", ")})`;if(X.description)return`${X.description} ${Q}`;return Q}return X.description}argumentDescription(X){let Y=[];if(X.argChoices)Y.push(`choices: ${X.argChoices.map((Q)=>JSON.stringify(Q)).join(", ")}`);if(X.defaultValue!==void 0)Y.push(`default: ${X.defaultValueDescription||JSON.stringify(X.defaultValue)}`);if(Y.length>0){let Q=`(${Y.join(", ")})`;if(X.description)return`${X.description} ${Q}`;return Q}return X.description}formatItemList(X,Y,Q){if(Y.length===0)return[];return[Q.styleTitle(X),...Y,""]}groupItems(X,Y,Q){let J=new Map;return X.forEach((Z)=>{let $=Q(Z);if(!J.has($))J.set($,[])}),Y.forEach((Z)=>{let $=Q(Z);if(!J.has($))J.set($,[]);J.get($).push(Z)}),J}formatHelp(X,Y){let Q=Y.padWidth(X,Y),J=Y.helpWidth??80;function Z(T,U){return Y.formatItem(T,Q,U,Y)}let $=[`${Y.styleTitle("Usage:")} ${Y.styleUsage(Y.commandUsage(X))}`,""],q=Y.commandDescription(X);if(q.length>0)$=$.concat([Y.boxWrap(Y.styleCommandDescription(q),J),""]);let _=Y.visibleArguments(X).map((T)=>{return Z(Y.styleArgumentTerm(Y.argumentTerm(T)),Y.styleArgumentDescription(Y.argumentDescription(T)))});if($=$.concat(this.formatItemList("Arguments:",_,Y)),this.groupItems(X.options,Y.visibleOptions(X),(T)=>T.helpGroupHeading??"Options:").forEach((T,U)=>{let j=T.map((L)=>{return Z(Y.styleOptionTerm(Y.optionTerm(L)),Y.styleOptionDescription(Y.optionDescription(L)))});$=$.concat(this.formatItemList(U,j,Y))}),Y.showGlobalOptions){let T=Y.visibleGlobalOptions(X).map((U)=>{return Z(Y.styleOptionTerm(Y.optionTerm(U)),Y.styleOptionDescription(Y.optionDescription(U)))});$=$.concat(this.formatItemList("Global Options:",T,Y))}return this.groupItems(X.commands,Y.visibleCommands(X),(T)=>T.helpGroup()||"Commands:").forEach((T,U)=>{let j=T.map((L)=>{return Z(Y.styleSubcommandTerm(Y.subcommandTerm(L)),Y.styleSubcommandDescription(Y.subcommandDescription(L)))});$=$.concat(this.formatItemList(U,j,Y))}),$.join(`
`)}displayWidth(X){return YX(X).length}styleTitle(X){return X}styleUsage(X){return X.split(" ").map((Y)=>{if(Y==="[options]")return this.styleOptionText(Y);if(Y==="[command]")return this.styleSubcommandText(Y);if(Y[0]==="["||Y[0]==="<")return this.styleArgumentText(Y);return this.styleCommandText(Y)}).join(" ")}styleCommandDescription(X){return this.styleDescriptionText(X)}styleOptionDescription(X){return this.styleDescriptionText(X)}styleSubcommandDescription(X){return this.styleDescriptionText(X)}styleArgumentDescription(X){return this.styleDescriptionText(X)}styleDescriptionText(X){return X}styleOptionTerm(X){return this.styleOptionText(X)}styleSubcommandTerm(X){return X.split(" ").map((Y)=>{if(Y==="[options]")return this.styleOptionText(Y);if(Y[0]==="["||Y[0]==="<")return this.styleArgumentText(Y);return this.styleSubcommandText(Y)}).join(" ")}styleArgumentTerm(X){return this.styleArgumentText(X)}styleOptionText(X){return X}styleArgumentText(X){return X}styleSubcommandText(X){return X}styleCommandText(X){return X}padWidth(X,Y){return Math.max(Y.longestOptionTermLength(X,Y),Y.longestGlobalOptionTermLength(X,Y),Y.longestSubcommandTermLength(X,Y),Y.longestArgumentTermLength(X,Y))}preformatted(X){return/\n[^\S\r\n]/.test(X)}formatItem(X,Y,Q,J){let $=" ".repeat(2);if(!Q)return $+X;let q=X.padEnd(Y+X.length-J.displayWidth(X)),_=2,G=(this.helpWidth??80)-Y-_-2,T;if(G<this.minWidthToWrap||J.preformatted(Q))T=Q;else T=J.boxWrap(Q,G).replace(/\n/g,`
`+" ".repeat(Y+_));return $+q+" ".repeat(_)+T.replace(/\n/g,`
${$}`)}boxWrap(X,Y){if(Y<this.minWidthToWrap)return X;let Q=X.split(/\r\n|\n/),J=/[\s]*[^\s]+/g,Z=[];return Q.forEach(($)=>{let q=$.match(J);if(q===null){Z.push("");return}let _=[q.shift()],B=this.displayWidth(_[0]);q.forEach((G)=>{let T=this.displayWidth(G);if(B+T<=Y){_.push(G),B+=T;return}Z.push(_.join(""));let U=G.trimStart();_=[U],B=this.displayWidth(U)}),Z.push(_.join(""))}),Z.join(`
`)}}function YX(X){let Y=/\x1b\[\d*(;\d*)*m/g;return X.replace(Y,"")}cX.Help=XX;cX.stripColor=YX});var m=P((iX)=>{var{InvalidArgumentError:dX}=C();class JX{constructor(X,Y){this.flags=X,this.description=Y||"",this.required=X.includes("<"),this.optional=X.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(X),this.mandatory=!1;let Q=pX(X);if(this.short=Q.shortFlag,this.long=Q.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0,this.helpGroupHeading=void 0}default(X,Y){return this.defaultValue=X,this.defaultValueDescription=Y,this}preset(X){return this.presetArg=X,this}conflicts(X){return this.conflictsWith=this.conflictsWith.concat(X),this}implies(X){let Y=X;if(typeof X==="string")Y={[X]:!0};return this.implied=Object.assign(this.implied||{},Y),this}env(X){return this.envVar=X,this}argParser(X){return this.parseArg=X,this}makeOptionMandatory(X=!0){return this.mandatory=!!X,this}hideHelp(X=!0){return this.hidden=!!X,this}_collectValue(X,Y){if(Y===this.defaultValue||!Array.isArray(Y))return[X];return Y.push(X),Y}choices(X){return this.argChoices=X.slice(),this.parseArg=(Y,Q)=>{if(!this.argChoices.includes(Y))throw new dX(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue(Y,Q);return Y},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){if(this.negate)return QX(this.name().replace(/^no-/,""));return QX(this.name())}helpGroup(X){return this.helpGroupHeading=X,this}is(X){return this.short===X||this.long===X}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class ZX{constructor(X){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,X.forEach((Y)=>{if(Y.negate)this.negativeOptions.set(Y.attributeName(),Y);else this.positiveOptions.set(Y.attributeName(),Y)}),this.negativeOptions.forEach((Y,Q)=>{if(this.positiveOptions.has(Q))this.dualOptions.add(Q)})}valueFromOption(X,Y){let Q=Y.attributeName();if(!this.dualOptions.has(Q))return!0;let J=this.negativeOptions.get(Q).presetArg,Z=J!==void 0?J:!1;return Y.negate===(Z===X)}}function QX(X){return X.split("-").reduce((Y,Q)=>{return Y+Q[0].toUpperCase()+Q.slice(1)})}function pX(X){let Y,Q,J=/^-[^-]$/,Z=/^--[^-]/,$=X.split(/[ |,]+/).concat("guard");if(J.test($[0]))Y=$.shift();if(Z.test($[0]))Q=$.shift();if(!Y&&J.test($[0]))Y=$.shift();if(!Y&&Z.test($[0]))Y=Q,Q=$.shift();if($[0].startsWith("-")){let q=$[0],_=`option creation failed due to '${q}' in option flags '${X}'`;if(/^-[^-][^-]/.test(q))throw Error(`${_}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);if(J.test(q))throw Error(`${_}
- too many short flags`);if(Z.test(q))throw Error(`${_}
- too many long flags`);throw Error(`${_}
- unrecognised flag format`)}if(Y===void 0&&Q===void 0)throw Error(`option creation failed due to no flags found in '${X}'.`);return{shortFlag:Y,longFlag:Q}}iX.Option=JX;iX.DualOptions=ZX});var $X=P((oX)=>{function aX(X,Y){if(Math.abs(X.length-Y.length)>3)return Math.max(X.length,Y.length);let Q=[];for(let J=0;J<=X.length;J++)Q[J]=[J];for(let J=0;J<=Y.length;J++)Q[0][J]=J;for(let J=1;J<=Y.length;J++)for(let Z=1;Z<=X.length;Z++){let $=1;if(X[Z-1]===Y[J-1])$=0;else $=1;if(Q[Z][J]=Math.min(Q[Z-1][J]+1,Q[Z][J-1]+1,Q[Z-1][J-1]+$),Z>1&&J>1&&X[Z-1]===Y[J-2]&&X[Z-2]===Y[J-1])Q[Z][J]=Math.min(Q[Z][J],Q[Z-2][J-2]+1)}return Q[X.length][Y.length]}function tX(X,Y){if(!Y||Y.length===0)return"";Y=Array.from(new Set(Y));let Q=X.startsWith("--");if(Q)X=X.slice(2),Y=Y.map((q)=>q.slice(2));let J=[],Z=3,$=0.4;if(Y.forEach((q)=>{if(q.length<=1)return;let _=aX(X,q),B=Math.max(X.length,q.length);if((B-_)/B>$){if(_<Z)Z=_,J=[q];else if(_===Z)J.push(q)}}),J.sort((q,_)=>q.localeCompare(_)),Q)J=J.map((q)=>`--${q}`);if(J.length>1)return`
(Did you mean one of ${J.join(", ")}?)`;if(J.length===1)return`
(Did you mean ${J[0]}?)`;return""}oX.suggestSimilar=tX});var TX=P(($Y)=>{var eX=K("events").EventEmitter,d=K("child_process"),M=K("path"),h=K("fs"),z=K("process"),{Argument:XY,humanReadableArgName:YY}=v(),{CommanderError:p}=C(),{Help:QY,stripColor:JY}=l(),{Option:qX,DualOptions:ZY}=m(),{suggestSimilar:_X}=$X();class s extends eX{constructor(X){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!1,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=X||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._savedState=null,this._outputConfiguration={writeOut:(Y)=>z.stdout.write(Y),writeErr:(Y)=>z.stderr.write(Y),outputError:(Y,Q)=>Q(Y),getOutHelpWidth:()=>z.stdout.isTTY?z.stdout.columns:void 0,getErrHelpWidth:()=>z.stderr.isTTY?z.stderr.columns:void 0,getOutHasColors:()=>i()??(z.stdout.isTTY&&z.stdout.hasColors?.()),getErrHasColors:()=>i()??(z.stderr.isTTY&&z.stderr.hasColors?.()),stripColor:(Y)=>JY(Y)},this._hidden=!1,this._helpOption=void 0,this._addImplicitHelpCommand=void 0,this._helpCommand=void 0,this._helpConfiguration={},this._helpGroupHeading=void 0,this._defaultCommandGroup=void 0,this._defaultOptionGroup=void 0}copyInheritedSettings(X){return this._outputConfiguration=X._outputConfiguration,this._helpOption=X._helpOption,this._helpCommand=X._helpCommand,this._helpConfiguration=X._helpConfiguration,this._exitCallback=X._exitCallback,this._storeOptionsAsProperties=X._storeOptionsAsProperties,this._combineFlagAndOptionalValue=X._combineFlagAndOptionalValue,this._allowExcessArguments=X._allowExcessArguments,this._enablePositionalOptions=X._enablePositionalOptions,this._showHelpAfterError=X._showHelpAfterError,this._showSuggestionAfterError=X._showSuggestionAfterError,this}_getCommandAndAncestors(){let X=[];for(let Y=this;Y;Y=Y.parent)X.push(Y);return X}command(X,Y,Q){let J=Y,Z=Q;if(typeof J==="object"&&J!==null)Z=J,J=null;Z=Z||{};let[,$,q]=X.match(/([^ ]+) *(.*)/),_=this.createCommand($);if(J)_.description(J),_._executableHandler=!0;if(Z.isDefault)this._defaultCommandName=_._name;if(_._hidden=!!(Z.noHelp||Z.hidden),_._executableFile=Z.executableFile||null,q)_.arguments(q);if(this._registerCommand(_),_.parent=this,_.copyInheritedSettings(this),J)return this;return _}createCommand(X){return new s(X)}createHelp(){return Object.assign(new QY,this.configureHelp())}configureHelp(X){if(X===void 0)return this._helpConfiguration;return this._helpConfiguration=X,this}configureOutput(X){if(X===void 0)return this._outputConfiguration;return this._outputConfiguration={...this._outputConfiguration,...X},this}showHelpAfterError(X=!0){if(typeof X!=="string")X=!!X;return this._showHelpAfterError=X,this}showSuggestionAfterError(X=!0){return this._showSuggestionAfterError=!!X,this}addCommand(X,Y){if(!X._name)throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if(Y=Y||{},Y.isDefault)this._defaultCommandName=X._name;if(Y.noHelp||Y.hidden)X._hidden=!0;return this._registerCommand(X),X.parent=this,X._checkForBrokenPassThrough(),this}createArgument(X,Y){return new XY(X,Y)}argument(X,Y,Q,J){let Z=this.createArgument(X,Y);if(typeof Q==="function")Z.default(J).argParser(Q);else Z.default(Q);return this.addArgument(Z),this}arguments(X){return X.trim().split(/ +/).forEach((Y)=>{this.argument(Y)}),this}addArgument(X){let Y=this.registeredArguments.slice(-1)[0];if(Y?.variadic)throw Error(`only the last argument can be variadic '${Y.name()}'`);if(X.required&&X.defaultValue!==void 0&&X.parseArg===void 0)throw Error(`a default value for a required argument is never used: '${X.name()}'`);return this.registeredArguments.push(X),this}helpCommand(X,Y){if(typeof X==="boolean"){if(this._addImplicitHelpCommand=X,X&&this._defaultCommandGroup)this._initCommandGroup(this._getHelpCommand());return this}let Q=X??"help [command]",[,J,Z]=Q.match(/([^ ]+) *(.*)/),$=Y??"display help for command",q=this.createCommand(J);if(q.helpOption(!1),Z)q.arguments(Z);if($)q.description($);if(this._addImplicitHelpCommand=!0,this._helpCommand=q,X||Y)this._initCommandGroup(q);return this}addHelpCommand(X,Y){if(typeof X!=="object")return this.helpCommand(X,Y),this;return this._addImplicitHelpCommand=!0,this._helpCommand=X,this._initCommandGroup(X),this}_getHelpCommand(){if(this._addImplicitHelpCommand??(this.commands.length&&!this._actionHandler&&!this._findCommand("help"))){if(this._helpCommand===void 0)this.helpCommand(void 0,void 0);return this._helpCommand}return null}hook(X,Y){let Q=["preSubcommand","preAction","postAction"];if(!Q.includes(X))throw Error(`Unexpected value for event passed to hook : '${X}'.
Expecting one of '${Q.join("', '")}'`);if(this._lifeCycleHooks[X])this._lifeCycleHooks[X].push(Y);else this._lifeCycleHooks[X]=[Y];return this}exitOverride(X){if(X)this._exitCallback=X;else this._exitCallback=(Y)=>{if(Y.code!=="commander.executeSubCommandAsync")throw Y};return this}_exit(X,Y,Q){if(this._exitCallback)this._exitCallback(new p(X,Y,Q));z.exit(X)}action(X){let Y=(Q)=>{let J=this.registeredArguments.length,Z=Q.slice(0,J);if(this._storeOptionsAsProperties)Z[J]=this;else Z[J]=this.opts();return Z.push(this),X.apply(this,Z)};return this._actionHandler=Y,this}createOption(X,Y){return new qX(X,Y)}_callParseArg(X,Y,Q,J){try{return X.parseArg(Y,Q)}catch(Z){if(Z.code==="commander.invalidArgument"){let $=`${J} ${Z.message}`;this.error($,{exitCode:Z.exitCode,code:Z.code})}throw Z}}_registerOption(X){let Y=X.short&&this._findOption(X.short)||X.long&&this._findOption(X.long);if(Y){let Q=X.long&&this._findOption(X.long)?X.long:X.short;throw Error(`Cannot add option '${X.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${Q}'
-  already used by option '${Y.flags}'`)}this._initOptionGroup(X),this.options.push(X)}_registerCommand(X){let Y=(J)=>{return[J.name()].concat(J.aliases())},Q=Y(X).find((J)=>this._findCommand(J));if(Q){let J=Y(this._findCommand(Q)).join("|"),Z=Y(X).join("|");throw Error(`cannot add command '${Z}' as already have command '${J}'`)}this._initCommandGroup(X),this.commands.push(X)}addOption(X){this._registerOption(X);let Y=X.name(),Q=X.attributeName();if(X.negate){let Z=X.long.replace(/^--no-/,"--");if(!this._findOption(Z))this.setOptionValueWithSource(Q,X.defaultValue===void 0?!0:X.defaultValue,"default")}else if(X.defaultValue!==void 0)this.setOptionValueWithSource(Q,X.defaultValue,"default");let J=(Z,$,q)=>{if(Z==null&&X.presetArg!==void 0)Z=X.presetArg;let _=this.getOptionValue(Q);if(Z!==null&&X.parseArg)Z=this._callParseArg(X,Z,_,$);else if(Z!==null&&X.variadic)Z=X._collectValue(Z,_);if(Z==null)if(X.negate)Z=!1;else if(X.isBoolean()||X.optional)Z=!0;else Z="";this.setOptionValueWithSource(Q,Z,q)};if(this.on("option:"+Y,(Z)=>{let $=`error: option '${X.flags}' argument '${Z}' is invalid.`;J(Z,$,"cli")}),X.envVar)this.on("optionEnv:"+Y,(Z)=>{let $=`error: option '${X.flags}' value '${Z}' from env '${X.envVar}' is invalid.`;J(Z,$,"env")});return this}_optionEx(X,Y,Q,J,Z){if(typeof Y==="object"&&Y instanceof qX)throw Error("To add an Option object use addOption() instead of option() or requiredOption()");let $=this.createOption(Y,Q);if($.makeOptionMandatory(!!X.mandatory),typeof J==="function")$.default(Z).argParser(J);else if(J instanceof RegExp){let q=J;J=(_,B)=>{let G=q.exec(_);return G?G[0]:B},$.default(Z).argParser(J)}else $.default(J);return this.addOption($)}option(X,Y,Q,J){return this._optionEx({},X,Y,Q,J)}requiredOption(X,Y,Q,J){return this._optionEx({mandatory:!0},X,Y,Q,J)}combineFlagAndOptionalValue(X=!0){return this._combineFlagAndOptionalValue=!!X,this}allowUnknownOption(X=!0){return this._allowUnknownOption=!!X,this}allowExcessArguments(X=!0){return this._allowExcessArguments=!!X,this}enablePositionalOptions(X=!0){return this._enablePositionalOptions=!!X,this}passThroughOptions(X=!0){return this._passThroughOptions=!!X,this._checkForBrokenPassThrough(),this}_checkForBrokenPassThrough(){if(this.parent&&this._passThroughOptions&&!this.parent._enablePositionalOptions)throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)}storeOptionsAsProperties(X=!0){if(this.options.length)throw Error("call .storeOptionsAsProperties() before adding options");if(Object.keys(this._optionValues).length)throw Error("call .storeOptionsAsProperties() before setting option values");return this._storeOptionsAsProperties=!!X,this}getOptionValue(X){if(this._storeOptionsAsProperties)return this[X];return this._optionValues[X]}setOptionValue(X,Y){return this.setOptionValueWithSource(X,Y,void 0)}setOptionValueWithSource(X,Y,Q){if(this._storeOptionsAsProperties)this[X]=Y;else this._optionValues[X]=Y;return this._optionValueSources[X]=Q,this}getOptionValueSource(X){return this._optionValueSources[X]}getOptionValueSourceWithGlobals(X){let Y;return this._getCommandAndAncestors().forEach((Q)=>{if(Q.getOptionValueSource(X)!==void 0)Y=Q.getOptionValueSource(X)}),Y}_prepareUserArgs(X,Y){if(X!==void 0&&!Array.isArray(X))throw Error("first parameter to parse must be array or undefined");if(Y=Y||{},X===void 0&&Y.from===void 0){if(z.versions?.electron)Y.from="electron";let J=z.execArgv??[];if(J.includes("-e")||J.includes("--eval")||J.includes("-p")||J.includes("--print"))Y.from="eval"}if(X===void 0)X=z.argv;this.rawArgs=X.slice();let Q;switch(Y.from){case void 0:case"node":this._scriptPath=X[1],Q=X.slice(2);break;case"electron":if(z.defaultApp)this._scriptPath=X[1],Q=X.slice(2);else Q=X.slice(1);break;case"user":Q=X.slice(0);break;case"eval":Q=X.slice(1);break;default:throw Error(`unexpected parse option { from: '${Y.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",Q}parse(X,Y){this._prepareForParse();let Q=this._prepareUserArgs(X,Y);return this._parseCommand([],Q),this}async parseAsync(X,Y){this._prepareForParse();let Q=this._prepareUserArgs(X,Y);return await this._parseCommand([],Q),this}_prepareForParse(){if(this._savedState===null)this.saveStateBeforeParse();else this.restoreStateBeforeParse()}saveStateBeforeParse(){this._savedState={_name:this._name,_optionValues:{...this._optionValues},_optionValueSources:{...this._optionValueSources}}}restoreStateBeforeParse(){if(this._storeOptionsAsProperties)throw Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);this._name=this._savedState._name,this._scriptPath=null,this.rawArgs=[],this._optionValues={...this._savedState._optionValues},this._optionValueSources={...this._savedState._optionValueSources},this.args=[],this.processedArgs=[]}_checkForMissingExecutable(X,Y,Q){if(h.existsSync(X))return;let J=Y?`searched for local subcommand relative to directory '${Y}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",Z=`'${X}' does not exist
 - if '${Q}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${J}`;throw Error(Z)}_executeSubCommand(X,Y){Y=Y.slice();let Q=!1,J=[".js",".ts",".tsx",".mjs",".cjs"];function Z(G,T){let U=M.resolve(G,T);if(h.existsSync(U))return U;if(J.includes(M.extname(T)))return;let j=J.find((L)=>h.existsSync(`${U}${L}`));if(j)return`${U}${j}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let $=X._executableFile||`${this._name}-${X._name}`,q=this._executableDir||"";if(this._scriptPath){let G;try{G=h.realpathSync(this._scriptPath)}catch{G=this._scriptPath}q=M.resolve(M.dirname(G),q)}if(q){let G=Z(q,$);if(!G&&!X._executableFile&&this._scriptPath){let T=M.basename(this._scriptPath,M.extname(this._scriptPath));if(T!==this._name)G=Z(q,`${T}-${X._name}`)}$=G||$}Q=J.includes(M.extname($));let _;if(z.platform!=="win32")if(Q)Y.unshift($),Y=GX(z.execArgv).concat(Y),_=d.spawn(z.argv[0],Y,{stdio:"inherit"});else _=d.spawn($,Y,{stdio:"inherit"});else this._checkForMissingExecutable($,q,X._name),Y.unshift($),Y=GX(z.execArgv).concat(Y),_=d.spawn(z.execPath,Y,{stdio:"inherit"});if(!_.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((T)=>{z.on(T,()=>{if(_.killed===!1&&_.exitCode===null)_.kill(T)})});let B=this._exitCallback;_.on("close",(G)=>{if(G=G??1,!B)z.exit(G);else B(new p(G,"commander.executeSubCommandAsync","(close)"))}),_.on("error",(G)=>{if(G.code==="ENOENT")this._checkForMissingExecutable($,q,X._name);else if(G.code==="EACCES")throw Error(`'${$}' not executable`);if(!B)z.exit(1);else{let T=new p(1,"commander.executeSubCommandAsync","(error)");T.nestedError=G,B(T)}}),this.runningCommand=_}_dispatchSubcommand(X,Y,Q){let J=this._findCommand(X);if(!J)this.help({error:!0});J._prepareForParse();let Z;return Z=this._chainOrCallSubCommandHook(Z,J,"preSubcommand"),Z=this._chainOrCall(Z,()=>{if(J._executableHandler)this._executeSubCommand(J,Y.concat(Q));else return J._parseCommand(Y,Q)}),Z}_dispatchHelpCommand(X){if(!X)this.help();let Y=this._findCommand(X);if(Y&&!Y._executableHandler)Y.help();return this._dispatchSubcommand(X,[],[this._getHelpOption()?.long??this._getHelpOption()?.short??"--help"])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((X,Y)=>{if(X.required&&this.args[Y]==null)this.missingArgument(X.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let X=(Q,J,Z)=>{let $=J;if(J!==null&&Q.parseArg){let q=`error: command-argument value '${J}' is invalid for argument '${Q.name()}'.`;$=this._callParseArg(Q,J,Z,q)}return $};this._checkNumberOfArguments();let Y=[];this.registeredArguments.forEach((Q,J)=>{let Z=Q.defaultValue;if(Q.variadic){if(J<this.args.length){if(Z=this.args.slice(J),Q.parseArg)Z=Z.reduce(($,q)=>{return X(Q,q,$)},Q.defaultValue)}else if(Z===void 0)Z=[]}else if(J<this.args.length){if(Z=this.args[J],Q.parseArg)Z=X(Q,Z,Q.defaultValue)}Y[J]=Z}),this.processedArgs=Y}_chainOrCall(X,Y){if(X?.then&&typeof X.then==="function")return X.then(()=>Y());return Y()}_chainOrCallHooks(X,Y){let Q=X,J=[];if(this._getCommandAndAncestors().reverse().filter((Z)=>Z._lifeCycleHooks[Y]!==void 0).forEach((Z)=>{Z._lifeCycleHooks[Y].forEach(($)=>{J.push({hookedCommand:Z,callback:$})})}),Y==="postAction")J.reverse();return J.forEach((Z)=>{Q=this._chainOrCall(Q,()=>{return Z.callback(Z.hookedCommand,this)})}),Q}_chainOrCallSubCommandHook(X,Y,Q){let J=X;if(this._lifeCycleHooks[Q]!==void 0)this._lifeCycleHooks[Q].forEach((Z)=>{J=this._chainOrCall(J,()=>{return Z(this,Y)})});return J}_parseCommand(X,Y){let Q=this.parseOptions(Y);if(this._parseOptionsEnv(),this._parseOptionsImplied(),X=X.concat(Q.operands),Y=Q.unknown,this.args=X.concat(Y),X&&this._findCommand(X[0]))return this._dispatchSubcommand(X[0],X.slice(1),Y);if(this._getHelpCommand()&&X[0]===this._getHelpCommand().name())return this._dispatchHelpCommand(X[1]);if(this._defaultCommandName)return this._outputHelpIfRequested(Y),this._dispatchSubcommand(this._defaultCommandName,X,Y);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});this._outputHelpIfRequested(Q.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let J=()=>{if(Q.unknown.length>0)this.unknownOption(Q.unknown[0])},Z=`command:${this.name()}`;if(this._actionHandler){J(),this._processArguments();let $;if($=this._chainOrCallHooks($,"preAction"),$=this._chainOrCall($,()=>this._actionHandler(this.processedArgs)),this.parent)$=this._chainOrCall($,()=>{this.parent.emit(Z,X,Y)});return $=this._chainOrCallHooks($,"postAction"),$}if(this.parent?.listenerCount(Z))J(),this._processArguments(),this.parent.emit(Z,X,Y);else if(X.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",X,Y);if(this.listenerCount("command:*"))this.emit("command:*",X,Y);else if(this.commands.length)this.unknownCommand();else J(),this._processArguments()}else if(this.commands.length)J(),this.help({error:!0});else J(),this._processArguments()}_findCommand(X){if(!X)return;return this.commands.find((Y)=>Y._name===X||Y._aliases.includes(X))}_findOption(X){return this.options.find((Y)=>Y.is(X))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((X)=>{X.options.forEach((Y)=>{if(Y.mandatory&&X.getOptionValue(Y.attributeName())===void 0)X.missingMandatoryOptionValue(Y)})})}_checkForConflictingLocalOptions(){let X=this.options.filter((Q)=>{let J=Q.attributeName();if(this.getOptionValue(J)===void 0)return!1;return this.getOptionValueSource(J)!=="default"});X.filter((Q)=>Q.conflictsWith.length>0).forEach((Q)=>{let J=X.find((Z)=>Q.conflictsWith.includes(Z.attributeName()));if(J)this._conflictingOption(Q,J)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((X)=>{X._checkForConflictingLocalOptions()})}parseOptions(X){let Y=[],Q=[],J=Y;function Z(G){return G.length>1&&G[0]==="-"}let $=(G)=>{if(!/^-(\d+|\d*\.\d+)(e[+-]?\d+)?$/.test(G))return!1;return!this._getCommandAndAncestors().some((T)=>T.options.map((U)=>U.short).some((U)=>/^-\d$/.test(U)))},q=null,_=null,B=0;while(B<X.length||_){let G=_??X[B++];if(_=null,G==="--"){if(J===Q)J.push(G);J.push(...X.slice(B));break}if(q&&(!Z(G)||$(G))){this.emit(`option:${q.name()}`,G);continue}if(q=null,Z(G)){let T=this._findOption(G);if(T){if(T.required){let U=X[B++];if(U===void 0)this.optionMissingArgument(T);this.emit(`option:${T.name()}`,U)}else if(T.optional){let U=null;if(B<X.length&&(!Z(X[B])||$(X[B])))U=X[B++];this.emit(`option:${T.name()}`,U)}else this.emit(`option:${T.name()}`);q=T.variadic?T:null;continue}}if(G.length>2&&G[0]==="-"&&G[1]!=="-"){let T=this._findOption(`-${G[1]}`);if(T){if(T.required||T.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${T.name()}`,G.slice(2));else this.emit(`option:${T.name()}`),_=`-${G.slice(2)}`;continue}}if(/^--[^=]+=/.test(G)){let T=G.indexOf("="),U=this._findOption(G.slice(0,T));if(U&&(U.required||U.optional)){this.emit(`option:${U.name()}`,G.slice(T+1));continue}}if(J===Y&&Z(G)&&!(this.commands.length===0&&$(G)))J=Q;if((this._enablePositionalOptions||this._passThroughOptions)&&Y.length===0&&Q.length===0){if(this._findCommand(G)){Y.push(G),Q.push(...X.slice(B));break}else if(this._getHelpCommand()&&G===this._getHelpCommand().name()){Y.push(G,...X.slice(B));break}else if(this._defaultCommandName){Q.push(G,...X.slice(B));break}}if(this._passThroughOptions){J.push(G,...X.slice(B));break}J.push(G)}return{operands:Y,unknown:Q}}opts(){if(this._storeOptionsAsProperties){let X={},Y=this.options.length;for(let Q=0;Q<Y;Q++){let J=this.options[Q].attributeName();X[J]=J===this._versionOptionName?this._version:this[J]}return X}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((X,Y)=>Object.assign(X,Y.opts()),{})}error(X,Y){if(this._outputConfiguration.outputError(`${X}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let Q=Y||{},J=Q.exitCode||1,Z=Q.code||"commander.error";this._exit(J,Z,X)}_parseOptionsEnv(){this.options.forEach((X)=>{if(X.envVar&&X.envVar in z.env){let Y=X.attributeName();if(this.getOptionValue(Y)===void 0||["default","config","env"].includes(this.getOptionValueSource(Y)))if(X.required||X.optional)this.emit(`optionEnv:${X.name()}`,z.env[X.envVar]);else this.emit(`optionEnv:${X.name()}`)}})}_parseOptionsImplied(){let X=new ZY(this.options),Y=(Q)=>{return this.getOptionValue(Q)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(Q))};this.options.filter((Q)=>Q.implied!==void 0&&Y(Q.attributeName())&&X.valueFromOption(this.getOptionValue(Q.attributeName()),Q)).forEach((Q)=>{Object.keys(Q.implied).filter((J)=>!Y(J)).forEach((J)=>{this.setOptionValueWithSource(J,Q.implied[J],"implied")})})}missingArgument(X){let Y=`error: missing required argument '${X}'`;this.error(Y,{code:"commander.missingArgument"})}optionMissingArgument(X){let Y=`error: option '${X.flags}' argument missing`;this.error(Y,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(X){let Y=`error: required option '${X.flags}' not specified`;this.error(Y,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(X,Y){let Q=($)=>{let q=$.attributeName(),_=this.getOptionValue(q),B=this.options.find((T)=>T.negate&&q===T.attributeName()),G=this.options.find((T)=>!T.negate&&q===T.attributeName());if(B&&(B.presetArg===void 0&&_===!1||B.presetArg!==void 0&&_===B.presetArg))return B;return G||$},J=($)=>{let q=Q($),_=q.attributeName();if(this.getOptionValueSource(_)==="env")return`environment variable '${q.envVar}'`;return`option '${q.flags}'`},Z=`error: ${J(X)} cannot be used with ${J(Y)}`;this.error(Z,{code:"commander.conflictingOption"})}unknownOption(X){if(this._allowUnknownOption)return;let Y="";if(X.startsWith("--")&&this._showSuggestionAfterError){let J=[],Z=this;do{let $=Z.createHelp().visibleOptions(Z).filter((q)=>q.long).map((q)=>q.long);J=J.concat($),Z=Z.parent}while(Z&&!Z._enablePositionalOptions);Y=_X(X,J)}let Q=`error: unknown option '${X}'${Y}`;this.error(Q,{code:"commander.unknownOption"})}_excessArguments(X){if(this._allowExcessArguments)return;let Y=this.registeredArguments.length,Q=Y===1?"":"s",Z=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${Y} argument${Q} but got ${X.length}.`;this.error(Z,{code:"commander.excessArguments"})}unknownCommand(){let X=this.args[0],Y="";if(this._showSuggestionAfterError){let J=[];this.createHelp().visibleCommands(this).forEach((Z)=>{if(J.push(Z.name()),Z.alias())J.push(Z.alias())}),Y=_X(X,J)}let Q=`error: unknown command '${X}'${Y}`;this.error(Q,{code:"commander.unknownCommand"})}version(X,Y,Q){if(X===void 0)return this._version;this._version=X,Y=Y||"-V, --version",Q=Q||"output the version number";let J=this.createOption(Y,Q);return this._versionOptionName=J.attributeName(),this._registerOption(J),this.on("option:"+J.name(),()=>{this._outputConfiguration.writeOut(`${X}
`),this._exit(0,"commander.version",X)}),this}description(X,Y){if(X===void 0&&Y===void 0)return this._description;if(this._description=X,Y)this._argsDescription=Y;return this}summary(X){if(X===void 0)return this._summary;return this._summary=X,this}alias(X){if(X===void 0)return this._aliases[0];let Y=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)Y=this.commands[this.commands.length-1];if(X===Y._name)throw Error("Command alias can't be the same as its name");let Q=this.parent?._findCommand(X);if(Q){let J=[Q.name()].concat(Q.aliases()).join("|");throw Error(`cannot add alias '${X}' to command '${this.name()}' as already have command '${J}'`)}return Y._aliases.push(X),this}aliases(X){if(X===void 0)return this._aliases;return X.forEach((Y)=>this.alias(Y)),this}usage(X){if(X===void 0){if(this._usage)return this._usage;let Y=this.registeredArguments.map((Q)=>{return YY(Q)});return[].concat(this.options.length||this._helpOption!==null?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?Y:[]).join(" ")}return this._usage=X,this}name(X){if(X===void 0)return this._name;return this._name=X,this}helpGroup(X){if(X===void 0)return this._helpGroupHeading??"";return this._helpGroupHeading=X,this}commandsGroup(X){if(X===void 0)return this._defaultCommandGroup??"";return this._defaultCommandGroup=X,this}optionsGroup(X){if(X===void 0)return this._defaultOptionGroup??"";return this._defaultOptionGroup=X,this}_initOptionGroup(X){if(this._defaultOptionGroup&&!X.helpGroupHeading)X.helpGroup(this._defaultOptionGroup)}_initCommandGroup(X){if(this._defaultCommandGroup&&!X.helpGroup())X.helpGroup(this._defaultCommandGroup)}nameFromFilename(X){return this._name=M.basename(X,M.extname(X)),this}executableDir(X){if(X===void 0)return this._executableDir;return this._executableDir=X,this}helpInformation(X){let Y=this.createHelp(),Q=this._getOutputContext(X);Y.prepareContext({error:Q.error,helpWidth:Q.helpWidth,outputHasColors:Q.hasColors});let J=Y.formatHelp(this,Y);if(Q.hasColors)return J;return this._outputConfiguration.stripColor(J)}_getOutputContext(X){X=X||{};let Y=!!X.error,Q,J,Z;if(Y)Q=(q)=>this._outputConfiguration.writeErr(q),J=this._outputConfiguration.getErrHasColors(),Z=this._outputConfiguration.getErrHelpWidth();else Q=(q)=>this._outputConfiguration.writeOut(q),J=this._outputConfiguration.getOutHasColors(),Z=this._outputConfiguration.getOutHelpWidth();return{error:Y,write:(q)=>{if(!J)q=this._outputConfiguration.stripColor(q);return Q(q)},hasColors:J,helpWidth:Z}}outputHelp(X){let Y;if(typeof X==="function")Y=X,X=void 0;let Q=this._getOutputContext(X),J={error:Q.error,write:Q.write,command:this};this._getCommandAndAncestors().reverse().forEach(($)=>$.emit("beforeAllHelp",J)),this.emit("beforeHelp",J);let Z=this.helpInformation({error:Q.error});if(Y){if(Z=Y(Z),typeof Z!=="string"&&!Buffer.isBuffer(Z))throw Error("outputHelp callback must return a string or a Buffer")}if(Q.write(Z),this._getHelpOption()?.long)this.emit(this._getHelpOption().long);this.emit("afterHelp",J),this._getCommandAndAncestors().forEach(($)=>$.emit("afterAllHelp",J))}helpOption(X,Y){if(typeof X==="boolean"){if(X){if(this._helpOption===null)this._helpOption=void 0;if(this._defaultOptionGroup)this._initOptionGroup(this._getHelpOption())}else this._helpOption=null;return this}if(this._helpOption=this.createOption(X??"-h, --help",Y??"display help for command"),X||Y)this._initOptionGroup(this._helpOption);return this}_getHelpOption(){if(this._helpOption===void 0)this.helpOption(void 0,void 0);return this._helpOption}addHelpOption(X){return this._helpOption=X,this._initOptionGroup(X),this}help(X){this.outputHelp(X);let Y=Number(z.exitCode??0);if(Y===0&&X&&typeof X!=="function"&&X.error)Y=1;this._exit(Y,"commander.help","(outputHelp)")}addHelpText(X,Y){let Q=["beforeAll","before","after","afterAll"];if(!Q.includes(X))throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${Q.join("', '")}'`);let J=`${X}Help`;return this.on(J,(Z)=>{let $;if(typeof Y==="function")$=Y({error:Z.error,command:Z.command});else $=Y;if($)Z.write(`${$}
`)}),this}_outputHelpIfRequested(X){let Y=this._getHelpOption();if(Y&&X.find((J)=>Y.is(J)))this.outputHelp(),this._exit(0,"commander.helpDisplayed","(outputHelp)")}}function GX(X){return X.map((Y)=>{if(!Y.startsWith("--inspect"))return Y;let Q,J="127.0.0.1",Z="9229",$;if(($=Y.match(/^(--inspect(-brk)?)$/))!==null)Q=$[1];else if(($=Y.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(Q=$[1],/^\d+$/.test($[3]))Z=$[3];else J=$[3];else if(($=Y.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)Q=$[1],J=$[3],Z=$[4];if(Q&&Z!=="0")return`${Q}=${J}:${parseInt(Z)+1}`;return Y})}function i(){if(z.env.NO_COLOR||z.env.FORCE_COLOR==="0"||z.env.FORCE_COLOR==="false")return!1;if(z.env.FORCE_COLOR||z.env.CLICOLOR_FORCE!==void 0)return!0;return}$Y.Command=s;$Y.useColor=i});var LX=P((UY)=>{var{Argument:UX}=v(),{Command:n}=TX(),{CommanderError:GY,InvalidArgumentError:BX}=C(),{Help:TY}=l(),{Option:zX}=m();UY.program=new n;UY.createCommand=(X)=>new n(X);UY.createOption=(X,Y)=>new zX(X,Y);UY.createArgument=(X,Y)=>new UX(X,Y);UY.Command=n;UY.Option=zX;UY.Argument=UX;UY.Help=TY;UY.CommanderError=GY;UY.InvalidArgumentError=BX;UY.InvalidOptionArgumentError=BX});var KX=D(LX(),1),{program:sY,createCommand:nY,createArgument:aY,createOption:tY,CommanderError:oY,InvalidArgumentError:rY,InvalidOptionArgumentError:eY,Command:HX,Argument:X1,Option:Y1,Help:Q1}=KX.default;function R(){if(process.argv.includes("--hook"))return"hook";return process.stdin.isTTY===!1?"hook":"cli"}async function WX(){try{let X=await Bun.stdin.text(),Y=JSON.parse(X);if(!Y.tool_input||typeof Y.tool_input.command!=="string")throw Error("Invalid hook input: missing tool_input.command field");return Y}catch(X){if(X instanceof SyntaxError)throw Error(`Failed to parse hook input JSON: ${X.message}`);throw X}}function jX(X,Y){return{hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"allow",updatedInput:{...Y,command:`cat << 'OUTPUT_EOF'
${X}
OUTPUT_EOF`}}}}function a(){return{}}class H extends Error{exitCode;metadata;constructor(X,Y=1,Q){super(X);this.exitCode=Y;this.metadata=Q;this.name="CommandError",Error.captureStackTrace(this,H)}}function DY(X){let Y=X.message;if(process.stderr.isTTY)return`\x1B[31mError:\x1B[0m ${Y}`;return`Error: ${Y}`}function RX(X){let Y=X instanceof H,Q=Y?X.exitCode:1,J=Y?X.metadata:void 0;return{success:!1,output:"",errorOutput:X.message,exitCode:Q,metadata:J??null}}function VX(X,Y){if(Y==="hook")return RX(X);return DY(X)}function A(X){return RX(X)}var IX={INVALID_ARGUMENTS:(X)=>new H(`Invalid arguments: ${X}`,1),MISSING_REQUIRED_ARG:(X)=>new H(`Missing required argument: ${X}`,1),COMMAND_NOT_FOUND:(X)=>new H(`Command not found: ${X}`,127),PERMISSION_DENIED:(X)=>new H(`Permission denied: ${X}`,126),FILE_NOT_FOUND:(X)=>new H(`File not found: ${X}`,2),INVALID_STATE:(X)=>new H(`Invalid state: ${X}`,1),EXECUTION_FAILED:(X)=>new H(`Execution failed: ${X}`,1)};function u(X,Y){return{success:!0,output:X,errorOutput:null,exitCode:0,metadata:Y??null}}var MX=(X)=>{let Y=X.trim().split(/\s+/);if(Y[0]==="speck-echo"||Y[0]==="echo")Y.shift();return{message:Y.join(" ")}},DX=async(X)=>{try{if(!X.message)throw IX.MISSING_REQUIRED_ARG("message");let Y=X.message;return u(Y,{message:X.message})}catch(Y){return A(Y instanceof Error?Y:Error(String(Y)))}};var NX=async(X,Y)=>{try{let Q=await PX(),Z=["Speck Environment","================",`Speck Root: ${Q.speckRoot}`,`Repo Root: ${Q.repoRoot}`,`Mode: ${Q.mode}`,`Execution Mode: ${Y.mode}`,`Working Directory: ${Y.workingDirectory}`,`Interactive: ${Y.isInteractive}`].join(`
`);return u(Z,{speckRoot:Q.speckRoot,repoRoot:Q.repoRoot,configMode:Q.mode,executionMode:Y.mode,workingDirectory:Y.workingDirectory,isInteractive:Y.isInteractive})}catch(Q){return A(Q instanceof Error?Q:Error(String(Q)))}};import{existsSync as W,readdirSync as SX,readFileSync as t}from"fs";import{join as f}from"path";function PY(X){return{json:X.includes("--json"),requireTasks:X.includes("--require-tasks"),includeTasks:X.includes("--include-tasks"),pathsOnly:X.includes("--paths-only"),skipFeatureCheck:X.includes("--skip-feature-check"),skipPlanCheck:X.includes("--skip-plan-check"),help:X.includes("--help")||X.includes("-h"),includeFileContents:X.includes("--include-file-contents"),includeWorkflowMode:X.includes("--include-workflow-mode"),validateCodeQuality:X.includes("--validate-code-quality")}}function NY(){console.log(`Usage: check-prerequisites.ts [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json                   Output in JSON format
  --require-tasks          Require tasks.md to exist (for implementation phase)
  --include-tasks          Include tasks.md in AVAILABLE_DOCS list
  --paths-only             Only output path variables (no prerequisite validation)
  --skip-feature-check     Skip feature directory and plan.md validation (for /speck.specify)
  --skip-plan-check        Skip plan.md validation but check feature directory (for /speck.plan)
  --validate-code-quality  Validate TypeScript typecheck and ESLint (Constitution Principle IX)
  --include-file-contents  Include file contents in JSON output
  --include-workflow-mode  Include workflow mode in JSON output
  --help, -h               Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  bun .speck/scripts/check-prerequisites.ts --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  bun .speck/scripts/check-prerequisites.ts --json --require-tasks --include-tasks

  # Validate code quality before feature completion
  bun .speck/scripts/check-prerequisites.ts --validate-code-quality

  # Get feature paths only (no validation)
  bun .speck/scripts/check-prerequisites.ts --paths-only
`)}function SY(X,Y){if(Y){let Q={MODE:X.MODE,REPO_ROOT:X.REPO_ROOT,BRANCH:X.CURRENT_BRANCH,FEATURE_DIR:X.FEATURE_DIR,FEATURE_SPEC:X.FEATURE_SPEC,IMPL_PLAN:X.IMPL_PLAN,TASKS:X.TASKS};console.log(JSON.stringify(Q))}else console.log(`MODE: ${X.MODE}`),console.log(`REPO_ROOT: ${X.REPO_ROOT}`),console.log(`BRANCH: ${X.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${X.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${X.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${X.IMPL_PLAN}`),console.log(`TASKS: ${X.TASKS}`)}function FY(X){let Y=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--skip-plan-check","--help","-h","--include-file-contents","--include-workflow-mode","--validate-code-quality"];for(let Q of X)if(Q.startsWith("--")||Q.startsWith("-")){if(!Y.includes(Q))console.error(`ERROR: Unknown option '${Q}'. Use --help for usage information.`),process.exit(1)}}var FX={maxSingleFile:24576,maxTotalFiles:102400};function N(X,Y){if(!W(X))return"NOT_FOUND";try{let J=Bun.file(X).size;if(J>FX.maxSingleFile)return"TOO_LARGE";if(Y.value+J>FX.maxTotalFiles)return"TOO_LARGE";let Z=t(X,"utf-8");return Y.value+=J,Z}catch(Q){return"NOT_FOUND"}}async function AY(X){let{$:Y}=awaitPromise.resolve(globalThis.Bun),Q=await Y`bun run typecheck`.cwd(X).nothrow().quiet();if(Q.exitCode!==0)return{passed:!1,message:`\u274C TypeScript validation failed (exit code ${Q.exitCode})
${Q.stderr.toString()}`};let J=await Y`bun run lint`.cwd(X).nothrow().quiet();if(J.exitCode!==0){let Z=J.stdout.toString();return{passed:!1,message:`\u274C ESLint validation failed (exit code ${J.exitCode})
${Z}`}}return{passed:!0,message:"\u2705 Code quality validation passed (0 typecheck errors, 0 lint errors/warnings)"}}function EY(X,Y){let Q=f(X,"plan.md");if(W(Q))try{let $=t(Q,"utf-8").match(/\*\*Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if($&&$[1])return $[1]}catch{}let J=f(Y,".speck","memory","constitution.md");if(W(J))try{let $=t(J,"utf-8").match(/\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if($&&$[1])return $[1]}catch{}return"single-branch"}async function OX(X){if(!X.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: Direct invocation deprecated. Prerequisites are now auto-checked via PrePromptSubmit hook.\x1B[0m
`);FY(X);let Y=PY(X);if(Y.help)return NY(),0;let Q=await EX(),J=Q.HAS_GIT==="true";if(!Y.skipFeatureCheck){if(!await AX(Q.CURRENT_BRANCH,J,Q.REPO_ROOT))return 1}if(Y.pathsOnly||Y.skipFeatureCheck)return SY(Q,Y.json),0;if(!W(Q.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${Q.FEATURE_DIR}`),console.error("Run /speck.specify first to create the feature structure."),1;if(!Y.skipPlanCheck&&!W(Q.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${Q.FEATURE_DIR}`),console.error("Run /speck.plan first to create the implementation plan."),1;if(Y.requireTasks&&!W(Q.TASKS))return console.error(`ERROR: tasks.md not found in ${Q.FEATURE_DIR}`),console.error("Run /speck.tasks first to create the task list."),1;let Z=[];if(W(Q.RESEARCH))Z.push("research.md");if(W(Q.DATA_MODEL))Z.push("data-model.md");if(W(Q.CONTRACTS_DIR))try{if(SX(Q.CONTRACTS_DIR).length>0)Z.push("contracts/")}catch{}if(W(Q.QUICKSTART))Z.push("quickstart.md");if(Y.includeTasks&&W(Q.TASKS))Z.push("tasks.md");let $;if(Y.includeFileContents){$={};let _={value:0};$["tasks.md"]=N(Q.TASKS,_),$["plan.md"]=N(Q.IMPL_PLAN,_),$["spec.md"]=N(Q.FEATURE_SPEC,_);let B=f(Q.REPO_ROOT,".speck","memory","constitution.md");$["constitution.md"]=N(B,_),$["data-model.md"]=N(Q.DATA_MODEL,_),$["research.md"]=N(Q.RESEARCH,_);let G=f(Q.FEATURE_DIR,"checklists");if(W(G))try{let T=SX(G).filter((U)=>U.endsWith(".md"));for(let U of T){let j=f(G,U);$[`checklists/${U}`]=N(j,_)}}catch{}}let q;if(Y.includeWorkflowMode)q=EY(Q.FEATURE_DIR,Q.REPO_ROOT);if(Y.validateCodeQuality){let _=await AY(Q.REPO_ROOT);if(!_.passed)return console.error(`
`+_.message),console.error(`
Constitution Principle IX requires zero typecheck errors and zero lint errors/warnings.`),console.error(`Fix all issues before marking the feature complete.
`),1;if(!Y.json)console.log(`
`+_.message+`
`)}if(Y.json){let _={MODE:Q.MODE,FEATURE_DIR:Q.FEATURE_DIR,AVAILABLE_DOCS:Z,...$&&{FILE_CONTENTS:$},...q&&{WORKFLOW_MODE:q}};console.log(JSON.stringify(_))}else if(console.log(`FEATURE_DIR:${Q.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:"),console.log(x(Q.RESEARCH,"research.md")),console.log(x(Q.DATA_MODEL,"data-model.md")),console.log(wX(Q.CONTRACTS_DIR,"contracts/")),console.log(x(Q.QUICKSTART,"quickstart.md")),Y.includeTasks)console.log(x(Q.TASKS,"tasks.md"));return 0}var wY=async()=>{return(await import("./branch-command-xmqtg052.js")).main},OY=async()=>{return(await import("./env-command-d62v6w5f.js")).main},kY=async()=>{return(await import("./create-new-feature-ge2f0p7p.js")).main},bY=async()=>{return(await import("./setup-plan-dgms79yg.js")).main},yY=async()=>{return(await import("./link-repo-4j4x71db.js")).main},CY=async()=>{return(await import("./update-agent-context-8hxmk24f.js")).main},V={echo:{handler:DX,parseArgs:MX,description:"Echo back the provided message",version:"1.0.0"},env:{handler:NX,lazyMain:OY,description:"Show Speck environment and configuration info",version:"1.0.0"},branch:{lazyMain:wY,description:"Manage stacked feature branches",version:"1.0.0"},"check-prerequisites":{main:OX,parseArgs:(X)=>{let Y=X.trim().split(/\s+/);if(Y[0]==="speck-check-prerequisites"||Y[0]==="check-prerequisites")Y.shift();return Y},description:"Validate feature directory structure and prerequisites",version:"1.0.0"},"create-new-feature":{lazyMain:kY,description:"Create new feature specification directory",version:"1.0.0"},"setup-plan":{lazyMain:bY,description:"Initialize planning workflow",version:"1.0.0"},"link-repo":{lazyMain:yY,description:"Link repository to multi-repo speck root",version:"1.0.0"},"update-agent-context":{lazyMain:CY,description:"Update agent-specific context files with technology stack",version:"1.0.0"}};import{appendFile as xY}from"fs/promises";var fY="/private/tmp/.claude-hook-test/speck-hook-log.txt",E=async(X)=>{await xY(fY,`[${new Date().toISOString()}] ${X}
`)},I=new HX;I.name("speck").description("Speck unified CLI for feature specification workflow").version("0.1.0");var kX=V.echo;I.command("echo <message...>").description(kX.description).action(async(X)=>{let Y=Array.isArray(X)?X.join(" "):String(X),Q={mode:R(),rawCommand:`echo ${Y}`,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},J=await kX.handler({message:Y},Q);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)});var o=V.env;if(!o)throw Error("env command not found in registry");I.command("env").description(o.description).action(async()=>{let X={mode:R(),rawCommand:"env",workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},Y=await o.handler({},X);if(Y.success)console.log(Y.output);else console.error(Y.errorOutput),process.exit(Y.exitCode)});var S=V.branch;if(!S)throw Error("branch command not found in registry");I.command("branch [args...]").description(S.description).allowUnknownOption().action(async(X)=>{let Y=Array.isArray(X)?X:[String(X)];if(S.lazyMain){let J=await(await S.lazyMain())(Y);process.exit(J)}else if(S.handler){let Q=`branch ${Y.join(" ")}`,J={mode:R(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},Z=S.parseArgs(Q),$=await S.handler(Z,J);if($.success)console.log($.output);else console.error($.errorOutput),process.exit($.exitCode)}});var w=V["check-prerequisites"];I.command("check-prerequisites [args...]").description(w.description).allowUnknownOption().action(async(X)=>{let Y=Array.isArray(X)?X:[String(X)];if(w.main){let Q=await w.main(Y);process.exit(Q)}else if(w.handler){let Q=`check-prerequisites ${Y.join(" ")}`,J={mode:R(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},Z=w.parseArgs(Q),$=await w.handler(Z,J);if($.success)console.log($.output);else console.error($.errorOutput),process.exit($.exitCode)}});var O=V["create-new-feature"];I.command("create-new-feature [args...]").description(O.description).allowUnknownOption().action(async(X)=>{let Y=Array.isArray(X)?X:[String(X)];if(O.lazyMain){let J=await(await O.lazyMain())(Y);process.exit(J)}else if(O.handler){let Q=`create-new-feature ${Y.join(" ")}`,J={mode:R(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},Z=O.parseArgs(Q),$=await O.handler(Z,J);if($.success)console.log($.output);else console.error($.errorOutput),process.exit($.exitCode)}});var k=V["setup-plan"];I.command("setup-plan [args...]").description(k.description).allowUnknownOption().action(async(X)=>{let Y=Array.isArray(X)?X:[String(X)];if(k.lazyMain){let J=await(await k.lazyMain())(Y);process.exit(J)}else if(k.handler){let Q=`setup-plan ${Y.join(" ")}`,J={mode:R(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},Z=k.parseArgs(Q),$=await k.handler(Z,J);if($.success)console.log($.output);else console.error($.errorOutput),process.exit($.exitCode)}});var b=V["link-repo"];I.command("link-repo [args...]").description(b.description).allowUnknownOption().action(async(X)=>{let Y=Array.isArray(X)?X:[String(X)];if(b.lazyMain){let J=await(await b.lazyMain())(Y);process.exit(J)}else if(b.handler){let Q=`link-repo ${Y.join(" ")}`,J={mode:R(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},Z=b.parseArgs(Q),$=await b.handler(Z,J);if($.success)console.log($.output);else console.error($.errorOutput),process.exit($.exitCode)}});var y=V["update-agent-context"];I.command("update-agent-context [args...]").description(y.description).allowUnknownOption().action(async(X)=>{let Y=Array.isArray(X)?X:[String(X)];if(y.lazyMain){let J=await(await y.lazyMain())(Y);process.exit(J)}else if(y.handler){let Q=`update-agent-context ${Y.join(" ")}`,J={mode:R(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},Z=y.parseArgs(Q),$=await y.handler(Z,J);if($.success)console.log($.output);else console.error($.errorOutput),process.exit($.exitCode)}});async function vY(){if(R()==="hook")await hY();else await uY()}async function hY(){try{let X=await WX(),{command:Y}=X.tool_input;if(await E(`Speck hook called - Command: ${Y}`),!Y.match(/^speck-/)){await E(`Skip (not speck-*): ${Y}`),console.log(JSON.stringify(a()));return}await E(`Intercepting speck command: ${Y}`);let Q=Y.match(/^speck-(.+?)(?:\s+(.*))?$/);if(!Q)console.error("Failed to parse command:",Y),process.exit(1);let[,J,Z=""]=Q,$=Z.split(/\s+/).filter((L)=>L.length>0),q=J?V[J]:void 0;if(!q){await E(`Unknown command: ${J}`),console.error(`Unknown command: ${J}`),console.log(JSON.stringify(a()));return}let{log:_,error:B}=console,G="",T="";console.log=(...L)=>{G+=L.join(" ")+`
`},console.error=(...L)=>{T+=L.join(" ")+`
`};try{if(q.main)await q.main($);else if(q.lazyMain)await(await q.lazyMain())($);else if(q.handler){let L={mode:"hook",rawCommand:Y,workingDirectory:process.cwd(),isInteractive:!1},g=q.parseArgs?q.parseArgs(Y):{},F=await q.handler(g,L);if(F.success&&F.output)G+=F.output;if(!F.success&&F.errorOutput)T+=F.errorOutput}else throw Error(`Command ${J} has no main, lazyMain, or handler`)}catch(L){let g=A(L instanceof Error?L:Error(String(L)));T+=g.errorOutput||""}console.log=_,console.error=B;let U=G.trim()||T.trim()||"",j=jX(U,X.tool_input);await E(`Returning result: ${U.substring(0,100)}`),console.log(JSON.stringify(j))}catch(X){await E(`Hook error: ${X instanceof Error?X.message:String(X)}`),console.error("Hook error:",X instanceof Error?X.message:String(X)),console.log("{}"),process.exit(1)}}async function uY(){try{await I.parseAsync(process.argv)}catch(X){let Y=VX(X instanceof Error?X:Error(String(X)),"cli");if(typeof Y==="string")console.error(Y);let Q=X instanceof H?X.exitCode:1;process.exit(Q)}}if(import.meta.main)vY();
