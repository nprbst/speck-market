#!/usr/bin/env bun
// @bun
var SX=Object.create;var{getPrototypeOf:FX,defineProperty:Q6,getOwnPropertyNames:NX}=Object;var vX=Object.prototype.hasOwnProperty;var _6=(q,X,Q)=>{Q=q!=null?SX(FX(q)):{};let _=X||!q||!q.__esModule?Q6(Q,"default",{value:q,enumerable:!0}):Q;for(let $ of NX(q))if(!vX.call(_,$))Q6(_,$,{get:()=>q[$],enumerable:!0});return _};var Pq=(q,X)=>()=>(X||q((X={exports:{}}).exports,X),X.exports);var wq=(q,X)=>{for(var Q in X)Q6(q,Q,{get:X[Q],enumerable:!0,configurable:!0,set:(_)=>X[Q]=()=>_})};var Z=(q,X)=>()=>(q&&(X=q(q=0)),X);var kq=import.meta.require;var A3=Pq((IX)=>{class $6 extends Error{constructor(q,X,Q){super(Q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=X,this.exitCode=q,this.nestedError=void 0}}class i6 extends $6{constructor(q){super(1,"commander.invalidArgument",q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}IX.CommanderError=$6;IX.InvalidArgumentError=i6});var f3=Pq((CX)=>{var{InvalidArgumentError:PX}=A3();class n6{constructor(q,X){switch(this.description=X||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,q[0]){case"<":this.required=!0,this._name=q.slice(1,-1);break;case"[":this.required=!1,this._name=q.slice(1,-1);break;default:this.required=!0,this._name=q;break}if(this._name.endsWith("..."))this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_collectValue(q,X){if(X===this.defaultValue||!Array.isArray(X))return[q];return X.push(q),X}default(q,X){return this.defaultValue=q,this.defaultValueDescription=X,this}argParser(q){return this.parseArg=q,this}choices(q){return this.argChoices=q.slice(),this.parseArg=(X,Q)=>{if(!this.argChoices.includes(X))throw new PX(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue(X,Q);return X},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function kX(q){let X=q.name()+(q.variadic===!0?"...":"");return q.required?"<"+X+">":"["+X+"]"}CX.Argument=n6;CX.humanReadableArgName=kX});var J6=Pq((xX)=>{var{humanReadableArgName:bX}=f3();class s6{constructor(){this.helpWidth=void 0,this.minWidthToWrap=40,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}prepareContext(q){this.helpWidth=this.helpWidth??q.helpWidth??80}visibleCommands(q){let X=q.commands.filter((_)=>!_._hidden),Q=q._getHelpCommand();if(Q&&!Q._hidden)X.push(Q);if(this.sortSubcommands)X.sort((_,$)=>{return _.name().localeCompare($.name())});return X}compareOptions(q,X){let Q=(_)=>{return _.short?_.short.replace(/^-/,""):_.long.replace(/^--/,"")};return Q(q).localeCompare(Q(X))}visibleOptions(q){let X=q.options.filter((_)=>!_.hidden),Q=q._getHelpOption();if(Q&&!Q.hidden){let _=Q.short&&q._findOption(Q.short),$=Q.long&&q._findOption(Q.long);if(!_&&!$)X.push(Q);else if(Q.long&&!$)X.push(q.createOption(Q.long,Q.description));else if(Q.short&&!_)X.push(q.createOption(Q.short,Q.description))}if(this.sortOptions)X.sort(this.compareOptions);return X}visibleGlobalOptions(q){if(!this.showGlobalOptions)return[];let X=[];for(let Q=q.parent;Q;Q=Q.parent){let _=Q.options.filter(($)=>!$.hidden);X.push(..._)}if(this.sortOptions)X.sort(this.compareOptions);return X}visibleArguments(q){if(q._argsDescription)q.registeredArguments.forEach((X)=>{X.description=X.description||q._argsDescription[X.name()]||""});if(q.registeredArguments.find((X)=>X.description))return q.registeredArguments;return[]}subcommandTerm(q){let X=q.registeredArguments.map((Q)=>bX(Q)).join(" ");return q._name+(q._aliases[0]?"|"+q._aliases[0]:"")+(q.options.length?" [options]":"")+(X?" "+X:"")}optionTerm(q){return q.flags}argumentTerm(q){return q.name()}longestSubcommandTermLength(q,X){return X.visibleCommands(q).reduce((Q,_)=>{return Math.max(Q,this.displayWidth(X.styleSubcommandTerm(X.subcommandTerm(_))))},0)}longestOptionTermLength(q,X){return X.visibleOptions(q).reduce((Q,_)=>{return Math.max(Q,this.displayWidth(X.styleOptionTerm(X.optionTerm(_))))},0)}longestGlobalOptionTermLength(q,X){return X.visibleGlobalOptions(q).reduce((Q,_)=>{return Math.max(Q,this.displayWidth(X.styleOptionTerm(X.optionTerm(_))))},0)}longestArgumentTermLength(q,X){return X.visibleArguments(q).reduce((Q,_)=>{return Math.max(Q,this.displayWidth(X.styleArgumentTerm(X.argumentTerm(_))))},0)}commandUsage(q){let X=q._name;if(q._aliases[0])X=X+"|"+q._aliases[0];let Q="";for(let _=q.parent;_;_=_.parent)Q=_.name()+" "+Q;return Q+X+" "+q.usage()}commandDescription(q){return q.description()}subcommandDescription(q){return q.summary()||q.description()}optionDescription(q){let X=[];if(q.argChoices)X.push(`choices: ${q.argChoices.map((Q)=>JSON.stringify(Q)).join(", ")}`);if(q.defaultValue!==void 0){if(q.required||q.optional||q.isBoolean()&&typeof q.defaultValue==="boolean")X.push(`default: ${q.defaultValueDescription||JSON.stringify(q.defaultValue)}`)}if(q.presetArg!==void 0&&q.optional)X.push(`preset: ${JSON.stringify(q.presetArg)}`);if(q.envVar!==void 0)X.push(`env: ${q.envVar}`);if(X.length>0){let Q=`(${X.join(", ")})`;if(q.description)return`${q.description} ${Q}`;return Q}return q.description}argumentDescription(q){let X=[];if(q.argChoices)X.push(`choices: ${q.argChoices.map((Q)=>JSON.stringify(Q)).join(", ")}`);if(q.defaultValue!==void 0)X.push(`default: ${q.defaultValueDescription||JSON.stringify(q.defaultValue)}`);if(X.length>0){let Q=`(${X.join(", ")})`;if(q.description)return`${q.description} ${Q}`;return Q}return q.description}formatItemList(q,X,Q){if(X.length===0)return[];return[Q.styleTitle(q),...X,""]}groupItems(q,X,Q){let _=new Map;return q.forEach(($)=>{let J=Q($);if(!_.has(J))_.set(J,[])}),X.forEach(($)=>{let J=Q($);if(!_.has(J))_.set(J,[]);_.get(J).push($)}),_}formatHelp(q,X){let Q=X.padWidth(q,X),_=X.helpWidth??80;function $(z,U){return X.formatItem(z,Q,U,X)}let J=[`${X.styleTitle("Usage:")} ${X.styleUsage(X.commandUsage(q))}`,""],Y=X.commandDescription(q);if(Y.length>0)J=J.concat([X.boxWrap(X.styleCommandDescription(Y),_),""]);let H=X.visibleArguments(q).map((z)=>{return $(X.styleArgumentTerm(X.argumentTerm(z)),X.styleArgumentDescription(X.argumentDescription(z)))});if(J=J.concat(this.formatItemList("Arguments:",H,X)),this.groupItems(q.options,X.visibleOptions(q),(z)=>z.helpGroupHeading??"Options:").forEach((z,U)=>{let L=z.map((A)=>{return $(X.styleOptionTerm(X.optionTerm(A)),X.styleOptionDescription(X.optionDescription(A)))});J=J.concat(this.formatItemList(U,L,X))}),X.showGlobalOptions){let z=X.visibleGlobalOptions(q).map((U)=>{return $(X.styleOptionTerm(X.optionTerm(U)),X.styleOptionDescription(X.optionDescription(U)))});J=J.concat(this.formatItemList("Global Options:",z,X))}return this.groupItems(q.commands,X.visibleCommands(q),(z)=>z.helpGroup()||"Commands:").forEach((z,U)=>{let L=z.map((A)=>{return $(X.styleSubcommandTerm(X.subcommandTerm(A)),X.styleSubcommandDescription(X.subcommandDescription(A)))});J=J.concat(this.formatItemList(U,L,X))}),J.join(`
`)}displayWidth(q){return o6(q).length}styleTitle(q){return q}styleUsage(q){return q.split(" ").map((X)=>{if(X==="[options]")return this.styleOptionText(X);if(X==="[command]")return this.styleSubcommandText(X);if(X[0]==="["||X[0]==="<")return this.styleArgumentText(X);return this.styleCommandText(X)}).join(" ")}styleCommandDescription(q){return this.styleDescriptionText(q)}styleOptionDescription(q){return this.styleDescriptionText(q)}styleSubcommandDescription(q){return this.styleDescriptionText(q)}styleArgumentDescription(q){return this.styleDescriptionText(q)}styleDescriptionText(q){return q}styleOptionTerm(q){return this.styleOptionText(q)}styleSubcommandTerm(q){return q.split(" ").map((X)=>{if(X==="[options]")return this.styleOptionText(X);if(X[0]==="["||X[0]==="<")return this.styleArgumentText(X);return this.styleSubcommandText(X)}).join(" ")}styleArgumentTerm(q){return this.styleArgumentText(q)}styleOptionText(q){return q}styleArgumentText(q){return q}styleSubcommandText(q){return q}styleCommandText(q){return q}padWidth(q,X){return Math.max(X.longestOptionTermLength(q,X),X.longestGlobalOptionTermLength(q,X),X.longestSubcommandTermLength(q,X),X.longestArgumentTermLength(q,X))}preformatted(q){return/\n[^\S\r\n]/.test(q)}formatItem(q,X,Q,_){let J=" ".repeat(2);if(!Q)return J+q;let Y=q.padEnd(X+q.length-_.displayWidth(q)),H=2,G=(this.helpWidth??80)-X-H-2,z;if(G<this.minWidthToWrap||_.preformatted(Q))z=Q;else z=_.boxWrap(Q,G).replace(/\n/g,`
`+" ".repeat(X+H));return J+Y+" ".repeat(H)+z.replace(/\n/g,`
${J}`)}boxWrap(q,X){if(X<this.minWidthToWrap)return q;let Q=q.split(/\r\n|\n/),_=/[\s]*[^\s]+/g,$=[];return Q.forEach((J)=>{let Y=J.match(_);if(Y===null){$.push("");return}let H=[Y.shift()],W=this.displayWidth(H[0]);Y.forEach((G)=>{let z=this.displayWidth(G);if(W+z<=X){H.push(G),W+=z;return}$.push(H.join(""));let U=G.trimStart();H=[U],W=this.displayWidth(U)}),$.push(H.join(""))}),$.join(`
`)}}function o6(q){let X=/\x1b\[\d*(;\d*)*m/g;return q.replace(X,"")}xX.Help=s6;xX.stripColor=o6});var Y6=Pq((uX)=>{var{InvalidArgumentError:gX}=A3();class a6{constructor(q,X){this.flags=q,this.description=X||"",this.required=q.includes("<"),this.optional=q.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(q),this.mandatory=!1;let Q=lX(q);if(this.short=Q.shortFlag,this.long=Q.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0,this.helpGroupHeading=void 0}default(q,X){return this.defaultValue=q,this.defaultValueDescription=X,this}preset(q){return this.presetArg=q,this}conflicts(q){return this.conflictsWith=this.conflictsWith.concat(q),this}implies(q){let X=q;if(typeof q==="string")X={[q]:!0};return this.implied=Object.assign(this.implied||{},X),this}env(q){return this.envVar=q,this}argParser(q){return this.parseArg=q,this}makeOptionMandatory(q=!0){return this.mandatory=!!q,this}hideHelp(q=!0){return this.hidden=!!q,this}_collectValue(q,X){if(X===this.defaultValue||!Array.isArray(X))return[q];return X.push(q),X}choices(q){return this.argChoices=q.slice(),this.parseArg=(X,Q)=>{if(!this.argChoices.includes(X))throw new gX(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue(X,Q);return X},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){if(this.negate)return r6(this.name().replace(/^no-/,""));return r6(this.name())}helpGroup(q){return this.helpGroupHeading=q,this}is(q){return this.short===q||this.long===q}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class t6{constructor(q){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,q.forEach((X)=>{if(X.negate)this.negativeOptions.set(X.attributeName(),X);else this.positiveOptions.set(X.attributeName(),X)}),this.negativeOptions.forEach((X,Q)=>{if(this.positiveOptions.has(Q))this.dualOptions.add(Q)})}valueFromOption(q,X){let Q=X.attributeName();if(!this.dualOptions.has(Q))return!0;let _=this.negativeOptions.get(Q).presetArg,$=_!==void 0?_:!1;return X.negate===($===q)}}function r6(q){return q.split("-").reduce((X,Q)=>{return X+Q[0].toUpperCase()+Q.slice(1)})}function lX(q){let X,Q,_=/^-[^-]$/,$=/^--[^-]/,J=q.split(/[ |,]+/).concat("guard");if(_.test(J[0]))X=J.shift();if($.test(J[0]))Q=J.shift();if(!X&&_.test(J[0]))X=J.shift();if(!X&&$.test(J[0]))X=Q,Q=J.shift();if(J[0].startsWith("-")){let Y=J[0],H=`option creation failed due to '${Y}' in option flags '${q}'`;if(/^-[^-][^-]/.test(Y))throw Error(`${H}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);if(_.test(Y))throw Error(`${H}
- too many short flags`);if($.test(Y))throw Error(`${H}
- too many long flags`);throw Error(`${H}
- unrecognised flag format`)}if(X===void 0&&Q===void 0)throw Error(`option creation failed due to no flags found in '${q}'.`);return{shortFlag:X,longFlag:Q}}uX.Option=a6;uX.DualOptions=t6});var e6=Pq((iX)=>{function cX(q,X){if(Math.abs(q.length-X.length)>3)return Math.max(q.length,X.length);let Q=[];for(let _=0;_<=q.length;_++)Q[_]=[_];for(let _=0;_<=X.length;_++)Q[0][_]=_;for(let _=1;_<=X.length;_++)for(let $=1;$<=q.length;$++){let J=1;if(q[$-1]===X[_-1])J=0;else J=1;if(Q[$][_]=Math.min(Q[$-1][_]+1,Q[$][_-1]+1,Q[$-1][_-1]+J),$>1&&_>1&&q[$-1]===X[_-2]&&q[$-2]===X[_-1])Q[$][_]=Math.min(Q[$][_],Q[$-2][_-2]+1)}return Q[q.length][X.length]}function pX(q,X){if(!X||X.length===0)return"";X=Array.from(new Set(X));let Q=q.startsWith("--");if(Q)q=q.slice(2),X=X.map((Y)=>Y.slice(2));let _=[],$=3,J=0.4;if(X.forEach((Y)=>{if(Y.length<=1)return;let H=cX(q,Y),W=Math.max(q.length,Y.length);if((W-H)/W>J){if(H<$)$=H,_=[Y];else if(H===$)_.push(Y)}}),_.sort((Y,H)=>Y.localeCompare(H)),Q)_=_.map((Y)=>`--${Y}`);if(_.length>1)return`
(Did you mean one of ${_.join(", ")}?)`;if(_.length===1)return`
(Did you mean ${_[0]}?)`;return""}iX.suggestSimilar=pX});var _8=Pq((q1)=>{var sX=kq("events").EventEmitter,H6=kq("child_process"),Mq=kq("path"),Z3=kq("fs"),T=kq("process"),{Argument:oX,humanReadableArgName:rX}=f3(),{CommanderError:W6}=A3(),{Help:aX,stripColor:tX}=J6(),{Option:q8,DualOptions:eX}=Y6(),{suggestSimilar:X8}=e6();class z6 extends sX{constructor(q){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!1,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=q||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._savedState=null,this._outputConfiguration={writeOut:(X)=>T.stdout.write(X),writeErr:(X)=>T.stderr.write(X),outputError:(X,Q)=>Q(X),getOutHelpWidth:()=>T.stdout.isTTY?T.stdout.columns:void 0,getErrHelpWidth:()=>T.stderr.isTTY?T.stderr.columns:void 0,getOutHasColors:()=>G6()??(T.stdout.isTTY&&T.stdout.hasColors?.()),getErrHasColors:()=>G6()??(T.stderr.isTTY&&T.stderr.hasColors?.()),stripColor:(X)=>tX(X)},this._hidden=!1,this._helpOption=void 0,this._addImplicitHelpCommand=void 0,this._helpCommand=void 0,this._helpConfiguration={},this._helpGroupHeading=void 0,this._defaultCommandGroup=void 0,this._defaultOptionGroup=void 0}copyInheritedSettings(q){return this._outputConfiguration=q._outputConfiguration,this._helpOption=q._helpOption,this._helpCommand=q._helpCommand,this._helpConfiguration=q._helpConfiguration,this._exitCallback=q._exitCallback,this._storeOptionsAsProperties=q._storeOptionsAsProperties,this._combineFlagAndOptionalValue=q._combineFlagAndOptionalValue,this._allowExcessArguments=q._allowExcessArguments,this._enablePositionalOptions=q._enablePositionalOptions,this._showHelpAfterError=q._showHelpAfterError,this._showSuggestionAfterError=q._showSuggestionAfterError,this}_getCommandAndAncestors(){let q=[];for(let X=this;X;X=X.parent)q.push(X);return q}command(q,X,Q){let _=X,$=Q;if(typeof _==="object"&&_!==null)$=_,_=null;$=$||{};let[,J,Y]=q.match(/([^ ]+) *(.*)/),H=this.createCommand(J);if(_)H.description(_),H._executableHandler=!0;if($.isDefault)this._defaultCommandName=H._name;if(H._hidden=!!($.noHelp||$.hidden),H._executableFile=$.executableFile||null,Y)H.arguments(Y);if(this._registerCommand(H),H.parent=this,H.copyInheritedSettings(this),_)return this;return H}createCommand(q){return new z6(q)}createHelp(){return Object.assign(new aX,this.configureHelp())}configureHelp(q){if(q===void 0)return this._helpConfiguration;return this._helpConfiguration=q,this}configureOutput(q){if(q===void 0)return this._outputConfiguration;return this._outputConfiguration={...this._outputConfiguration,...q},this}showHelpAfterError(q=!0){if(typeof q!=="string")q=!!q;return this._showHelpAfterError=q,this}showSuggestionAfterError(q=!0){return this._showSuggestionAfterError=!!q,this}addCommand(q,X){if(!q._name)throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if(X=X||{},X.isDefault)this._defaultCommandName=q._name;if(X.noHelp||X.hidden)q._hidden=!0;return this._registerCommand(q),q.parent=this,q._checkForBrokenPassThrough(),this}createArgument(q,X){return new oX(q,X)}argument(q,X,Q,_){let $=this.createArgument(q,X);if(typeof Q==="function")$.default(_).argParser(Q);else $.default(Q);return this.addArgument($),this}arguments(q){return q.trim().split(/ +/).forEach((X)=>{this.argument(X)}),this}addArgument(q){let X=this.registeredArguments.slice(-1)[0];if(X?.variadic)throw Error(`only the last argument can be variadic '${X.name()}'`);if(q.required&&q.defaultValue!==void 0&&q.parseArg===void 0)throw Error(`a default value for a required argument is never used: '${q.name()}'`);return this.registeredArguments.push(q),this}helpCommand(q,X){if(typeof q==="boolean"){if(this._addImplicitHelpCommand=q,q&&this._defaultCommandGroup)this._initCommandGroup(this._getHelpCommand());return this}let Q=q??"help [command]",[,_,$]=Q.match(/([^ ]+) *(.*)/),J=X??"display help for command",Y=this.createCommand(_);if(Y.helpOption(!1),$)Y.arguments($);if(J)Y.description(J);if(this._addImplicitHelpCommand=!0,this._helpCommand=Y,q||X)this._initCommandGroup(Y);return this}addHelpCommand(q,X){if(typeof q!=="object")return this.helpCommand(q,X),this;return this._addImplicitHelpCommand=!0,this._helpCommand=q,this._initCommandGroup(q),this}_getHelpCommand(){if(this._addImplicitHelpCommand??(this.commands.length&&!this._actionHandler&&!this._findCommand("help"))){if(this._helpCommand===void 0)this.helpCommand(void 0,void 0);return this._helpCommand}return null}hook(q,X){let Q=["preSubcommand","preAction","postAction"];if(!Q.includes(q))throw Error(`Unexpected value for event passed to hook : '${q}'.
Expecting one of '${Q.join("', '")}'`);if(this._lifeCycleHooks[q])this._lifeCycleHooks[q].push(X);else this._lifeCycleHooks[q]=[X];return this}exitOverride(q){if(q)this._exitCallback=q;else this._exitCallback=(X)=>{if(X.code!=="commander.executeSubCommandAsync")throw X};return this}_exit(q,X,Q){if(this._exitCallback)this._exitCallback(new W6(q,X,Q));T.exit(q)}action(q){let X=(Q)=>{let _=this.registeredArguments.length,$=Q.slice(0,_);if(this._storeOptionsAsProperties)$[_]=this;else $[_]=this.opts();return $.push(this),q.apply(this,$)};return this._actionHandler=X,this}createOption(q,X){return new q8(q,X)}_callParseArg(q,X,Q,_){try{return q.parseArg(X,Q)}catch($){if($.code==="commander.invalidArgument"){let J=`${_} ${$.message}`;this.error(J,{exitCode:$.exitCode,code:$.code})}throw $}}_registerOption(q){let X=q.short&&this._findOption(q.short)||q.long&&this._findOption(q.long);if(X){let Q=q.long&&this._findOption(q.long)?q.long:q.short;throw Error(`Cannot add option '${q.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${Q}'
-  already used by option '${X.flags}'`)}this._initOptionGroup(q),this.options.push(q)}_registerCommand(q){let X=(_)=>{return[_.name()].concat(_.aliases())},Q=X(q).find((_)=>this._findCommand(_));if(Q){let _=X(this._findCommand(Q)).join("|"),$=X(q).join("|");throw Error(`cannot add command '${$}' as already have command '${_}'`)}this._initCommandGroup(q),this.commands.push(q)}addOption(q){this._registerOption(q);let X=q.name(),Q=q.attributeName();if(q.negate){let $=q.long.replace(/^--no-/,"--");if(!this._findOption($))this.setOptionValueWithSource(Q,q.defaultValue===void 0?!0:q.defaultValue,"default")}else if(q.defaultValue!==void 0)this.setOptionValueWithSource(Q,q.defaultValue,"default");let _=($,J,Y)=>{if($==null&&q.presetArg!==void 0)$=q.presetArg;let H=this.getOptionValue(Q);if($!==null&&q.parseArg)$=this._callParseArg(q,$,H,J);else if($!==null&&q.variadic)$=q._collectValue($,H);if($==null)if(q.negate)$=!1;else if(q.isBoolean()||q.optional)$=!0;else $="";this.setOptionValueWithSource(Q,$,Y)};if(this.on("option:"+X,($)=>{let J=`error: option '${q.flags}' argument '${$}' is invalid.`;_($,J,"cli")}),q.envVar)this.on("optionEnv:"+X,($)=>{let J=`error: option '${q.flags}' value '${$}' from env '${q.envVar}' is invalid.`;_($,J,"env")});return this}_optionEx(q,X,Q,_,$){if(typeof X==="object"&&X instanceof q8)throw Error("To add an Option object use addOption() instead of option() or requiredOption()");let J=this.createOption(X,Q);if(J.makeOptionMandatory(!!q.mandatory),typeof _==="function")J.default($).argParser(_);else if(_ instanceof RegExp){let Y=_;_=(H,W)=>{let G=Y.exec(H);return G?G[0]:W},J.default($).argParser(_)}else J.default(_);return this.addOption(J)}option(q,X,Q,_){return this._optionEx({},q,X,Q,_)}requiredOption(q,X,Q,_){return this._optionEx({mandatory:!0},q,X,Q,_)}combineFlagAndOptionalValue(q=!0){return this._combineFlagAndOptionalValue=!!q,this}allowUnknownOption(q=!0){return this._allowUnknownOption=!!q,this}allowExcessArguments(q=!0){return this._allowExcessArguments=!!q,this}enablePositionalOptions(q=!0){return this._enablePositionalOptions=!!q,this}passThroughOptions(q=!0){return this._passThroughOptions=!!q,this._checkForBrokenPassThrough(),this}_checkForBrokenPassThrough(){if(this.parent&&this._passThroughOptions&&!this.parent._enablePositionalOptions)throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)}storeOptionsAsProperties(q=!0){if(this.options.length)throw Error("call .storeOptionsAsProperties() before adding options");if(Object.keys(this._optionValues).length)throw Error("call .storeOptionsAsProperties() before setting option values");return this._storeOptionsAsProperties=!!q,this}getOptionValue(q){if(this._storeOptionsAsProperties)return this[q];return this._optionValues[q]}setOptionValue(q,X){return this.setOptionValueWithSource(q,X,void 0)}setOptionValueWithSource(q,X,Q){if(this._storeOptionsAsProperties)this[q]=X;else this._optionValues[q]=X;return this._optionValueSources[q]=Q,this}getOptionValueSource(q){return this._optionValueSources[q]}getOptionValueSourceWithGlobals(q){let X;return this._getCommandAndAncestors().forEach((Q)=>{if(Q.getOptionValueSource(q)!==void 0)X=Q.getOptionValueSource(q)}),X}_prepareUserArgs(q,X){if(q!==void 0&&!Array.isArray(q))throw Error("first parameter to parse must be array or undefined");if(X=X||{},q===void 0&&X.from===void 0){if(T.versions?.electron)X.from="electron";let _=T.execArgv??[];if(_.includes("-e")||_.includes("--eval")||_.includes("-p")||_.includes("--print"))X.from="eval"}if(q===void 0)q=T.argv;this.rawArgs=q.slice();let Q;switch(X.from){case void 0:case"node":this._scriptPath=q[1],Q=q.slice(2);break;case"electron":if(T.defaultApp)this._scriptPath=q[1],Q=q.slice(2);else Q=q.slice(1);break;case"user":Q=q.slice(0);break;case"eval":Q=q.slice(1);break;default:throw Error(`unexpected parse option { from: '${X.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",Q}parse(q,X){this._prepareForParse();let Q=this._prepareUserArgs(q,X);return this._parseCommand([],Q),this}async parseAsync(q,X){this._prepareForParse();let Q=this._prepareUserArgs(q,X);return await this._parseCommand([],Q),this}_prepareForParse(){if(this._savedState===null)this.saveStateBeforeParse();else this.restoreStateBeforeParse()}saveStateBeforeParse(){this._savedState={_name:this._name,_optionValues:{...this._optionValues},_optionValueSources:{...this._optionValueSources}}}restoreStateBeforeParse(){if(this._storeOptionsAsProperties)throw Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);this._name=this._savedState._name,this._scriptPath=null,this.rawArgs=[],this._optionValues={...this._savedState._optionValues},this._optionValueSources={...this._savedState._optionValueSources},this.args=[],this.processedArgs=[]}_checkForMissingExecutable(q,X,Q){if(Z3.existsSync(q))return;let _=X?`searched for local subcommand relative to directory '${X}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",$=`'${q}' does not exist
 - if '${Q}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${_}`;throw Error($)}_executeSubCommand(q,X){X=X.slice();let Q=!1,_=[".js",".ts",".tsx",".mjs",".cjs"];function $(G,z){let U=Mq.resolve(G,z);if(Z3.existsSync(U))return U;if(_.includes(Mq.extname(z)))return;let L=_.find((A)=>Z3.existsSync(`${U}${A}`));if(L)return`${U}${L}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let J=q._executableFile||`${this._name}-${q._name}`,Y=this._executableDir||"";if(this._scriptPath){let G;try{G=Z3.realpathSync(this._scriptPath)}catch{G=this._scriptPath}Y=Mq.resolve(Mq.dirname(G),Y)}if(Y){let G=$(Y,J);if(!G&&!q._executableFile&&this._scriptPath){let z=Mq.basename(this._scriptPath,Mq.extname(this._scriptPath));if(z!==this._name)G=$(Y,`${z}-${q._name}`)}J=G||J}Q=_.includes(Mq.extname(J));let H;if(T.platform!=="win32")if(Q)X.unshift(J),X=Q8(T.execArgv).concat(X),H=H6.spawn(T.argv[0],X,{stdio:"inherit"});else H=H6.spawn(J,X,{stdio:"inherit"});else this._checkForMissingExecutable(J,Y,q._name),X.unshift(J),X=Q8(T.execArgv).concat(X),H=H6.spawn(T.execPath,X,{stdio:"inherit"});if(!H.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((z)=>{T.on(z,()=>{if(H.killed===!1&&H.exitCode===null)H.kill(z)})});let W=this._exitCallback;H.on("close",(G)=>{if(G=G??1,!W)T.exit(G);else W(new W6(G,"commander.executeSubCommandAsync","(close)"))}),H.on("error",(G)=>{if(G.code==="ENOENT")this._checkForMissingExecutable(J,Y,q._name);else if(G.code==="EACCES")throw Error(`'${J}' not executable`);if(!W)T.exit(1);else{let z=new W6(1,"commander.executeSubCommandAsync","(error)");z.nestedError=G,W(z)}}),this.runningCommand=H}_dispatchSubcommand(q,X,Q){let _=this._findCommand(q);if(!_)this.help({error:!0});_._prepareForParse();let $;return $=this._chainOrCallSubCommandHook($,_,"preSubcommand"),$=this._chainOrCall($,()=>{if(_._executableHandler)this._executeSubCommand(_,X.concat(Q));else return _._parseCommand(X,Q)}),$}_dispatchHelpCommand(q){if(!q)this.help();let X=this._findCommand(q);if(X&&!X._executableHandler)X.help();return this._dispatchSubcommand(q,[],[this._getHelpOption()?.long??this._getHelpOption()?.short??"--help"])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((q,X)=>{if(q.required&&this.args[X]==null)this.missingArgument(q.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let q=(Q,_,$)=>{let J=_;if(_!==null&&Q.parseArg){let Y=`error: command-argument value '${_}' is invalid for argument '${Q.name()}'.`;J=this._callParseArg(Q,_,$,Y)}return J};this._checkNumberOfArguments();let X=[];this.registeredArguments.forEach((Q,_)=>{let $=Q.defaultValue;if(Q.variadic){if(_<this.args.length){if($=this.args.slice(_),Q.parseArg)$=$.reduce((J,Y)=>{return q(Q,Y,J)},Q.defaultValue)}else if($===void 0)$=[]}else if(_<this.args.length){if($=this.args[_],Q.parseArg)$=q(Q,$,Q.defaultValue)}X[_]=$}),this.processedArgs=X}_chainOrCall(q,X){if(q?.then&&typeof q.then==="function")return q.then(()=>X());return X()}_chainOrCallHooks(q,X){let Q=q,_=[];if(this._getCommandAndAncestors().reverse().filter(($)=>$._lifeCycleHooks[X]!==void 0).forEach(($)=>{$._lifeCycleHooks[X].forEach((J)=>{_.push({hookedCommand:$,callback:J})})}),X==="postAction")_.reverse();return _.forEach(($)=>{Q=this._chainOrCall(Q,()=>{return $.callback($.hookedCommand,this)})}),Q}_chainOrCallSubCommandHook(q,X,Q){let _=q;if(this._lifeCycleHooks[Q]!==void 0)this._lifeCycleHooks[Q].forEach(($)=>{_=this._chainOrCall(_,()=>{return $(this,X)})});return _}_parseCommand(q,X){let Q=this.parseOptions(X);if(this._parseOptionsEnv(),this._parseOptionsImplied(),q=q.concat(Q.operands),X=Q.unknown,this.args=q.concat(X),q&&this._findCommand(q[0]))return this._dispatchSubcommand(q[0],q.slice(1),X);if(this._getHelpCommand()&&q[0]===this._getHelpCommand().name())return this._dispatchHelpCommand(q[1]);if(this._defaultCommandName)return this._outputHelpIfRequested(X),this._dispatchSubcommand(this._defaultCommandName,q,X);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});this._outputHelpIfRequested(Q.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let _=()=>{if(Q.unknown.length>0)this.unknownOption(Q.unknown[0])},$=`command:${this.name()}`;if(this._actionHandler){_(),this._processArguments();let J;if(J=this._chainOrCallHooks(J,"preAction"),J=this._chainOrCall(J,()=>this._actionHandler(this.processedArgs)),this.parent)J=this._chainOrCall(J,()=>{this.parent.emit($,q,X)});return J=this._chainOrCallHooks(J,"postAction"),J}if(this.parent?.listenerCount($))_(),this._processArguments(),this.parent.emit($,q,X);else if(q.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",q,X);if(this.listenerCount("command:*"))this.emit("command:*",q,X);else if(this.commands.length)this.unknownCommand();else _(),this._processArguments()}else if(this.commands.length)_(),this.help({error:!0});else _(),this._processArguments()}_findCommand(q){if(!q)return;return this.commands.find((X)=>X._name===q||X._aliases.includes(q))}_findOption(q){return this.options.find((X)=>X.is(q))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((q)=>{q.options.forEach((X)=>{if(X.mandatory&&q.getOptionValue(X.attributeName())===void 0)q.missingMandatoryOptionValue(X)})})}_checkForConflictingLocalOptions(){let q=this.options.filter((Q)=>{let _=Q.attributeName();if(this.getOptionValue(_)===void 0)return!1;return this.getOptionValueSource(_)!=="default"});q.filter((Q)=>Q.conflictsWith.length>0).forEach((Q)=>{let _=q.find(($)=>Q.conflictsWith.includes($.attributeName()));if(_)this._conflictingOption(Q,_)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((q)=>{q._checkForConflictingLocalOptions()})}parseOptions(q){let X=[],Q=[],_=X;function $(G){return G.length>1&&G[0]==="-"}let J=(G)=>{if(!/^-(\d+|\d*\.\d+)(e[+-]?\d+)?$/.test(G))return!1;return!this._getCommandAndAncestors().some((z)=>z.options.map((U)=>U.short).some((U)=>/^-\d$/.test(U)))},Y=null,H=null,W=0;while(W<q.length||H){let G=H??q[W++];if(H=null,G==="--"){if(_===Q)_.push(G);_.push(...q.slice(W));break}if(Y&&(!$(G)||J(G))){this.emit(`option:${Y.name()}`,G);continue}if(Y=null,$(G)){let z=this._findOption(G);if(z){if(z.required){let U=q[W++];if(U===void 0)this.optionMissingArgument(z);this.emit(`option:${z.name()}`,U)}else if(z.optional){let U=null;if(W<q.length&&(!$(q[W])||J(q[W])))U=q[W++];this.emit(`option:${z.name()}`,U)}else this.emit(`option:${z.name()}`);Y=z.variadic?z:null;continue}}if(G.length>2&&G[0]==="-"&&G[1]!=="-"){let z=this._findOption(`-${G[1]}`);if(z){if(z.required||z.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${z.name()}`,G.slice(2));else this.emit(`option:${z.name()}`),H=`-${G.slice(2)}`;continue}}if(/^--[^=]+=/.test(G)){let z=G.indexOf("="),U=this._findOption(G.slice(0,z));if(U&&(U.required||U.optional)){this.emit(`option:${U.name()}`,G.slice(z+1));continue}}if(_===X&&$(G)&&!(this.commands.length===0&&J(G)))_=Q;if((this._enablePositionalOptions||this._passThroughOptions)&&X.length===0&&Q.length===0){if(this._findCommand(G)){X.push(G),Q.push(...q.slice(W));break}else if(this._getHelpCommand()&&G===this._getHelpCommand().name()){X.push(G,...q.slice(W));break}else if(this._defaultCommandName){Q.push(G,...q.slice(W));break}}if(this._passThroughOptions){_.push(G,...q.slice(W));break}_.push(G)}return{operands:X,unknown:Q}}opts(){if(this._storeOptionsAsProperties){let q={},X=this.options.length;for(let Q=0;Q<X;Q++){let _=this.options[Q].attributeName();q[_]=_===this._versionOptionName?this._version:this[_]}return q}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((q,X)=>Object.assign(q,X.opts()),{})}error(q,X){if(this._outputConfiguration.outputError(`${q}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let Q=X||{},_=Q.exitCode||1,$=Q.code||"commander.error";this._exit(_,$,q)}_parseOptionsEnv(){this.options.forEach((q)=>{if(q.envVar&&q.envVar in T.env){let X=q.attributeName();if(this.getOptionValue(X)===void 0||["default","config","env"].includes(this.getOptionValueSource(X)))if(q.required||q.optional)this.emit(`optionEnv:${q.name()}`,T.env[q.envVar]);else this.emit(`optionEnv:${q.name()}`)}})}_parseOptionsImplied(){let q=new eX(this.options),X=(Q)=>{return this.getOptionValue(Q)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(Q))};this.options.filter((Q)=>Q.implied!==void 0&&X(Q.attributeName())&&q.valueFromOption(this.getOptionValue(Q.attributeName()),Q)).forEach((Q)=>{Object.keys(Q.implied).filter((_)=>!X(_)).forEach((_)=>{this.setOptionValueWithSource(_,Q.implied[_],"implied")})})}missingArgument(q){let X=`error: missing required argument '${q}'`;this.error(X,{code:"commander.missingArgument"})}optionMissingArgument(q){let X=`error: option '${q.flags}' argument missing`;this.error(X,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(q){let X=`error: required option '${q.flags}' not specified`;this.error(X,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(q,X){let Q=(J)=>{let Y=J.attributeName(),H=this.getOptionValue(Y),W=this.options.find((z)=>z.negate&&Y===z.attributeName()),G=this.options.find((z)=>!z.negate&&Y===z.attributeName());if(W&&(W.presetArg===void 0&&H===!1||W.presetArg!==void 0&&H===W.presetArg))return W;return G||J},_=(J)=>{let Y=Q(J),H=Y.attributeName();if(this.getOptionValueSource(H)==="env")return`environment variable '${Y.envVar}'`;return`option '${Y.flags}'`},$=`error: ${_(q)} cannot be used with ${_(X)}`;this.error($,{code:"commander.conflictingOption"})}unknownOption(q){if(this._allowUnknownOption)return;let X="";if(q.startsWith("--")&&this._showSuggestionAfterError){let _=[],$=this;do{let J=$.createHelp().visibleOptions($).filter((Y)=>Y.long).map((Y)=>Y.long);_=_.concat(J),$=$.parent}while($&&!$._enablePositionalOptions);X=X8(q,_)}let Q=`error: unknown option '${q}'${X}`;this.error(Q,{code:"commander.unknownOption"})}_excessArguments(q){if(this._allowExcessArguments)return;let X=this.registeredArguments.length,Q=X===1?"":"s",$=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${X} argument${Q} but got ${q.length}.`;this.error($,{code:"commander.excessArguments"})}unknownCommand(){let q=this.args[0],X="";if(this._showSuggestionAfterError){let _=[];this.createHelp().visibleCommands(this).forEach(($)=>{if(_.push($.name()),$.alias())_.push($.alias())}),X=X8(q,_)}let Q=`error: unknown command '${q}'${X}`;this.error(Q,{code:"commander.unknownCommand"})}version(q,X,Q){if(q===void 0)return this._version;this._version=q,X=X||"-V, --version",Q=Q||"output the version number";let _=this.createOption(X,Q);return this._versionOptionName=_.attributeName(),this._registerOption(_),this.on("option:"+_.name(),()=>{this._outputConfiguration.writeOut(`${q}
`),this._exit(0,"commander.version",q)}),this}description(q,X){if(q===void 0&&X===void 0)return this._description;if(this._description=q,X)this._argsDescription=X;return this}summary(q){if(q===void 0)return this._summary;return this._summary=q,this}alias(q){if(q===void 0)return this._aliases[0];let X=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)X=this.commands[this.commands.length-1];if(q===X._name)throw Error("Command alias can't be the same as its name");let Q=this.parent?._findCommand(q);if(Q){let _=[Q.name()].concat(Q.aliases()).join("|");throw Error(`cannot add alias '${q}' to command '${this.name()}' as already have command '${_}'`)}return X._aliases.push(q),this}aliases(q){if(q===void 0)return this._aliases;return q.forEach((X)=>this.alias(X)),this}usage(q){if(q===void 0){if(this._usage)return this._usage;let X=this.registeredArguments.map((Q)=>{return rX(Q)});return[].concat(this.options.length||this._helpOption!==null?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?X:[]).join(" ")}return this._usage=q,this}name(q){if(q===void 0)return this._name;return this._name=q,this}helpGroup(q){if(q===void 0)return this._helpGroupHeading??"";return this._helpGroupHeading=q,this}commandsGroup(q){if(q===void 0)return this._defaultCommandGroup??"";return this._defaultCommandGroup=q,this}optionsGroup(q){if(q===void 0)return this._defaultOptionGroup??"";return this._defaultOptionGroup=q,this}_initOptionGroup(q){if(this._defaultOptionGroup&&!q.helpGroupHeading)q.helpGroup(this._defaultOptionGroup)}_initCommandGroup(q){if(this._defaultCommandGroup&&!q.helpGroup())q.helpGroup(this._defaultCommandGroup)}nameFromFilename(q){return this._name=Mq.basename(q,Mq.extname(q)),this}executableDir(q){if(q===void 0)return this._executableDir;return this._executableDir=q,this}helpInformation(q){let X=this.createHelp(),Q=this._getOutputContext(q);X.prepareContext({error:Q.error,helpWidth:Q.helpWidth,outputHasColors:Q.hasColors});let _=X.formatHelp(this,X);if(Q.hasColors)return _;return this._outputConfiguration.stripColor(_)}_getOutputContext(q){q=q||{};let X=!!q.error,Q,_,$;if(X)Q=(Y)=>this._outputConfiguration.writeErr(Y),_=this._outputConfiguration.getErrHasColors(),$=this._outputConfiguration.getErrHelpWidth();else Q=(Y)=>this._outputConfiguration.writeOut(Y),_=this._outputConfiguration.getOutHasColors(),$=this._outputConfiguration.getOutHelpWidth();return{error:X,write:(Y)=>{if(!_)Y=this._outputConfiguration.stripColor(Y);return Q(Y)},hasColors:_,helpWidth:$}}outputHelp(q){let X;if(typeof q==="function")X=q,q=void 0;let Q=this._getOutputContext(q),_={error:Q.error,write:Q.write,command:this};this._getCommandAndAncestors().reverse().forEach((J)=>J.emit("beforeAllHelp",_)),this.emit("beforeHelp",_);let $=this.helpInformation({error:Q.error});if(X){if($=X($),typeof $!=="string"&&!Buffer.isBuffer($))throw Error("outputHelp callback must return a string or a Buffer")}if(Q.write($),this._getHelpOption()?.long)this.emit(this._getHelpOption().long);this.emit("afterHelp",_),this._getCommandAndAncestors().forEach((J)=>J.emit("afterAllHelp",_))}helpOption(q,X){if(typeof q==="boolean"){if(q){if(this._helpOption===null)this._helpOption=void 0;if(this._defaultOptionGroup)this._initOptionGroup(this._getHelpOption())}else this._helpOption=null;return this}if(this._helpOption=this.createOption(q??"-h, --help",X??"display help for command"),q||X)this._initOptionGroup(this._helpOption);return this}_getHelpOption(){if(this._helpOption===void 0)this.helpOption(void 0,void 0);return this._helpOption}addHelpOption(q){return this._helpOption=q,this._initOptionGroup(q),this}help(q){this.outputHelp(q);let X=Number(T.exitCode??0);if(X===0&&q&&typeof q!=="function"&&q.error)X=1;this._exit(X,"commander.help","(outputHelp)")}addHelpText(q,X){let Q=["beforeAll","before","after","afterAll"];if(!Q.includes(q))throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${Q.join("', '")}'`);let _=`${q}Help`;return this.on(_,($)=>{let J;if(typeof X==="function")J=X({error:$.error,command:$.command});else J=X;if(J)$.write(`${J}
`)}),this}_outputHelpIfRequested(q){let X=this._getHelpOption();if(X&&q.find((_)=>X.is(_)))this.outputHelp(),this._exit(0,"commander.helpDisplayed","(outputHelp)")}}function Q8(q){return q.map((X)=>{if(!X.startsWith("--inspect"))return X;let Q,_="127.0.0.1",$="9229",J;if((J=X.match(/^(--inspect(-brk)?)$/))!==null)Q=J[1];else if((J=X.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(Q=J[1],/^\d+$/.test(J[3]))$=J[3];else _=J[3];else if((J=X.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)Q=J[1],_=J[3],$=J[4];if(Q&&$!=="0")return`${Q}=${_}:${parseInt($)+1}`;return X})}function G6(){if(T.env.NO_COLOR||T.env.FORCE_COLOR==="0"||T.env.FORCE_COLOR==="false")return!1;if(T.env.FORCE_COLOR||T.env.CLICOLOR_FORCE!==void 0)return!0;return}q1.Command=z6;q1.useColor=G6});var H8=Pq((J1)=>{var{Argument:$8}=f3(),{Command:U6}=_8(),{CommanderError:_1,InvalidArgumentError:J8}=A3(),{Help:$1}=J6(),{Option:Y8}=Y6();J1.program=new U6;J1.createCommand=(q)=>new U6(q);J1.createOption=(q,X)=>new Y8(q,X);J1.createArgument=(q,X)=>new $8(q,X);J1.Command=U6;J1.Option=Y8;J1.Argument=$8;J1.Help=$1;J1.CommanderError=_1;J1.InvalidArgumentError=J8;J1.InvalidOptionArgumentError=J8});var A6={};wq(A6,{validateBranchName:()=>O6,syncSharedContracts:()=>N1,isPluginInstallation:()=>y3,isMultiRepoChild:()=>L6,hasGit:()=>B8,getTemplatesDir:()=>fq,getScriptsDir:()=>A1,getRepoRoot:()=>B3,getPluginRoot:()=>h3,getMultiRepoContext:()=>iq,getMemoryDir:()=>B1,getFeaturePaths:()=>p,getFeatureDir:()=>w1,getDefaultWorkflowMode:()=>E1,getCurrentBranch:()=>A8,getChildRepoName:()=>g3,findFeatureDirByPrefix:()=>D8,findChildReposWithNames:()=>K6,findChildRepos:()=>O8,detectSpeckRoot:()=>b,detectSpeckMode:()=>D1,clearSpeckCache:()=>V6,checkFile:()=>S1,checkFeatureBranch:()=>D3,checkDir:()=>F1});import{existsSync as Yq}from"fs";import{readdirSync as j6}from"fs";import k from"fs/promises";import D from"path";var{$:x3}=globalThis.Bun;function y3(){if(process.env.CLAUDE_PLUGIN_ROOT)return!0;let q=import.meta.dir;return q.includes("/.claude/plugins/")||q.includes("/.config/claude-code/plugins/")}function h3(){if(process.env.CLAUDE_PLUGIN_ROOT)return process.env.CLAUDE_PLUGIN_ROOT;let q=import.meta.dir;if(y3())return D.resolve(q,"../../..");else return D.resolve(q,"../../..")}function fq(){let q=h3();if(y3())return D.join(q,"templates");else return D.join(q,".speck/templates")}function A1(){let q=h3();return D.join(q,".speck/scripts")}function B1(){let q=h3();if(y3())return D.join(q,"memory");else return D.join(q,".speck/memory")}async function B3(){try{return(await x3`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{return process.cwd()}}function V6(){Cq=null}async function b(){if(Cq)return Cq;let q=await B3(),X=D.join(q,".speck","root");try{if(!(await k.lstat(X)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let W={mode:"single-repo",speckRoot:q,repoRoot:q,specsDir:D.join(q,"specs")};return Cq=W,W}let _=await k.realpath(X),$=["/","/etc","/usr","/bin","/sbin","/System","/Library"],J=process.env.HOME||process.env.USERPROFILE||"";if($.some((W)=>_===W||_.startsWith(W+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${_}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(J&&_===D.dirname(J))throw Error(`Security: .speck/root symlink points above home directory: ${_}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await k.access(_);let Y=D.join(q,"specs");try{if((await k.stat(Y)).isDirectory()&&_!==q)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${Y}
  Shared: ${D.join(_,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${Y}/* ${D.join(_,"specs")}/
  2. Remove local specs: rm -rf ${Y}
`)}catch(W){let G=W;if(G.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${G.message}`)}let H={mode:"multi-repo",speckRoot:_,repoRoot:q,specsDir:D.join(_,"specs")};return Cq=H,H}catch(Q){let _=Q;if(_.code==="ENOENT"){if((await O8(q)).length>0){let H={mode:"multi-repo",speckRoot:q,repoRoot:q,specsDir:D.join(q,"specs")};return Cq=H,H}let Y={mode:"single-repo",speckRoot:q,repoRoot:q,specsDir:D.join(q,"specs")};return Cq=Y,Y}if(_.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let $=await k.readlink(X).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${$} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}async function L6(){let q=await b();return q.mode==="multi-repo"&&q.repoRoot!==q.speckRoot}async function g3(q,X){try{let Q=await k.realpath(q),_=await k.readdir(X,{withFileTypes:!0});for(let $ of _)if($.isSymbolicLink()&&$.name.startsWith(".speck-link-")){let J=D.join(X,$.name);try{if(await k.realpath(J)===Q)return $.name.replace(/^\.speck-link-/,"")}catch{continue}}}catch{}return D.basename(q)}async function O8(q){let X=[];try{let Q=await k.readdir(q,{withFileTypes:!0});for(let _ of Q)if(_.isSymbolicLink()&&_.name.startsWith(".speck-link-")){let $=D.join(q,_.name);try{let J=await k.realpath($);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((W)=>J===W||J.startsWith(W+"/"))){console.warn(`Security: Skipping ${_.name} - points to system directory: ${J}`);continue}let H=D.join(J,".git");try{await k.access(H),X.push(J)}catch{console.warn(`Warning: ${_.name} points to non-git directory: ${J}`)}}catch(J){let Y=J instanceof Error?J.message:String(J);console.warn(`Warning: Broken symlink ${_.name}: ${Y}`)}}}catch(Q){if(Q.code!=="ENOENT")throw Q}return X}async function K6(q){let X=new Map;try{let Q=await k.readdir(q,{withFileTypes:!0});for(let _ of Q)if(_.isSymbolicLink()&&_.name.startsWith(".speck-link-")){let $=D.join(q,_.name),J=_.name.substring(12);try{let Y=await k.realpath($);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((G)=>Y===G||Y.startsWith(G+"/"))){console.warn(`Security: Skipping ${_.name} - points to system directory: ${Y}`);continue}let W=D.join(Y,".git");try{await k.access(W),X.set(J,Y)}catch{console.warn(`Warning: ${_.name} points to non-git directory: ${Y}`)}}catch(Y){let H=Y instanceof Error?Y.message:String(Y);console.warn(`Warning: Broken symlink ${_.name}: ${H}`)}}}catch(Q){if(Q.code!=="ENOENT")throw Q}return X}async function iq(){let q=await b();if(q.mode==="single-repo")return{...q,context:"single",parentSpecId:null,childRepoName:null};if(q.repoRoot===q.speckRoot)return{...q,context:"root",parentSpecId:null,childRepoName:null};else{let X=await g3(q.repoRoot,q.speckRoot),Q=null;try{let _=D.join(q.repoRoot,".speck","branches.json"),$=await k.readFile(_,"utf-8"),J=JSON.parse($);if(J.branches&&J.branches.length>0)Q=J.branches[0]?.parentSpecId||null}catch{}if(!Q)try{let{$:_}=awaitPromise.resolve(globalThis.Bun),J=(await _`git -C ${q.speckRoot} rev-parse --abbrev-ref HEAD`.quiet()).stdout.toString().trim();if(/^\d{3}-/.test(J))Q=J}catch{}return{...q,context:"child",parentSpecId:Q,childRepoName:X}}}async function A8(q){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await x3`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let X=D.join(q,"specs");if(Yq(X)){let Q="",_=0,$=j6(X,{withFileTypes:!0});for(let J of $)if(J.isDirectory()){let Y=J.name.match(/^(\d{3})-/);if(Y&&Y[1]){let H=parseInt(Y[1],10);if(H>_)_=H,Q=J.name}}if(Q)return Q}return"main"}}async function B8(){try{let q=process.cwd(),X=D.join(q,".git");if(Yq(X))return!0;return await x3`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function O6(q){try{return(await x3`git check-ref-format --branch ${q}`.quiet()).exitCode===0}catch{return!1}}async function D3(q,X,Q){if(!X)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let _=D.join(Q,".speck","branches.json");if(Yq(_))try{let $=await k.readFile(_,"utf-8"),J=JSON.parse($);if(J.branches&&Array.isArray(J.branches)){if(J.branches.some((H)=>H.name===q))return!0}}catch{}if(!/^\d{3}-/.test(q))return console.error(`ERROR: Not on a feature branch. Current branch: ${q}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}function w1(q,X){return D.join(q,"specs",X)}async function D8(q,X,Q){let _=D.join(Q,".speck","branches.json");if(Yq(_))try{let H=await k.readFile(_,"utf-8"),W=JSON.parse(H);if(W.branches&&Array.isArray(W.branches)){let G=W.branches.find((z)=>z.name===X);if(G&&G.specId)return D.join(q,G.specId)}}catch{}let $=X.match(/^(\d{3})-/);if(!$)return D.join(q,X);let J=$[1],Y=[];if(Yq(q)){let H=j6(q,{withFileTypes:!0});for(let W of H)if(W.isDirectory()&&W.name.startsWith(`${J}-`))Y.push(W.name)}if(Y.length===0)return D.join(q,X);else if(Y.length===1&&Y[0])return D.join(q,Y[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${J}': ${Y.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),D.join(q,X)}async function p(){let q=await b(),X=await A8(q.repoRoot),Q=await B8(),_=await D8(q.specsDir,X,q.repoRoot),$=D.basename(_),J=D.join(q.repoRoot,"specs",$);return{MODE:q.mode,SPECK_ROOT:q.speckRoot,SPECS_DIR:q.specsDir,REPO_ROOT:q.repoRoot,CURRENT_BRANCH:X,HAS_GIT:Q?"true":"false",FEATURE_DIR:_,FEATURE_SPEC:D.join(_,"spec.md"),CHECKLISTS_DIR:D.join(_,"checklists"),LINKED_REPOS:D.join(_,"linked-repos.md"),IMPL_PLAN:D.join(J,"plan.md"),TASKS:D.join(J,"tasks.md"),RESEARCH:D.join(J,"research.md"),DATA_MODEL:D.join(J,"data-model.md"),QUICKSTART:D.join(J,"quickstart.md"),CONTRACTS_DIR:D.join(J,"contracts")}}async function E1(){try{let q=await B3(),X=D.join(q,".speck/memory/constitution.md");if(!Yq(X))return null;let _=(await k.readFile(X,"utf-8")).match(/^\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)\s*$/m);if(_&&(_[1]==="stacked-pr"||_[1]==="single-branch"))return _[1];return null}catch(q){return null}}function S1(q,X){return Yq(q)?`  \u2713 ${X}`:`  \u2717 ${X}`}function F1(q,X){if(!Yq(q))return`  \u2717 ${X}`;try{return j6(q).length>0?`  \u2713 ${X}`:`  \u2717 ${X}`}catch{return`  \u2717 ${X}`}}async function N1(q){let X=await b();if(X.mode!=="multi-repo")return!1;let Q=D.join(X.speckRoot,"specs",q,"contracts");if(!Yq(Q))return!1;let _=D.join(X.repoRoot,"specs",q);if(!Yq(_))return!1;let $=D.join(_,"contracts");try{if((await k.lstat($)).isSymbolicLink()){if(await k.realpath($)===Q)return!0;await k.unlink($)}else return console.warn(`WARNING: Local contracts/ directory exists but is not a symlink
  Local: ${$}
  Shared: ${Q}
  Skipping symlink creation to preserve local data.`),!1}catch(Y){if(Y.code!=="ENOENT")throw Y}let J=D.relative(_,Q);try{return await k.symlink(J,$,"dir"),!0}catch(Y){let H=Y instanceof Error?Y.message:String(Y);return console.warn(`Warning: Failed to create contracts/ symlink: ${H}`),!1}}var Cq=null,D1;var o=Z(()=>{D1=b});var w3=()=>{};var I,E6,j,Hq=(q)=>{switch(typeof q){case"undefined":return j.undefined;case"string":return j.string;case"number":return Number.isNaN(q)?j.nan:j.number;case"boolean":return j.boolean;case"function":return j.function;case"bigint":return j.bigint;case"symbol":return j.symbol;case"object":if(Array.isArray(q))return j.array;if(q===null)return j.null;if(q.then&&typeof q.then==="function"&&q.catch&&typeof q.catch==="function")return j.promise;if(typeof Map<"u"&&q instanceof Map)return j.map;if(typeof Set<"u"&&q instanceof Set)return j.set;if(typeof Date<"u"&&q instanceof Date)return j.date;return j.object;default:return j.unknown}};var E3=Z(()=>{(function(q){q.assertEqual=($)=>{};function X($){}q.assertIs=X;function Q($){throw Error()}q.assertNever=Q,q.arrayToEnum=($)=>{let J={};for(let Y of $)J[Y]=Y;return J},q.getValidEnumValues=($)=>{let J=q.objectKeys($).filter((H)=>typeof $[$[H]]!=="number"),Y={};for(let H of J)Y[H]=$[H];return q.objectValues(Y)},q.objectValues=($)=>{return q.objectKeys($).map(function(J){return $[J]})},q.objectKeys=typeof Object.keys==="function"?($)=>Object.keys($):($)=>{let J=[];for(let Y in $)if(Object.prototype.hasOwnProperty.call($,Y))J.push(Y);return J},q.find=($,J)=>{for(let Y of $)if(J(Y))return Y;return},q.isInteger=typeof Number.isInteger==="function"?($)=>Number.isInteger($):($)=>typeof $==="number"&&Number.isFinite($)&&Math.floor($)===$;function _($,J=" | "){return $.map((Y)=>typeof Y==="string"?`'${Y}'`:Y).join(J)}q.joinValues=_,q.jsonStringifyReplacer=($,J)=>{if(typeof J==="bigint")return J.toString();return J}})(I||(I={}));(function(q){q.mergeShapes=(X,Q)=>{return{...X,...Q}}})(E6||(E6={}));j=I.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"])});var M,Z1=(q)=>{return JSON.stringify(q,null,2).replace(/"([^"]+)":/g,"$1:")},i;var l3=Z(()=>{E3();M=I.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]);i=class i extends Error{get errors(){return this.issues}constructor(q){super();this.issues=[],this.addIssue=(Q)=>{this.issues=[...this.issues,Q]},this.addIssues=(Q=[])=>{this.issues=[...this.issues,...Q]};let X=new.target.prototype;if(Object.setPrototypeOf)Object.setPrototypeOf(this,X);else this.__proto__=X;this.name="ZodError",this.issues=q}format(q){let X=q||function($){return $.message},Q={_errors:[]},_=($)=>{for(let J of $.issues)if(J.code==="invalid_union")J.unionErrors.map(_);else if(J.code==="invalid_return_type")_(J.returnTypeError);else if(J.code==="invalid_arguments")_(J.argumentsError);else if(J.path.length===0)Q._errors.push(X(J));else{let Y=Q,H=0;while(H<J.path.length){let W=J.path[H];if(H!==J.path.length-1)Y[W]=Y[W]||{_errors:[]};else Y[W]=Y[W]||{_errors:[]},Y[W]._errors.push(X(J));Y=Y[W],H++}}};return _(this),Q}static assert(q){if(!(q instanceof i))throw Error(`Not a ZodError: ${q}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,I.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten(q=(X)=>X.message){let X={},Q=[];for(let _ of this.issues)if(_.path.length>0){let $=_.path[0];X[$]=X[$]||[],X[$].push(q(_))}else Q.push(q(_));return{formErrors:Q,fieldErrors:X}}get formErrors(){return this.flatten()}};i.create=(q)=>{return new i(q)}});var b1=(q,X)=>{let Q;switch(q.code){case M.invalid_type:if(q.received===j.undefined)Q="Required";else Q=`Expected ${q.expected}, received ${q.received}`;break;case M.invalid_literal:Q=`Invalid literal value, expected ${JSON.stringify(q.expected,I.jsonStringifyReplacer)}`;break;case M.unrecognized_keys:Q=`Unrecognized key(s) in object: ${I.joinValues(q.keys,", ")}`;break;case M.invalid_union:Q="Invalid input";break;case M.invalid_union_discriminator:Q=`Invalid discriminator value. Expected ${I.joinValues(q.options)}`;break;case M.invalid_enum_value:Q=`Invalid enum value. Expected ${I.joinValues(q.options)}, received '${q.received}'`;break;case M.invalid_arguments:Q="Invalid function arguments";break;case M.invalid_return_type:Q="Invalid function return type";break;case M.invalid_date:Q="Invalid date";break;case M.invalid_string:if(typeof q.validation==="object")if("includes"in q.validation){if(Q=`Invalid input: must include "${q.validation.includes}"`,typeof q.validation.position==="number")Q=`${Q} at one or more positions greater than or equal to ${q.validation.position}`}else if("startsWith"in q.validation)Q=`Invalid input: must start with "${q.validation.startsWith}"`;else if("endsWith"in q.validation)Q=`Invalid input: must end with "${q.validation.endsWith}"`;else I.assertNever(q.validation);else if(q.validation!=="regex")Q=`Invalid ${q.validation}`;else Q="Invalid";break;case M.too_small:if(q.type==="array")Q=`Array must contain ${q.exact?"exactly":q.inclusive?"at least":"more than"} ${q.minimum} element(s)`;else if(q.type==="string")Q=`String must contain ${q.exact?"exactly":q.inclusive?"at least":"over"} ${q.minimum} character(s)`;else if(q.type==="number")Q=`Number must be ${q.exact?"exactly equal to ":q.inclusive?"greater than or equal to ":"greater than "}${q.minimum}`;else if(q.type==="bigint")Q=`Number must be ${q.exact?"exactly equal to ":q.inclusive?"greater than or equal to ":"greater than "}${q.minimum}`;else if(q.type==="date")Q=`Date must be ${q.exact?"exactly equal to ":q.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(q.minimum))}`;else Q="Invalid input";break;case M.too_big:if(q.type==="array")Q=`Array must contain ${q.exact?"exactly":q.inclusive?"at most":"less than"} ${q.maximum} element(s)`;else if(q.type==="string")Q=`String must contain ${q.exact?"exactly":q.inclusive?"at most":"under"} ${q.maximum} character(s)`;else if(q.type==="number")Q=`Number must be ${q.exact?"exactly":q.inclusive?"less than or equal to":"less than"} ${q.maximum}`;else if(q.type==="bigint")Q=`BigInt must be ${q.exact?"exactly":q.inclusive?"less than or equal to":"less than"} ${q.maximum}`;else if(q.type==="date")Q=`Date must be ${q.exact?"exactly":q.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(q.maximum))}`;else Q="Invalid input";break;case M.custom:Q="Invalid input";break;case M.invalid_intersection_types:Q="Intersection results could not be merged";break;case M.not_multiple_of:Q=`Number must be a multiple of ${q.multipleOf}`;break;case M.not_finite:Q="Number must be finite";break;default:Q=X.defaultError,I.assertNever(q)}return{message:Q}},Vq;var S6=Z(()=>{l3();E3();Vq=b1});function x1(q){N8=q}function nq(){return N8}var N8;var u3=Z(()=>{S6();N8=Vq});function V(q,X){let Q=nq(),_=S3({issueData:X,data:q.data,path:q.path,errorMaps:[q.common.contextualErrorMap,q.schemaErrorMap,Q,Q===Vq?void 0:Vq].filter(($)=>!!$)});q.common.issues.push(_)}class l{constructor(){this.value="valid"}dirty(){if(this.value==="valid")this.value="dirty"}abort(){if(this.value!=="aborted")this.value="aborted"}static mergeArray(q,X){let Q=[];for(let _ of X){if(_.status==="aborted")return B;if(_.status==="dirty")q.dirty();Q.push(_.value)}return{status:q.value,value:Q}}static async mergeObjectAsync(q,X){let Q=[];for(let _ of X){let $=await _.key,J=await _.value;Q.push({key:$,value:J})}return l.mergeObjectSync(q,Q)}static mergeObjectSync(q,X){let Q={};for(let _ of X){let{key:$,value:J}=_;if($.status==="aborted")return B;if(J.status==="aborted")return B;if($.status==="dirty")q.dirty();if(J.status==="dirty")q.dirty();if($.value!=="__proto__"&&(typeof J.value<"u"||_.alwaysSet))Q[$.value]=J.value}return{status:q.value,value:Q}}}var S3=(q)=>{let{data:X,path:Q,errorMaps:_,issueData:$}=q,J=[...Q,...$.path||[]],Y={...$,path:J};if($.message!==void 0)return{...$,path:J,message:$.message};let H="",W=_.filter((G)=>!!G).slice().reverse();for(let G of W)H=G(Y,{data:X,defaultError:H}).message;return{...$,path:J,message:H}},y1,B,xq=(q)=>({status:"dirty",value:q}),m=(q)=>({status:"valid",value:q}),m3=(q)=>q.status==="aborted",d3=(q)=>q.status==="dirty",Eq=(q)=>q.status==="valid",sq=(q)=>typeof Promise<"u"&&q instanceof Promise;var F6=Z(()=>{u3();S6();y1=[];B=Object.freeze({status:"aborted"})});var v8=()=>{};var K;var I8=Z(()=>{(function(q){q.errToObj=(X)=>typeof X==="string"?{message:X}:X||{},q.toString=(X)=>typeof X==="string"?X:X?.message})(K||(K={}))});class e{constructor(q,X,Q,_){this._cachedPath=[],this.parent=q,this.data=X,this._path=Q,this._key=_}get path(){if(!this._cachedPath.length)if(Array.isArray(this._key))this._cachedPath.push(...this._path,...this._key);else this._cachedPath.push(...this._path,this._key);return this._cachedPath}}function S(q){if(!q)return{};let{errorMap:X,invalid_type_error:Q,required_error:_,description:$}=q;if(X&&(Q||_))throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);if(X)return{errorMap:X,description:$};return{errorMap:(Y,H)=>{let{message:W}=q;if(Y.code==="invalid_enum_value")return{message:W??H.defaultError};if(typeof H.data>"u")return{message:W??_??H.defaultError};if(Y.code!=="invalid_type")return{message:H.defaultError};return{message:W??Q??H.defaultError}},description:$}}class F{get description(){return this._def.description}_getType(q){return Hq(q.data)}_getOrReturnCtx(q,X){return X||{common:q.parent.common,data:q.data,parsedType:Hq(q.data),schemaErrorMap:this._def.errorMap,path:q.path,parent:q.parent}}_processInputParams(q){return{status:new l,ctx:{common:q.parent.common,data:q.data,parsedType:Hq(q.data),schemaErrorMap:this._def.errorMap,path:q.path,parent:q.parent}}}_parseSync(q){let X=this._parse(q);if(sq(X))throw Error("Synchronous parse encountered promise.");return X}_parseAsync(q){let X=this._parse(q);return Promise.resolve(X)}parse(q,X){let Q=this.safeParse(q,X);if(Q.success)return Q.data;throw Q.error}safeParse(q,X){let Q={common:{issues:[],async:X?.async??!1,contextualErrorMap:X?.errorMap},path:X?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:q,parsedType:Hq(q)},_=this._parseSync({data:q,path:Q.path,parent:Q});return R8(Q,_)}"~validate"(q){let X={common:{issues:[],async:!!this["~standard"].async},path:[],schemaErrorMap:this._def.errorMap,parent:null,data:q,parsedType:Hq(q)};if(!this["~standard"].async)try{let Q=this._parseSync({data:q,path:[],parent:X});return Eq(Q)?{value:Q.value}:{issues:X.common.issues}}catch(Q){if(Q?.message?.toLowerCase()?.includes("encountered"))this["~standard"].async=!0;X.common={issues:[],async:!0}}return this._parseAsync({data:q,path:[],parent:X}).then((Q)=>Eq(Q)?{value:Q.value}:{issues:X.common.issues})}async parseAsync(q,X){let Q=await this.safeParseAsync(q,X);if(Q.success)return Q.data;throw Q.error}async safeParseAsync(q,X){let Q={common:{issues:[],contextualErrorMap:X?.errorMap,async:!0},path:X?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:q,parsedType:Hq(q)},_=this._parse({data:q,path:Q.path,parent:Q}),$=await(sq(_)?_:Promise.resolve(_));return R8(Q,$)}refine(q,X){let Q=(_)=>{if(typeof X==="string"||typeof X>"u")return{message:X};else if(typeof X==="function")return X(_);else return X};return this._refinement((_,$)=>{let J=q(_),Y=()=>$.addIssue({code:M.custom,...Q(_)});if(typeof Promise<"u"&&J instanceof Promise)return J.then((H)=>{if(!H)return Y(),!1;else return!0});if(!J)return Y(),!1;else return!0})}refinement(q,X){return this._refinement((Q,_)=>{if(!q(Q))return _.addIssue(typeof X==="function"?X(Q,_):X),!1;else return!0})}_refinement(q){return new qq({schema:this,typeName:w.ZodEffects,effect:{type:"refinement",refinement:q}})}superRefine(q){return this._refinement(q)}constructor(q){this.spa=this.safeParseAsync,this._def=q,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this),this["~standard"]={version:1,vendor:"zod",validate:(X)=>this["~validate"](X)}}optional(){return t.create(this,this._def)}nullable(){return Kq.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return a.create(this)}promise(){return lq.create(this,this._def)}or(q){return q3.create([this,q],this._def)}and(q){return X3.create(this,q,this._def)}transform(q){return new qq({...S(this._def),schema:this,typeName:w.ZodEffects,effect:{type:"transform",transform:q}})}default(q){let X=typeof q==="function"?q:()=>q;return new J3({...S(this._def),innerType:this,defaultValue:X,typeName:w.ZodDefault})}brand(){return new p3({typeName:w.ZodBranded,type:this,...S(this._def)})}catch(q){let X=typeof q==="function"?q:()=>q;return new Y3({...S(this._def),innerType:this,catchValue:X,typeName:w.ZodCatch})}describe(q){return new this.constructor({...this._def,description:q})}pipe(q){return T3.create(this,q)}readonly(){return H3.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}function k8(q){let X="[0-5]\\d";if(q.precision)X=`${X}\\.\\d{${q.precision}}`;else if(q.precision==null)X=`${X}(\\.\\d+)?`;let Q=q.precision?"+":"?";return`([01]\\d|2[0-3]):[0-5]\\d(:${X})${Q}`}function q9(q){return new RegExp(`^${k8(q)}$`)}function C8(q){let X=`${P8}T${k8(q)}`,Q=[];if(Q.push(q.local?"Z?":"Z"),q.offset)Q.push("([+-]\\d{2}:?\\d{2})");return X=`${X}(${Q.join("|")})`,new RegExp(`^${X}$`)}function X9(q,X){if((X==="v4"||!X)&&n1.test(q))return!0;if((X==="v6"||!X)&&o1.test(q))return!0;return!1}function Q9(q,X){if(!d1.test(q))return!1;try{let[Q]=q.split(".");if(!Q)return!1;let _=Q.replace(/-/g,"+").replace(/_/g,"/").padEnd(Q.length+(4-Q.length%4)%4,"="),$=JSON.parse(atob(_));if(typeof $!=="object"||$===null)return!1;if("typ"in $&&$?.typ!=="JWT")return!1;if(!$.alg)return!1;if(X&&$.alg!==X)return!1;return!0}catch{return!1}}function _9(q,X){if((X==="v4"||!X)&&s1.test(q))return!0;if((X==="v6"||!X)&&r1.test(q))return!0;return!1}function $9(q,X){let Q=(q.toString().split(".")[1]||"").length,_=(X.toString().split(".")[1]||"").length,$=Q>_?Q:_,J=Number.parseInt(q.toFixed($).replace(".","")),Y=Number.parseInt(X.toFixed($).replace(".",""));return J%Y/10**$}function oq(q){if(q instanceof C){let X={};for(let Q in q.shape){let _=q.shape[Q];X[Q]=t.create(oq(_))}return new C({...q._def,shape:()=>X})}else if(q instanceof a)return new a({...q._def,type:oq(q.element)});else if(q instanceof t)return t.create(oq(q.unwrap()));else if(q instanceof Kq)return Kq.create(oq(q.unwrap()));else if(q instanceof Gq)return Gq.create(q.items.map((X)=>oq(X)));else return q}function v6(q,X){let Q=Hq(q),_=Hq(X);if(q===X)return{valid:!0,data:q};else if(Q===j.object&&_===j.object){let $=I.objectKeys(X),J=I.objectKeys(q).filter((H)=>$.indexOf(H)!==-1),Y={...q,...X};for(let H of J){let W=v6(q[H],X[H]);if(!W.valid)return{valid:!1};Y[H]=W.data}return{valid:!0,data:Y}}else if(Q===j.array&&_===j.array){if(q.length!==X.length)return{valid:!1};let $=[];for(let J=0;J<q.length;J++){let Y=q[J],H=X[J],W=v6(Y,H);if(!W.valid)return{valid:!1};$.push(W.data)}return{valid:!0,data:$}}else if(Q===j.date&&_===j.date&&+q===+X)return{valid:!0,data:q};else return{valid:!1}}function f8(q,X){return new vq({values:q,typeName:w.ZodEnum,...S(X)})}function T8(q,X){let Q=typeof q==="function"?q(X):typeof q==="string"?{message:q}:q;return typeof Q==="string"?{message:Q}:Q}function Z8(q,X={},Q){if(q)return hq.create().superRefine((_,$)=>{let J=q(_);if(J instanceof Promise)return J.then((Y)=>{if(!Y){let H=T8(X,_),W=H.fatal??Q??!0;$.addIssue({code:"custom",...H,fatal:W})}});if(!J){let Y=T8(X,_),H=Y.fatal??Q??!0;$.addIssue({code:"custom",...Y,fatal:H})}return});return hq.create()}var R8=(q,X)=>{if(Eq(X))return{success:!0,data:X.value};else{if(!q.common.issues.length)throw Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;let Q=new i(q.common.issues);return this._error=Q,this._error}}}},h1,g1,l1,u1,m1,d1,c1,p1,i1="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",N6,n1,s1,o1,r1,a1,t1,P8="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",e1,r,Fq,Nq,aq,yq,F3,tq,eq,hq,Sq,Wq,N3,a,C,q3,Lq=(q)=>{if(q instanceof Q3)return Lq(q.schema);else if(q instanceof qq)return Lq(q.innerType());else if(q instanceof _3)return[q.value];else if(q instanceof vq)return q.options;else if(q instanceof $3)return I.objectValues(q.enum);else if(q instanceof J3)return Lq(q._def.innerType);else if(q instanceof tq)return[void 0];else if(q instanceof eq)return[null];else if(q instanceof t)return[void 0,...Lq(q.unwrap())];else if(q instanceof Kq)return[null,...Lq(q.unwrap())];else if(q instanceof p3)return Lq(q.unwrap());else if(q instanceof H3)return Lq(q.unwrap());else if(q instanceof Y3)return Lq(q._def.innerType);else return[]},c3,X3,Gq,v3,I3,gq,rq,Q3,_3,vq,$3,lq,qq,t,Kq,J3,Y3,R3,J9,p3,T3,H3,Y9,w,H9=(q,X={message:`Input not instance of ${q.name}`})=>Z8((Q)=>Q instanceof q,X),b8,x8,W9,G9,y8,z9,U9,M9,j9,V9,L9,K9,O9,A9,B9,D9,w9,E9,S9,F9,N9,v9,I9,R9,T9,P9,k9,C9,f9,Z9,b9,x9,y9,h9,g9=()=>b8().optional(),l9=()=>x8().optional(),u9=()=>y8().optional(),m9,d9;var h8=Z(()=>{l3();u3();I8();F6();E3();h1=/^c[^\s-]{8,}$/i,g1=/^[0-9a-z]+$/,l1=/^[0-9A-HJKMNP-TV-Z]{26}$/i,u1=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,m1=/^[a-z0-9_-]{21}$/i,d1=/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,c1=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,p1=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,n1=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,s1=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,o1=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,r1=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,a1=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,t1=/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,e1=new RegExp(`^${P8}$`);r=class r extends F{_parse(q){if(this._def.coerce)q.data=String(q.data);if(this._getType(q)!==j.string){let $=this._getOrReturnCtx(q);return V($,{code:M.invalid_type,expected:j.string,received:$.parsedType}),B}let Q=new l,_=void 0;for(let $ of this._def.checks)if($.kind==="min"){if(q.data.length<$.value)_=this._getOrReturnCtx(q,_),V(_,{code:M.too_small,minimum:$.value,type:"string",inclusive:!0,exact:!1,message:$.message}),Q.dirty()}else if($.kind==="max"){if(q.data.length>$.value)_=this._getOrReturnCtx(q,_),V(_,{code:M.too_big,maximum:$.value,type:"string",inclusive:!0,exact:!1,message:$.message}),Q.dirty()}else if($.kind==="length"){let J=q.data.length>$.value,Y=q.data.length<$.value;if(J||Y){if(_=this._getOrReturnCtx(q,_),J)V(_,{code:M.too_big,maximum:$.value,type:"string",inclusive:!0,exact:!0,message:$.message});else if(Y)V(_,{code:M.too_small,minimum:$.value,type:"string",inclusive:!0,exact:!0,message:$.message});Q.dirty()}}else if($.kind==="email"){if(!p1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"email",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="emoji"){if(!N6)N6=new RegExp(i1,"u");if(!N6.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"emoji",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="uuid"){if(!u1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"uuid",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="nanoid"){if(!m1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"nanoid",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="cuid"){if(!h1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"cuid",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="cuid2"){if(!g1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"cuid2",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="ulid"){if(!l1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"ulid",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="url")try{new URL(q.data)}catch{_=this._getOrReturnCtx(q,_),V(_,{validation:"url",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="regex"){if($.regex.lastIndex=0,!$.regex.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"regex",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="trim")q.data=q.data.trim();else if($.kind==="includes"){if(!q.data.includes($.value,$.position))_=this._getOrReturnCtx(q,_),V(_,{code:M.invalid_string,validation:{includes:$.value,position:$.position},message:$.message}),Q.dirty()}else if($.kind==="toLowerCase")q.data=q.data.toLowerCase();else if($.kind==="toUpperCase")q.data=q.data.toUpperCase();else if($.kind==="startsWith"){if(!q.data.startsWith($.value))_=this._getOrReturnCtx(q,_),V(_,{code:M.invalid_string,validation:{startsWith:$.value},message:$.message}),Q.dirty()}else if($.kind==="endsWith"){if(!q.data.endsWith($.value))_=this._getOrReturnCtx(q,_),V(_,{code:M.invalid_string,validation:{endsWith:$.value},message:$.message}),Q.dirty()}else if($.kind==="datetime"){if(!C8($).test(q.data))_=this._getOrReturnCtx(q,_),V(_,{code:M.invalid_string,validation:"datetime",message:$.message}),Q.dirty()}else if($.kind==="date"){if(!e1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{code:M.invalid_string,validation:"date",message:$.message}),Q.dirty()}else if($.kind==="time"){if(!q9($).test(q.data))_=this._getOrReturnCtx(q,_),V(_,{code:M.invalid_string,validation:"time",message:$.message}),Q.dirty()}else if($.kind==="duration"){if(!c1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"duration",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="ip"){if(!X9(q.data,$.version))_=this._getOrReturnCtx(q,_),V(_,{validation:"ip",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="jwt"){if(!Q9(q.data,$.alg))_=this._getOrReturnCtx(q,_),V(_,{validation:"jwt",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="cidr"){if(!_9(q.data,$.version))_=this._getOrReturnCtx(q,_),V(_,{validation:"cidr",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="base64"){if(!a1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"base64",code:M.invalid_string,message:$.message}),Q.dirty()}else if($.kind==="base64url"){if(!t1.test(q.data))_=this._getOrReturnCtx(q,_),V(_,{validation:"base64url",code:M.invalid_string,message:$.message}),Q.dirty()}else I.assertNever($);return{status:Q.value,value:q.data}}_regex(q,X,Q){return this.refinement((_)=>q.test(_),{validation:X,code:M.invalid_string,...K.errToObj(Q)})}_addCheck(q){return new r({...this._def,checks:[...this._def.checks,q]})}email(q){return this._addCheck({kind:"email",...K.errToObj(q)})}url(q){return this._addCheck({kind:"url",...K.errToObj(q)})}emoji(q){return this._addCheck({kind:"emoji",...K.errToObj(q)})}uuid(q){return this._addCheck({kind:"uuid",...K.errToObj(q)})}nanoid(q){return this._addCheck({kind:"nanoid",...K.errToObj(q)})}cuid(q){return this._addCheck({kind:"cuid",...K.errToObj(q)})}cuid2(q){return this._addCheck({kind:"cuid2",...K.errToObj(q)})}ulid(q){return this._addCheck({kind:"ulid",...K.errToObj(q)})}base64(q){return this._addCheck({kind:"base64",...K.errToObj(q)})}base64url(q){return this._addCheck({kind:"base64url",...K.errToObj(q)})}jwt(q){return this._addCheck({kind:"jwt",...K.errToObj(q)})}ip(q){return this._addCheck({kind:"ip",...K.errToObj(q)})}cidr(q){return this._addCheck({kind:"cidr",...K.errToObj(q)})}datetime(q){if(typeof q==="string")return this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:q});return this._addCheck({kind:"datetime",precision:typeof q?.precision>"u"?null:q?.precision,offset:q?.offset??!1,local:q?.local??!1,...K.errToObj(q?.message)})}date(q){return this._addCheck({kind:"date",message:q})}time(q){if(typeof q==="string")return this._addCheck({kind:"time",precision:null,message:q});return this._addCheck({kind:"time",precision:typeof q?.precision>"u"?null:q?.precision,...K.errToObj(q?.message)})}duration(q){return this._addCheck({kind:"duration",...K.errToObj(q)})}regex(q,X){return this._addCheck({kind:"regex",regex:q,...K.errToObj(X)})}includes(q,X){return this._addCheck({kind:"includes",value:q,position:X?.position,...K.errToObj(X?.message)})}startsWith(q,X){return this._addCheck({kind:"startsWith",value:q,...K.errToObj(X)})}endsWith(q,X){return this._addCheck({kind:"endsWith",value:q,...K.errToObj(X)})}min(q,X){return this._addCheck({kind:"min",value:q,...K.errToObj(X)})}max(q,X){return this._addCheck({kind:"max",value:q,...K.errToObj(X)})}length(q,X){return this._addCheck({kind:"length",value:q,...K.errToObj(X)})}nonempty(q){return this.min(1,K.errToObj(q))}trim(){return new r({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new r({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new r({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find((q)=>q.kind==="datetime")}get isDate(){return!!this._def.checks.find((q)=>q.kind==="date")}get isTime(){return!!this._def.checks.find((q)=>q.kind==="time")}get isDuration(){return!!this._def.checks.find((q)=>q.kind==="duration")}get isEmail(){return!!this._def.checks.find((q)=>q.kind==="email")}get isURL(){return!!this._def.checks.find((q)=>q.kind==="url")}get isEmoji(){return!!this._def.checks.find((q)=>q.kind==="emoji")}get isUUID(){return!!this._def.checks.find((q)=>q.kind==="uuid")}get isNANOID(){return!!this._def.checks.find((q)=>q.kind==="nanoid")}get isCUID(){return!!this._def.checks.find((q)=>q.kind==="cuid")}get isCUID2(){return!!this._def.checks.find((q)=>q.kind==="cuid2")}get isULID(){return!!this._def.checks.find((q)=>q.kind==="ulid")}get isIP(){return!!this._def.checks.find((q)=>q.kind==="ip")}get isCIDR(){return!!this._def.checks.find((q)=>q.kind==="cidr")}get isBase64(){return!!this._def.checks.find((q)=>q.kind==="base64")}get isBase64url(){return!!this._def.checks.find((q)=>q.kind==="base64url")}get minLength(){let q=null;for(let X of this._def.checks)if(X.kind==="min"){if(q===null||X.value>q)q=X.value}return q}get maxLength(){let q=null;for(let X of this._def.checks)if(X.kind==="max"){if(q===null||X.value<q)q=X.value}return q}};r.create=(q)=>{return new r({checks:[],typeName:w.ZodString,coerce:q?.coerce??!1,...S(q)})};Fq=class Fq extends F{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(q){if(this._def.coerce)q.data=Number(q.data);if(this._getType(q)!==j.number){let $=this._getOrReturnCtx(q);return V($,{code:M.invalid_type,expected:j.number,received:$.parsedType}),B}let Q=void 0,_=new l;for(let $ of this._def.checks)if($.kind==="int"){if(!I.isInteger(q.data))Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.invalid_type,expected:"integer",received:"float",message:$.message}),_.dirty()}else if($.kind==="min"){if($.inclusive?q.data<$.value:q.data<=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.too_small,minimum:$.value,type:"number",inclusive:$.inclusive,exact:!1,message:$.message}),_.dirty()}else if($.kind==="max"){if($.inclusive?q.data>$.value:q.data>=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.too_big,maximum:$.value,type:"number",inclusive:$.inclusive,exact:!1,message:$.message}),_.dirty()}else if($.kind==="multipleOf"){if($9(q.data,$.value)!==0)Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.not_multiple_of,multipleOf:$.value,message:$.message}),_.dirty()}else if($.kind==="finite"){if(!Number.isFinite(q.data))Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.not_finite,message:$.message}),_.dirty()}else I.assertNever($);return{status:_.value,value:q.data}}gte(q,X){return this.setLimit("min",q,!0,K.toString(X))}gt(q,X){return this.setLimit("min",q,!1,K.toString(X))}lte(q,X){return this.setLimit("max",q,!0,K.toString(X))}lt(q,X){return this.setLimit("max",q,!1,K.toString(X))}setLimit(q,X,Q,_){return new Fq({...this._def,checks:[...this._def.checks,{kind:q,value:X,inclusive:Q,message:K.toString(_)}]})}_addCheck(q){return new Fq({...this._def,checks:[...this._def.checks,q]})}int(q){return this._addCheck({kind:"int",message:K.toString(q)})}positive(q){return this._addCheck({kind:"min",value:0,inclusive:!1,message:K.toString(q)})}negative(q){return this._addCheck({kind:"max",value:0,inclusive:!1,message:K.toString(q)})}nonpositive(q){return this._addCheck({kind:"max",value:0,inclusive:!0,message:K.toString(q)})}nonnegative(q){return this._addCheck({kind:"min",value:0,inclusive:!0,message:K.toString(q)})}multipleOf(q,X){return this._addCheck({kind:"multipleOf",value:q,message:K.toString(X)})}finite(q){return this._addCheck({kind:"finite",message:K.toString(q)})}safe(q){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:K.toString(q)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:K.toString(q)})}get minValue(){let q=null;for(let X of this._def.checks)if(X.kind==="min"){if(q===null||X.value>q)q=X.value}return q}get maxValue(){let q=null;for(let X of this._def.checks)if(X.kind==="max"){if(q===null||X.value<q)q=X.value}return q}get isInt(){return!!this._def.checks.find((q)=>q.kind==="int"||q.kind==="multipleOf"&&I.isInteger(q.value))}get isFinite(){let q=null,X=null;for(let Q of this._def.checks)if(Q.kind==="finite"||Q.kind==="int"||Q.kind==="multipleOf")return!0;else if(Q.kind==="min"){if(X===null||Q.value>X)X=Q.value}else if(Q.kind==="max"){if(q===null||Q.value<q)q=Q.value}return Number.isFinite(X)&&Number.isFinite(q)}};Fq.create=(q)=>{return new Fq({checks:[],typeName:w.ZodNumber,coerce:q?.coerce||!1,...S(q)})};Nq=class Nq extends F{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte}_parse(q){if(this._def.coerce)try{q.data=BigInt(q.data)}catch{return this._getInvalidInput(q)}if(this._getType(q)!==j.bigint)return this._getInvalidInput(q);let Q=void 0,_=new l;for(let $ of this._def.checks)if($.kind==="min"){if($.inclusive?q.data<$.value:q.data<=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.too_small,type:"bigint",minimum:$.value,inclusive:$.inclusive,message:$.message}),_.dirty()}else if($.kind==="max"){if($.inclusive?q.data>$.value:q.data>=$.value)Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.too_big,type:"bigint",maximum:$.value,inclusive:$.inclusive,message:$.message}),_.dirty()}else if($.kind==="multipleOf"){if(q.data%$.value!==BigInt(0))Q=this._getOrReturnCtx(q,Q),V(Q,{code:M.not_multiple_of,multipleOf:$.value,message:$.message}),_.dirty()}else I.assertNever($);return{status:_.value,value:q.data}}_getInvalidInput(q){let X=this._getOrReturnCtx(q);return V(X,{code:M.invalid_type,expected:j.bigint,received:X.parsedType}),B}gte(q,X){return this.setLimit("min",q,!0,K.toString(X))}gt(q,X){return this.setLimit("min",q,!1,K.toString(X))}lte(q,X){return this.setLimit("max",q,!0,K.toString(X))}lt(q,X){return this.setLimit("max",q,!1,K.toString(X))}setLimit(q,X,Q,_){return new Nq({...this._def,checks:[...this._def.checks,{kind:q,value:X,inclusive:Q,message:K.toString(_)}]})}_addCheck(q){return new Nq({...this._def,checks:[...this._def.checks,q]})}positive(q){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:K.toString(q)})}negative(q){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:K.toString(q)})}nonpositive(q){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:K.toString(q)})}nonnegative(q){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:K.toString(q)})}multipleOf(q,X){return this._addCheck({kind:"multipleOf",value:q,message:K.toString(X)})}get minValue(){let q=null;for(let X of this._def.checks)if(X.kind==="min"){if(q===null||X.value>q)q=X.value}return q}get maxValue(){let q=null;for(let X of this._def.checks)if(X.kind==="max"){if(q===null||X.value<q)q=X.value}return q}};Nq.create=(q)=>{return new Nq({checks:[],typeName:w.ZodBigInt,coerce:q?.coerce??!1,...S(q)})};aq=class aq extends F{_parse(q){if(this._def.coerce)q.data=Boolean(q.data);if(this._getType(q)!==j.boolean){let Q=this._getOrReturnCtx(q);return V(Q,{code:M.invalid_type,expected:j.boolean,received:Q.parsedType}),B}return m(q.data)}};aq.create=(q)=>{return new aq({typeName:w.ZodBoolean,coerce:q?.coerce||!1,...S(q)})};yq=class yq extends F{_parse(q){if(this._def.coerce)q.data=new Date(q.data);if(this._getType(q)!==j.date){let $=this._getOrReturnCtx(q);return V($,{code:M.invalid_type,expected:j.date,received:$.parsedType}),B}if(Number.isNaN(q.data.getTime())){let $=this._getOrReturnCtx(q);return V($,{code:M.invalid_date}),B}let Q=new l,_=void 0;for(let $ of this._def.checks)if($.kind==="min"){if(q.data.getTime()<$.value)_=this._getOrReturnCtx(q,_),V(_,{code:M.too_small,message:$.message,inclusive:!0,exact:!1,minimum:$.value,type:"date"}),Q.dirty()}else if($.kind==="max"){if(q.data.getTime()>$.value)_=this._getOrReturnCtx(q,_),V(_,{code:M.too_big,message:$.message,inclusive:!0,exact:!1,maximum:$.value,type:"date"}),Q.dirty()}else I.assertNever($);return{status:Q.value,value:new Date(q.data.getTime())}}_addCheck(q){return new yq({...this._def,checks:[...this._def.checks,q]})}min(q,X){return this._addCheck({kind:"min",value:q.getTime(),message:K.toString(X)})}max(q,X){return this._addCheck({kind:"max",value:q.getTime(),message:K.toString(X)})}get minDate(){let q=null;for(let X of this._def.checks)if(X.kind==="min"){if(q===null||X.value>q)q=X.value}return q!=null?new Date(q):null}get maxDate(){let q=null;for(let X of this._def.checks)if(X.kind==="max"){if(q===null||X.value<q)q=X.value}return q!=null?new Date(q):null}};yq.create=(q)=>{return new yq({checks:[],coerce:q?.coerce||!1,typeName:w.ZodDate,...S(q)})};F3=class F3 extends F{_parse(q){if(this._getType(q)!==j.symbol){let Q=this._getOrReturnCtx(q);return V(Q,{code:M.invalid_type,expected:j.symbol,received:Q.parsedType}),B}return m(q.data)}};F3.create=(q)=>{return new F3({typeName:w.ZodSymbol,...S(q)})};tq=class tq extends F{_parse(q){if(this._getType(q)!==j.undefined){let Q=this._getOrReturnCtx(q);return V(Q,{code:M.invalid_type,expected:j.undefined,received:Q.parsedType}),B}return m(q.data)}};tq.create=(q)=>{return new tq({typeName:w.ZodUndefined,...S(q)})};eq=class eq extends F{_parse(q){if(this._getType(q)!==j.null){let Q=this._getOrReturnCtx(q);return V(Q,{code:M.invalid_type,expected:j.null,received:Q.parsedType}),B}return m(q.data)}};eq.create=(q)=>{return new eq({typeName:w.ZodNull,...S(q)})};hq=class hq extends F{constructor(){super(...arguments);this._any=!0}_parse(q){return m(q.data)}};hq.create=(q)=>{return new hq({typeName:w.ZodAny,...S(q)})};Sq=class Sq extends F{constructor(){super(...arguments);this._unknown=!0}_parse(q){return m(q.data)}};Sq.create=(q)=>{return new Sq({typeName:w.ZodUnknown,...S(q)})};Wq=class Wq extends F{_parse(q){let X=this._getOrReturnCtx(q);return V(X,{code:M.invalid_type,expected:j.never,received:X.parsedType}),B}};Wq.create=(q)=>{return new Wq({typeName:w.ZodNever,...S(q)})};N3=class N3 extends F{_parse(q){if(this._getType(q)!==j.undefined){let Q=this._getOrReturnCtx(q);return V(Q,{code:M.invalid_type,expected:j.void,received:Q.parsedType}),B}return m(q.data)}};N3.create=(q)=>{return new N3({typeName:w.ZodVoid,...S(q)})};a=class a extends F{_parse(q){let{ctx:X,status:Q}=this._processInputParams(q),_=this._def;if(X.parsedType!==j.array)return V(X,{code:M.invalid_type,expected:j.array,received:X.parsedType}),B;if(_.exactLength!==null){let J=X.data.length>_.exactLength.value,Y=X.data.length<_.exactLength.value;if(J||Y)V(X,{code:J?M.too_big:M.too_small,minimum:Y?_.exactLength.value:void 0,maximum:J?_.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:_.exactLength.message}),Q.dirty()}if(_.minLength!==null){if(X.data.length<_.minLength.value)V(X,{code:M.too_small,minimum:_.minLength.value,type:"array",inclusive:!0,exact:!1,message:_.minLength.message}),Q.dirty()}if(_.maxLength!==null){if(X.data.length>_.maxLength.value)V(X,{code:M.too_big,maximum:_.maxLength.value,type:"array",inclusive:!0,exact:!1,message:_.maxLength.message}),Q.dirty()}if(X.common.async)return Promise.all([...X.data].map((J,Y)=>{return _.type._parseAsync(new e(X,J,X.path,Y))})).then((J)=>{return l.mergeArray(Q,J)});let $=[...X.data].map((J,Y)=>{return _.type._parseSync(new e(X,J,X.path,Y))});return l.mergeArray(Q,$)}get element(){return this._def.type}min(q,X){return new a({...this._def,minLength:{value:q,message:K.toString(X)}})}max(q,X){return new a({...this._def,maxLength:{value:q,message:K.toString(X)}})}length(q,X){return new a({...this._def,exactLength:{value:q,message:K.toString(X)}})}nonempty(q){return this.min(1,q)}};a.create=(q,X)=>{return new a({type:q,minLength:null,maxLength:null,exactLength:null,typeName:w.ZodArray,...S(X)})};C=class C extends F{constructor(){super(...arguments);this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;let q=this._def.shape(),X=I.objectKeys(q);return this._cached={shape:q,keys:X},this._cached}_parse(q){if(this._getType(q)!==j.object){let W=this._getOrReturnCtx(q);return V(W,{code:M.invalid_type,expected:j.object,received:W.parsedType}),B}let{status:Q,ctx:_}=this._processInputParams(q),{shape:$,keys:J}=this._getCached(),Y=[];if(!(this._def.catchall instanceof Wq&&this._def.unknownKeys==="strip")){for(let W in _.data)if(!J.includes(W))Y.push(W)}let H=[];for(let W of J){let G=$[W],z=_.data[W];H.push({key:{status:"valid",value:W},value:G._parse(new e(_,z,_.path,W)),alwaysSet:W in _.data})}if(this._def.catchall instanceof Wq){let W=this._def.unknownKeys;if(W==="passthrough")for(let G of Y)H.push({key:{status:"valid",value:G},value:{status:"valid",value:_.data[G]}});else if(W==="strict"){if(Y.length>0)V(_,{code:M.unrecognized_keys,keys:Y}),Q.dirty()}else if(W==="strip");else throw Error("Internal ZodObject error: invalid unknownKeys value.")}else{let W=this._def.catchall;for(let G of Y){let z=_.data[G];H.push({key:{status:"valid",value:G},value:W._parse(new e(_,z,_.path,G)),alwaysSet:G in _.data})}}if(_.common.async)return Promise.resolve().then(async()=>{let W=[];for(let G of H){let z=await G.key,U=await G.value;W.push({key:z,value:U,alwaysSet:G.alwaysSet})}return W}).then((W)=>{return l.mergeObjectSync(Q,W)});else return l.mergeObjectSync(Q,H)}get shape(){return this._def.shape()}strict(q){return K.errToObj,new C({...this._def,unknownKeys:"strict",...q!==void 0?{errorMap:(X,Q)=>{let _=this._def.errorMap?.(X,Q).message??Q.defaultError;if(X.code==="unrecognized_keys")return{message:K.errToObj(q).message??_};return{message:_}}}:{}})}strip(){return new C({...this._def,unknownKeys:"strip"})}passthrough(){return new C({...this._def,unknownKeys:"passthrough"})}extend(q){return new C({...this._def,shape:()=>({...this._def.shape(),...q})})}merge(q){return new C({unknownKeys:q._def.unknownKeys,catchall:q._def.catchall,shape:()=>({...this._def.shape(),...q._def.shape()}),typeName:w.ZodObject})}setKey(q,X){return this.augment({[q]:X})}catchall(q){return new C({...this._def,catchall:q})}pick(q){let X={};for(let Q of I.objectKeys(q))if(q[Q]&&this.shape[Q])X[Q]=this.shape[Q];return new C({...this._def,shape:()=>X})}omit(q){let X={};for(let Q of I.objectKeys(this.shape))if(!q[Q])X[Q]=this.shape[Q];return new C({...this._def,shape:()=>X})}deepPartial(){return oq(this)}partial(q){let X={};for(let Q of I.objectKeys(this.shape)){let _=this.shape[Q];if(q&&!q[Q])X[Q]=_;else X[Q]=_.optional()}return new C({...this._def,shape:()=>X})}required(q){let X={};for(let Q of I.objectKeys(this.shape))if(q&&!q[Q])X[Q]=this.shape[Q];else{let $=this.shape[Q];while($ instanceof t)$=$._def.innerType;X[Q]=$}return new C({...this._def,shape:()=>X})}keyof(){return f8(I.objectKeys(this.shape))}};C.create=(q,X)=>{return new C({shape:()=>q,unknownKeys:"strip",catchall:Wq.create(),typeName:w.ZodObject,...S(X)})};C.strictCreate=(q,X)=>{return new C({shape:()=>q,unknownKeys:"strict",catchall:Wq.create(),typeName:w.ZodObject,...S(X)})};C.lazycreate=(q,X)=>{return new C({shape:q,unknownKeys:"strip",catchall:Wq.create(),typeName:w.ZodObject,...S(X)})};q3=class q3 extends F{_parse(q){let{ctx:X}=this._processInputParams(q),Q=this._def.options;function _($){for(let Y of $)if(Y.result.status==="valid")return Y.result;for(let Y of $)if(Y.result.status==="dirty")return X.common.issues.push(...Y.ctx.common.issues),Y.result;let J=$.map((Y)=>new i(Y.ctx.common.issues));return V(X,{code:M.invalid_union,unionErrors:J}),B}if(X.common.async)return Promise.all(Q.map(async($)=>{let J={...X,common:{...X.common,issues:[]},parent:null};return{result:await $._parseAsync({data:X.data,path:X.path,parent:J}),ctx:J}})).then(_);else{let $=void 0,J=[];for(let H of Q){let W={...X,common:{...X.common,issues:[]},parent:null},G=H._parseSync({data:X.data,path:X.path,parent:W});if(G.status==="valid")return G;else if(G.status==="dirty"&&!$)$={result:G,ctx:W};if(W.common.issues.length)J.push(W.common.issues)}if($)return X.common.issues.push(...$.ctx.common.issues),$.result;let Y=J.map((H)=>new i(H));return V(X,{code:M.invalid_union,unionErrors:Y}),B}}get options(){return this._def.options}};q3.create=(q,X)=>{return new q3({options:q,typeName:w.ZodUnion,...S(X)})};c3=class c3 extends F{_parse(q){let{ctx:X}=this._processInputParams(q);if(X.parsedType!==j.object)return V(X,{code:M.invalid_type,expected:j.object,received:X.parsedType}),B;let Q=this.discriminator,_=X.data[Q],$=this.optionsMap.get(_);if(!$)return V(X,{code:M.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[Q]}),B;if(X.common.async)return $._parseAsync({data:X.data,path:X.path,parent:X});else return $._parseSync({data:X.data,path:X.path,parent:X})}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(q,X,Q){let _=new Map;for(let $ of X){let J=Lq($.shape[q]);if(!J.length)throw Error(`A discriminator value for key \`${q}\` could not be extracted from all schema options`);for(let Y of J){if(_.has(Y))throw Error(`Discriminator property ${String(q)} has duplicate value ${String(Y)}`);_.set(Y,$)}}return new c3({typeName:w.ZodDiscriminatedUnion,discriminator:q,options:X,optionsMap:_,...S(Q)})}};X3=class X3 extends F{_parse(q){let{status:X,ctx:Q}=this._processInputParams(q),_=($,J)=>{if(m3($)||m3(J))return B;let Y=v6($.value,J.value);if(!Y.valid)return V(Q,{code:M.invalid_intersection_types}),B;if(d3($)||d3(J))X.dirty();return{status:X.value,value:Y.data}};if(Q.common.async)return Promise.all([this._def.left._parseAsync({data:Q.data,path:Q.path,parent:Q}),this._def.right._parseAsync({data:Q.data,path:Q.path,parent:Q})]).then(([$,J])=>_($,J));else return _(this._def.left._parseSync({data:Q.data,path:Q.path,parent:Q}),this._def.right._parseSync({data:Q.data,path:Q.path,parent:Q}))}};X3.create=(q,X,Q)=>{return new X3({left:q,right:X,typeName:w.ZodIntersection,...S(Q)})};Gq=class Gq extends F{_parse(q){let{status:X,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==j.array)return V(Q,{code:M.invalid_type,expected:j.array,received:Q.parsedType}),B;if(Q.data.length<this._def.items.length)return V(Q,{code:M.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),B;if(!this._def.rest&&Q.data.length>this._def.items.length)V(Q,{code:M.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),X.dirty();let $=[...Q.data].map((J,Y)=>{let H=this._def.items[Y]||this._def.rest;if(!H)return null;return H._parse(new e(Q,J,Q.path,Y))}).filter((J)=>!!J);if(Q.common.async)return Promise.all($).then((J)=>{return l.mergeArray(X,J)});else return l.mergeArray(X,$)}get items(){return this._def.items}rest(q){return new Gq({...this._def,rest:q})}};Gq.create=(q,X)=>{if(!Array.isArray(q))throw Error("You must pass an array of schemas to z.tuple([ ... ])");return new Gq({items:q,typeName:w.ZodTuple,rest:null,...S(X)})};v3=class v3 extends F{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(q){let{status:X,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==j.object)return V(Q,{code:M.invalid_type,expected:j.object,received:Q.parsedType}),B;let _=[],$=this._def.keyType,J=this._def.valueType;for(let Y in Q.data)_.push({key:$._parse(new e(Q,Y,Q.path,Y)),value:J._parse(new e(Q,Q.data[Y],Q.path,Y)),alwaysSet:Y in Q.data});if(Q.common.async)return l.mergeObjectAsync(X,_);else return l.mergeObjectSync(X,_)}get element(){return this._def.valueType}static create(q,X,Q){if(X instanceof F)return new v3({keyType:q,valueType:X,typeName:w.ZodRecord,...S(Q)});return new v3({keyType:r.create(),valueType:q,typeName:w.ZodRecord,...S(X)})}};I3=class I3 extends F{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(q){let{status:X,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==j.map)return V(Q,{code:M.invalid_type,expected:j.map,received:Q.parsedType}),B;let _=this._def.keyType,$=this._def.valueType,J=[...Q.data.entries()].map(([Y,H],W)=>{return{key:_._parse(new e(Q,Y,Q.path,[W,"key"])),value:$._parse(new e(Q,H,Q.path,[W,"value"]))}});if(Q.common.async){let Y=new Map;return Promise.resolve().then(async()=>{for(let H of J){let W=await H.key,G=await H.value;if(W.status==="aborted"||G.status==="aborted")return B;if(W.status==="dirty"||G.status==="dirty")X.dirty();Y.set(W.value,G.value)}return{status:X.value,value:Y}})}else{let Y=new Map;for(let H of J){let{key:W,value:G}=H;if(W.status==="aborted"||G.status==="aborted")return B;if(W.status==="dirty"||G.status==="dirty")X.dirty();Y.set(W.value,G.value)}return{status:X.value,value:Y}}}};I3.create=(q,X,Q)=>{return new I3({valueType:X,keyType:q,typeName:w.ZodMap,...S(Q)})};gq=class gq extends F{_parse(q){let{status:X,ctx:Q}=this._processInputParams(q);if(Q.parsedType!==j.set)return V(Q,{code:M.invalid_type,expected:j.set,received:Q.parsedType}),B;let _=this._def;if(_.minSize!==null){if(Q.data.size<_.minSize.value)V(Q,{code:M.too_small,minimum:_.minSize.value,type:"set",inclusive:!0,exact:!1,message:_.minSize.message}),X.dirty()}if(_.maxSize!==null){if(Q.data.size>_.maxSize.value)V(Q,{code:M.too_big,maximum:_.maxSize.value,type:"set",inclusive:!0,exact:!1,message:_.maxSize.message}),X.dirty()}let $=this._def.valueType;function J(H){let W=new Set;for(let G of H){if(G.status==="aborted")return B;if(G.status==="dirty")X.dirty();W.add(G.value)}return{status:X.value,value:W}}let Y=[...Q.data.values()].map((H,W)=>$._parse(new e(Q,H,Q.path,W)));if(Q.common.async)return Promise.all(Y).then((H)=>J(H));else return J(Y)}min(q,X){return new gq({...this._def,minSize:{value:q,message:K.toString(X)}})}max(q,X){return new gq({...this._def,maxSize:{value:q,message:K.toString(X)}})}size(q,X){return this.min(q,X).max(q,X)}nonempty(q){return this.min(1,q)}};gq.create=(q,X)=>{return new gq({valueType:q,minSize:null,maxSize:null,typeName:w.ZodSet,...S(X)})};rq=class rq extends F{constructor(){super(...arguments);this.validate=this.implement}_parse(q){let{ctx:X}=this._processInputParams(q);if(X.parsedType!==j.function)return V(X,{code:M.invalid_type,expected:j.function,received:X.parsedType}),B;function Q(Y,H){return S3({data:Y,path:X.path,errorMaps:[X.common.contextualErrorMap,X.schemaErrorMap,nq(),Vq].filter((W)=>!!W),issueData:{code:M.invalid_arguments,argumentsError:H}})}function _(Y,H){return S3({data:Y,path:X.path,errorMaps:[X.common.contextualErrorMap,X.schemaErrorMap,nq(),Vq].filter((W)=>!!W),issueData:{code:M.invalid_return_type,returnTypeError:H}})}let $={errorMap:X.common.contextualErrorMap},J=X.data;if(this._def.returns instanceof lq){let Y=this;return m(async function(...H){let W=new i([]),G=await Y._def.args.parseAsync(H,$).catch((L)=>{throw W.addIssue(Q(H,L)),W}),z=await Reflect.apply(J,this,G);return await Y._def.returns._def.type.parseAsync(z,$).catch((L)=>{throw W.addIssue(_(z,L)),W})})}else{let Y=this;return m(function(...H){let W=Y._def.args.safeParse(H,$);if(!W.success)throw new i([Q(H,W.error)]);let G=Reflect.apply(J,this,W.data),z=Y._def.returns.safeParse(G,$);if(!z.success)throw new i([_(G,z.error)]);return z.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...q){return new rq({...this._def,args:Gq.create(q).rest(Sq.create())})}returns(q){return new rq({...this._def,returns:q})}implement(q){return this.parse(q)}strictImplement(q){return this.parse(q)}static create(q,X,Q){return new rq({args:q?q:Gq.create([]).rest(Sq.create()),returns:X||Sq.create(),typeName:w.ZodFunction,...S(Q)})}};Q3=class Q3 extends F{get schema(){return this._def.getter()}_parse(q){let{ctx:X}=this._processInputParams(q);return this._def.getter()._parse({data:X.data,path:X.path,parent:X})}};Q3.create=(q,X)=>{return new Q3({getter:q,typeName:w.ZodLazy,...S(X)})};_3=class _3 extends F{_parse(q){if(q.data!==this._def.value){let X=this._getOrReturnCtx(q);return V(X,{received:X.data,code:M.invalid_literal,expected:this._def.value}),B}return{status:"valid",value:q.data}}get value(){return this._def.value}};_3.create=(q,X)=>{return new _3({value:q,typeName:w.ZodLiteral,...S(X)})};vq=class vq extends F{_parse(q){if(typeof q.data!=="string"){let X=this._getOrReturnCtx(q),Q=this._def.values;return V(X,{expected:I.joinValues(Q),received:X.parsedType,code:M.invalid_type}),B}if(!this._cache)this._cache=new Set(this._def.values);if(!this._cache.has(q.data)){let X=this._getOrReturnCtx(q),Q=this._def.values;return V(X,{received:X.data,code:M.invalid_enum_value,options:Q}),B}return m(q.data)}get options(){return this._def.values}get enum(){let q={};for(let X of this._def.values)q[X]=X;return q}get Values(){let q={};for(let X of this._def.values)q[X]=X;return q}get Enum(){let q={};for(let X of this._def.values)q[X]=X;return q}extract(q,X=this._def){return vq.create(q,{...this._def,...X})}exclude(q,X=this._def){return vq.create(this.options.filter((Q)=>!q.includes(Q)),{...this._def,...X})}};vq.create=f8;$3=class $3 extends F{_parse(q){let X=I.getValidEnumValues(this._def.values),Q=this._getOrReturnCtx(q);if(Q.parsedType!==j.string&&Q.parsedType!==j.number){let _=I.objectValues(X);return V(Q,{expected:I.joinValues(_),received:Q.parsedType,code:M.invalid_type}),B}if(!this._cache)this._cache=new Set(I.getValidEnumValues(this._def.values));if(!this._cache.has(q.data)){let _=I.objectValues(X);return V(Q,{received:Q.data,code:M.invalid_enum_value,options:_}),B}return m(q.data)}get enum(){return this._def.values}};$3.create=(q,X)=>{return new $3({values:q,typeName:w.ZodNativeEnum,...S(X)})};lq=class lq extends F{unwrap(){return this._def.type}_parse(q){let{ctx:X}=this._processInputParams(q);if(X.parsedType!==j.promise&&X.common.async===!1)return V(X,{code:M.invalid_type,expected:j.promise,received:X.parsedType}),B;let Q=X.parsedType===j.promise?X.data:Promise.resolve(X.data);return m(Q.then((_)=>{return this._def.type.parseAsync(_,{path:X.path,errorMap:X.common.contextualErrorMap})}))}};lq.create=(q,X)=>{return new lq({type:q,typeName:w.ZodPromise,...S(X)})};qq=class qq extends F{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===w.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(q){let{status:X,ctx:Q}=this._processInputParams(q),_=this._def.effect||null,$={addIssue:(J)=>{if(V(Q,J),J.fatal)X.abort();else X.dirty()},get path(){return Q.path}};if($.addIssue=$.addIssue.bind($),_.type==="preprocess"){let J=_.transform(Q.data,$);if(Q.common.async)return Promise.resolve(J).then(async(Y)=>{if(X.value==="aborted")return B;let H=await this._def.schema._parseAsync({data:Y,path:Q.path,parent:Q});if(H.status==="aborted")return B;if(H.status==="dirty")return xq(H.value);if(X.value==="dirty")return xq(H.value);return H});else{if(X.value==="aborted")return B;let Y=this._def.schema._parseSync({data:J,path:Q.path,parent:Q});if(Y.status==="aborted")return B;if(Y.status==="dirty")return xq(Y.value);if(X.value==="dirty")return xq(Y.value);return Y}}if(_.type==="refinement"){let J=(Y)=>{let H=_.refinement(Y,$);if(Q.common.async)return Promise.resolve(H);if(H instanceof Promise)throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return Y};if(Q.common.async===!1){let Y=this._def.schema._parseSync({data:Q.data,path:Q.path,parent:Q});if(Y.status==="aborted")return B;if(Y.status==="dirty")X.dirty();return J(Y.value),{status:X.value,value:Y.value}}else return this._def.schema._parseAsync({data:Q.data,path:Q.path,parent:Q}).then((Y)=>{if(Y.status==="aborted")return B;if(Y.status==="dirty")X.dirty();return J(Y.value).then(()=>{return{status:X.value,value:Y.value}})})}if(_.type==="transform")if(Q.common.async===!1){let J=this._def.schema._parseSync({data:Q.data,path:Q.path,parent:Q});if(!Eq(J))return B;let Y=_.transform(J.value,$);if(Y instanceof Promise)throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:X.value,value:Y}}else return this._def.schema._parseAsync({data:Q.data,path:Q.path,parent:Q}).then((J)=>{if(!Eq(J))return B;return Promise.resolve(_.transform(J.value,$)).then((Y)=>({status:X.value,value:Y}))});I.assertNever(_)}};qq.create=(q,X,Q)=>{return new qq({schema:q,typeName:w.ZodEffects,effect:X,...S(Q)})};qq.createWithPreprocess=(q,X,Q)=>{return new qq({schema:X,effect:{type:"preprocess",transform:q},typeName:w.ZodEffects,...S(Q)})};t=class t extends F{_parse(q){if(this._getType(q)===j.undefined)return m(void 0);return this._def.innerType._parse(q)}unwrap(){return this._def.innerType}};t.create=(q,X)=>{return new t({innerType:q,typeName:w.ZodOptional,...S(X)})};Kq=class Kq extends F{_parse(q){if(this._getType(q)===j.null)return m(null);return this._def.innerType._parse(q)}unwrap(){return this._def.innerType}};Kq.create=(q,X)=>{return new Kq({innerType:q,typeName:w.ZodNullable,...S(X)})};J3=class J3 extends F{_parse(q){let{ctx:X}=this._processInputParams(q),Q=X.data;if(X.parsedType===j.undefined)Q=this._def.defaultValue();return this._def.innerType._parse({data:Q,path:X.path,parent:X})}removeDefault(){return this._def.innerType}};J3.create=(q,X)=>{return new J3({innerType:q,typeName:w.ZodDefault,defaultValue:typeof X.default==="function"?X.default:()=>X.default,...S(X)})};Y3=class Y3 extends F{_parse(q){let{ctx:X}=this._processInputParams(q),Q={...X,common:{...X.common,issues:[]}},_=this._def.innerType._parse({data:Q.data,path:Q.path,parent:{...Q}});if(sq(_))return _.then(($)=>{return{status:"valid",value:$.status==="valid"?$.value:this._def.catchValue({get error(){return new i(Q.common.issues)},input:Q.data})}});else return{status:"valid",value:_.status==="valid"?_.value:this._def.catchValue({get error(){return new i(Q.common.issues)},input:Q.data})}}removeCatch(){return this._def.innerType}};Y3.create=(q,X)=>{return new Y3({innerType:q,typeName:w.ZodCatch,catchValue:typeof X.catch==="function"?X.catch:()=>X.catch,...S(X)})};R3=class R3 extends F{_parse(q){if(this._getType(q)!==j.nan){let Q=this._getOrReturnCtx(q);return V(Q,{code:M.invalid_type,expected:j.nan,received:Q.parsedType}),B}return{status:"valid",value:q.data}}};R3.create=(q)=>{return new R3({typeName:w.ZodNaN,...S(q)})};J9=Symbol("zod_brand");p3=class p3 extends F{_parse(q){let{ctx:X}=this._processInputParams(q),Q=X.data;return this._def.type._parse({data:Q,path:X.path,parent:X})}unwrap(){return this._def.type}};T3=class T3 extends F{_parse(q){let{status:X,ctx:Q}=this._processInputParams(q);if(Q.common.async)return(async()=>{let $=await this._def.in._parseAsync({data:Q.data,path:Q.path,parent:Q});if($.status==="aborted")return B;if($.status==="dirty")return X.dirty(),xq($.value);else return this._def.out._parseAsync({data:$.value,path:Q.path,parent:Q})})();else{let _=this._def.in._parseSync({data:Q.data,path:Q.path,parent:Q});if(_.status==="aborted")return B;if(_.status==="dirty")return X.dirty(),{status:"dirty",value:_.value};else return this._def.out._parseSync({data:_.value,path:Q.path,parent:Q})}}static create(q,X){return new T3({in:q,out:X,typeName:w.ZodPipeline})}};H3=class H3 extends F{_parse(q){let X=this._def.innerType._parse(q),Q=(_)=>{if(Eq(_))_.value=Object.freeze(_.value);return _};return sq(X)?X.then((_)=>Q(_)):Q(X)}unwrap(){return this._def.innerType}};H3.create=(q,X)=>{return new H3({innerType:q,typeName:w.ZodReadonly,...S(X)})};Y9={object:C.lazycreate};(function(q){q.ZodString="ZodString",q.ZodNumber="ZodNumber",q.ZodNaN="ZodNaN",q.ZodBigInt="ZodBigInt",q.ZodBoolean="ZodBoolean",q.ZodDate="ZodDate",q.ZodSymbol="ZodSymbol",q.ZodUndefined="ZodUndefined",q.ZodNull="ZodNull",q.ZodAny="ZodAny",q.ZodUnknown="ZodUnknown",q.ZodNever="ZodNever",q.ZodVoid="ZodVoid",q.ZodArray="ZodArray",q.ZodObject="ZodObject",q.ZodUnion="ZodUnion",q.ZodDiscriminatedUnion="ZodDiscriminatedUnion",q.ZodIntersection="ZodIntersection",q.ZodTuple="ZodTuple",q.ZodRecord="ZodRecord",q.ZodMap="ZodMap",q.ZodSet="ZodSet",q.ZodFunction="ZodFunction",q.ZodLazy="ZodLazy",q.ZodLiteral="ZodLiteral",q.ZodEnum="ZodEnum",q.ZodEffects="ZodEffects",q.ZodNativeEnum="ZodNativeEnum",q.ZodOptional="ZodOptional",q.ZodNullable="ZodNullable",q.ZodDefault="ZodDefault",q.ZodCatch="ZodCatch",q.ZodPromise="ZodPromise",q.ZodBranded="ZodBranded",q.ZodPipeline="ZodPipeline",q.ZodReadonly="ZodReadonly"})(w||(w={}));b8=r.create,x8=Fq.create,W9=R3.create,G9=Nq.create,y8=aq.create,z9=yq.create,U9=F3.create,M9=tq.create,j9=eq.create,V9=hq.create,L9=Sq.create,K9=Wq.create,O9=N3.create,A9=a.create,B9=C.create,D9=C.strictCreate,w9=q3.create,E9=c3.create,S9=X3.create,F9=Gq.create,N9=v3.create,v9=I3.create,I9=gq.create,R9=rq.create,T9=Q3.create,P9=_3.create,k9=vq.create,C9=$3.create,f9=lq.create,Z9=qq.create,b9=t.create,x9=Kq.create,y9=qq.createWithPreprocess,h9=T3.create,m9={string:(q)=>r.create({...q,coerce:!0}),number:(q)=>Fq.create({...q,coerce:!0}),boolean:(q)=>aq.create({...q,coerce:!0}),bigint:(q)=>Nq.create({...q,coerce:!0}),date:(q)=>yq.create({...q,coerce:!0})},d9=B});var x={};wq(x,{void:()=>O9,util:()=>I,unknown:()=>L9,union:()=>w9,undefined:()=>M9,tuple:()=>F9,transformer:()=>Z9,symbol:()=>U9,string:()=>b8,strictObject:()=>D9,setErrorMap:()=>x1,set:()=>I9,record:()=>N9,quotelessJson:()=>Z1,promise:()=>f9,preprocess:()=>y9,pipeline:()=>h9,ostring:()=>g9,optional:()=>b9,onumber:()=>l9,oboolean:()=>u9,objectUtil:()=>E6,object:()=>B9,number:()=>x8,nullable:()=>x9,null:()=>j9,never:()=>K9,nativeEnum:()=>C9,nan:()=>W9,map:()=>v9,makeIssue:()=>S3,literal:()=>P9,lazy:()=>T9,late:()=>Y9,isValid:()=>Eq,isDirty:()=>d3,isAsync:()=>sq,isAborted:()=>m3,intersection:()=>S9,instanceof:()=>H9,getParsedType:()=>Hq,getErrorMap:()=>nq,function:()=>R9,enum:()=>k9,effect:()=>Z9,discriminatedUnion:()=>E9,defaultErrorMap:()=>Vq,datetimeRegex:()=>C8,date:()=>z9,custom:()=>Z8,coerce:()=>m9,boolean:()=>y8,bigint:()=>G9,array:()=>A9,any:()=>V9,addIssueToContext:()=>V,ZodVoid:()=>N3,ZodUnknown:()=>Sq,ZodUnion:()=>q3,ZodUndefined:()=>tq,ZodType:()=>F,ZodTuple:()=>Gq,ZodTransformer:()=>qq,ZodSymbol:()=>F3,ZodString:()=>r,ZodSet:()=>gq,ZodSchema:()=>F,ZodRecord:()=>v3,ZodReadonly:()=>H3,ZodPromise:()=>lq,ZodPipeline:()=>T3,ZodParsedType:()=>j,ZodOptional:()=>t,ZodObject:()=>C,ZodNumber:()=>Fq,ZodNullable:()=>Kq,ZodNull:()=>eq,ZodNever:()=>Wq,ZodNativeEnum:()=>$3,ZodNaN:()=>R3,ZodMap:()=>I3,ZodLiteral:()=>_3,ZodLazy:()=>Q3,ZodIssueCode:()=>M,ZodIntersection:()=>X3,ZodFunction:()=>rq,ZodFirstPartyTypeKind:()=>w,ZodError:()=>i,ZodEnum:()=>vq,ZodEffects:()=>qq,ZodDiscriminatedUnion:()=>c3,ZodDefault:()=>J3,ZodDate:()=>yq,ZodCatch:()=>Y3,ZodBranded:()=>p3,ZodBoolean:()=>aq,ZodBigInt:()=>Nq,ZodArray:()=>a,ZodAny:()=>hq,Schema:()=>F,ParseStatus:()=>l,OK:()=>m,NEVER:()=>d9,INVALID:()=>B,EMPTY_PATH:()=>y1,DIRTY:()=>xq,BRAND:()=>J9});var I6=Z(()=>{u3();F6();v8();E3();h8();l3()});var g8=Z(()=>{I6();I6()});import i3 from"fs/promises";import{existsSync as m8}from"fs";import R6 from"path";async function d(q){let X=R6.join(q,p8);if(!m8(X))return{version:c8,branches:[],specIndex:{}};try{let Q=await i3.readFile(X,"utf-8"),_=JSON.parse(Q),$=T6.safeParse(_);if(!$.success){let J=p9(_,q);if(J)return console.warn("[WARN] Auto-repaired branches.json - review changes"),await uq(q,J),J;throw Error(`Corrupted branches.json - restore from git history:
  git show HEAD:.speck/branches.json > .speck/branches.json

Validation errors:
${$.error.message}`)}return $.data}catch(Q){if(Q instanceof SyntaxError)throw Error(`Corrupted branches.json (invalid JSON) - restore from git history:
  git show HEAD:.speck/branches.json > .speck/branches.json`);throw Q}}async function uq(q,X){let Q=R6.join(q,p8),_=`${Q}.tmp`,$=T6.safeParse(X);if(!$.success)throw Error(`Invalid branch mapping: ${$.error.message}`);let J=R6.join(q,".speck");if(!m8(J))await i3.mkdir(J,{recursive:!0});let Y=JSON.stringify(X,null,2);await i3.writeFile(_,Y,"utf-8"),await i3.rename(_,Q)}function P6(q){let X={};for(let Q of q.branches){if(!X[Q.specId])X[Q.specId]=[];X[Q.specId].push(Q.name)}return{...q,specIndex:X}}function k6(q,X){let Q=q.branches.find((_)=>_.name===X);return Q?Q.specId:null}function W3(q,X){return q.branches.find((Q)=>Q.name===X)||null}function C6(q,X){let Q=d8.safeParse(X);if(!Q.success)throw Error(`Invalid branch entry: ${Q.error.message}`);if(q.branches.some(($)=>$.name===X.name))throw Error(`Branch '${X.name}' already exists in mapping`);let _=[...q.branches,X];return P6({...q,branches:_})}function f6(q,X,Q,_){let $=W3(q,X);if(!$)throw Error(`Branch '${X}' not found in mapping`);if(c9($.status,Q),Q==="submitted"&&!_&&!$.pr)throw Error("PR number required for 'submitted' status");let J=q.branches.map((Y)=>Y.name===X?{...Y,status:Q,pr:_!==void 0?_:Y.pr,updatedAt:new Date().toISOString()}:Y);return{...q,branches:J}}function i8(q,X){if(!W3(q,X))throw Error(`Branch '${X}' not found in mapping`);let _=q.branches.filter(($)=>$.name!==X);return P6({...q,branches:_})}function n3(q,X){let Q=new Set,_=new Set,$=[];function J(Y){if(_.has(Y)){let W=$.indexOf(Y);return[...$.slice(W),Y]}if(Q.has(Y))return null;Q.add(Y),_.add(Y),$.push(Y);let H=X.branches.find((W)=>W.name===Y);if(H&&H.baseBranch){if(X.branches.some((G)=>G.name===H.baseBranch)){let G=J(H.baseBranch);if(G)return G}}return $.pop(),_.delete(Y),null}return J(q)}function c9(q,X){if(q==="merged")throw Error("Cannot transition from 'merged' (terminal state)");if(q==="abandoned")throw Error("Cannot transition from 'abandoned' (terminal state)")}function p9(q,X){try{let Q=q;if(!Q.version)Q.version=c8;if(!Array.isArray(Q.branches))Q.branches=[];for(let J of Q.branches){if(!J.createdAt||!l8(J.createdAt))J.createdAt=new Date().toISOString();if(!J.updatedAt||!l8(J.updatedAt))J.updatedAt=new Date().toISOString()}if(!Q.specIndex||typeof Q.specIndex!=="object")Q.specIndex={};let _=P6(Q),$=T6.safeParse(_);if($.success)return $.data;return null}catch{return null}}function l8(q){try{return new Date(q).toISOString()===q}catch{return!1}}async function G3(q,X){let{findChildReposWithNames:Q}=await Promise.resolve().then(() => (o(),A6)),_=null;try{let W=await d(q);if(W.branches.length>0)_=u8(q,"root",W)}catch(W){}let $=new Map,J=await Q(q),Y=Array.from(J.entries()).map(async([W,G])=>{try{let z=await d(G);if(z.branches.length>0){let U=u8(G,W,z);return{childName:W,summary:U}}}catch(z){}return null}),H=await Promise.all(Y);for(let W of H)if(W)$.set(W.childName,W.summary);return{rootRepo:_,childRepos:$}}function u8(q,X,Q){let _={active:0,submitted:0,merged:0,abandoned:0};for(let H of Q.branches)_[H.status]++;let $=[...new Set(Q.branches.map((H)=>H.specId))],J=$.length===1?$[0]??null:null,Y=i9(Q);return{repoPath:q,repoName:X,specId:J,branchCount:Q.branches.length,statusCounts:_,chains:Y,branches:Q.branches}}function i9(q){let X=[],Q=new Set,_=new Set(q.branches.map((J)=>J.name)),$=q.branches.filter((J)=>!_.has(J.baseBranch));for(let J of $)if(!Q.has(J.name)){let Y=n8(J.name,q,Q);if(Y.length>0)X.push({branches:Y})}return X}function n8(q,X,Q){Q.add(q);let _=X.branches.filter((J)=>J.baseBranch===q);if(_.length===0)return[q];let $=_[0];if($&&!Q.has($.name))return[q,...n8($.name,X,Q)];return[q]}var d8,T6,c8="1.1.0",p8=".speck/branches.json";var Z6=Z(()=>{g8();d8=x.object({name:x.string().min(1,"Branch name cannot be empty"),specId:x.string().regex(/^\d{3}-.+$/,"Spec ID must match pattern NNN-feature-name"),baseBranch:x.string().min(1,"Base branch cannot be empty"),status:x.enum(["active","submitted","merged","abandoned"]),pr:x.number().int().positive().nullable(),createdAt:x.string().datetime({message:"Invalid ISO 8601 timestamp"}),updatedAt:x.string().datetime({message:"Invalid ISO 8601 timestamp"}),parentSpecId:x.string().regex(/^\d{3}-.+$/,"Parent spec ID must match pattern NNN-feature-name").optional()}),T6=x.object({version:x.string().regex(/^\d+\.\d+\.\d+$/,"Version must be semver format"),branches:x.array(d8),specIndex:x.record(x.string(),x.array(x.string()))})});var b6,y;var x6=Z(()=>{b6=class b6 extends Error{constructor(q){super(q);this.name="ValidationError"}};y=class y extends Error{constructor(q){super(q);this.name="GitError"}}});var{$:Xq}=globalThis.Bun;async function s8(q,X,Q){if((await Xq`git -C ${Q} rev-parse --verify ${X}`.quiet()).exitCode!==0)throw new y(`Base branch '${X}' does not exist`);if((await Xq`git check-ref-format --branch ${q}`.quiet()).exitCode!==0)throw new y(`Invalid branch name: '${q}'`);let J=await Xq`git -C ${Q} branch ${q} ${X}`.quiet();if(J.exitCode!==0){let Y=J.stderr.toString();throw new y(`Failed to create branch: ${Y}`)}}async function o8(q,X,Q){try{let _=await Xq`git -C ${Q} branch --merged ${X}`.quiet();if(_.exitCode!==0)throw new y(`Failed to check merged status for '${q}'`);return _.text().split(`
`).map((Y)=>Y.trim().replace(/^\*\s*/,"")).filter(Boolean).includes(q)}catch(_){if(_ instanceof y)throw _;throw new y(`Failed to check merged status: ${String(_)}`)}}async function r8(q,X){try{let Q=X?`git -C ${q} branch --list --format='%(refname:short)|%(upstream:short)' ${X}`:`git -C ${q} branch --list --format='%(refname:short)|%(upstream:short)'`,_=await Xq`sh -c ${Q}`.quiet();if(_.exitCode!==0){let J=_.stderr.toString();throw new y(`Failed to list branches: ${J}`)}return _.stdout.toString().split(`
`).filter(Boolean).map((J)=>{let[Y,H]=J.split("|");if(!Y)throw new y("Invalid branch line format");return{name:Y.trim(),upstream:H?.trim()||null}})}catch(Q){if(Q instanceof y)throw Q;throw new y(`Failed to list branches: ${String(Q)}`)}}async function a8(q,X){let Q=await Xq`git -C ${X} checkout ${q}`.quiet();if(Q.exitCode!==0){let _=Q.stderr.toString();throw new y(`Failed to checkout branch '${q}': ${_}`)}}async function z3(q){let X=await Xq`git -C ${q} rev-parse --abbrev-ref HEAD`.quiet();if(X.exitCode!==0)throw new y("Failed to get current branch");let Q=X.stdout.toString().trim();if(Q==="HEAD")throw new y("Currently in detached HEAD state");return Q}async function s3(q,X){try{return(await Xq`git -C ${X} rev-parse --verify ${q}`.quiet()).exitCode===0}catch{return!1}}async function t8(q,X){let Q=await Xq`git -C ${X} branch --list ${q}`.quiet();if(Q.exitCode!==0||!Q.stdout.toString().trim())throw new y(`Base branch '${q}' does not exist in current repository.

Cross-repo branch dependencies are not supported.

Alternatives:
  1. Complete work in other repo first and merge to main
  2. Use shared contracts/APIs for coordination
  3. Manually coordinate PR merge order across repos`)}async function y6(q){if(P3.has(q))return P3.get(q);try{let Q=await Xq`git -C ${q} symbolic-ref refs/remotes/origin/HEAD`.quiet();if(Q.exitCode===0){let $=Q.stdout.toString().trim().match(/refs\/remotes\/origin\/(.+)/);if($&&$[1]){let J=$[1];return P3.set(q,J),J}}}catch{}let X=["main","master","develop"];for(let Q of X)if(await s3(Q,q))return P3.set(q,Q),Q;return P3.set(q,null),null}async function e8(q){try{let X=await Xq`git -C ${q} remote get-url origin`.quiet();if(X.exitCode===0)return X.stdout.toString().trim();return null}catch{return null}}var P3;var h6=Z(()=>{x6();P3=new Map});var _X={};wq(_X,{main:()=>GQ});import o3 from"path";import r3 from"fs/promises";var{$:Iq}=globalThis.Bun;async function QX(q){try{let Q=(await Iq`git -C ${q} symbolic-ref --short HEAD 2>/dev/null || git -C ${q} rev-parse --short HEAD 2>/dev/null`.quiet()).text().trim();if(Q&&/^\d{3}-.+$/.test(Q)){let Y=o3.join(q,"specs",Q);try{return await r3.access(Y),Q}catch{}}let _=o3.join(q,"specs"),J=(await r3.readdir(_)).filter((Y)=>/^\d{3}-.+$/.test(Y));if(J.length===0)return null;return J.sort(),J[J.length-1]??null}catch{return null}}async function n9(){try{return(await Iq`which gh`.quiet()).exitCode===0}catch{return!1}}async function s9(q,X,Q){try{let _=await Iq`git -C ${Q} log ${q}..${X} --format=%s%n%b`.quiet();if(_.exitCode!==0)return[];return _.stdout.toString().trim().split(`
`).filter(($)=>$.trim())}catch{return[]}}function o9(q){let X=[/^wip/i,/^fix$/i,/^tmp/i,/^temp/i,/^test/i,/^update$/i,/^merge/i,/^rebase/i,/^\./],Q=q.trim().toLowerCase();return!X.some((_)=>_.test(Q))&&Q.length>5}function r9(q){if(q.length===0)return null;let X=q.filter(($)=>$.trim()&&o9($));if(X.length===0)return null;let Q=X[0]?.split(`
`)[0]??"Update",_=X.map(($)=>`- ${$.split(`
`)[0]}`).join(`
`);return{title:Q,body:_}}async function a9(q,X,Q){try{let $=(await Iq`git -C ${Q} diff ${q}...${X} --stat`.quiet()).stdout.toString().trim(),Y=(await Iq`git -C ${Q} diff ${q}...${X} --name-status`.quiet()).stdout.toString().trim().split(`
`).filter((G)=>G.trim()),H=`Update ${X} (${Y.length} files changed)`,W=`## Changes

${$}

## Files Modified
${Y.map((G)=>`- ${G}`).join(`
`)}`;return{title:H,body:W}}catch{return{title:`Update ${X}`,body:"Changes made on this branch"}}}function t9(q,X,Q){if(X)return X;return"main"}async function e9(q,X,Q,_,$){if($?.context==="child"){if(!await e8(_))return console.warn(`
\u26A0\uFE0F  WARNING: No remote configured for this repository.`),console.warn("Branch created locally. PR creation unavailable."),console.warn(`
To configure remote:`),console.warn("  git remote add origin <url>"),console.warn(`  git push -u origin <branch-name>
`),null}if(!await n9())return null;let Y=W3(Q,q),H;if($?.context==="child")H=await y6(_)||"main";else H=t9(q,Y?.baseBranch||null,_);let W=await s9(H,q,_);if(W.length===0)return null;let G=r9(W);if(!G)G=await a9(H,q,_);let z=G.title;if($?.childRepoName)z=`[${$.childRepoName}] ${G.title}`;return{title:z,body:G.body,prBase:H}}function g6(q,X,Q){let _=q.branches.filter((Y)=>Y.specId===X),$=_.filter((Y)=>!_.some((H)=>H.name===Y.baseBranch));function J(Y,H,W){let G=_.find((O)=>O.name===Y);if(!G)return;let z="  ".repeat(H),U=H===0?"":W?"\u2514\u2500 ":"\u251C\u2500 ",L=Y===Q?" (current)":"",A=G.status!=="active"?` (${G.status}${G.pr?`, PR #${G.pr}`:""})`:"";console.log(`${z}${U}${Y}${L}${A}`);let P=_.filter((O)=>O.baseBranch===Y);P.forEach((O,R)=>{J(O.name,H+1,R===P.length-1)})}$.forEach((Y)=>{console.log(`  ${Y.baseBranch}`),J(Y.name,1,!0)})}function qX(q,X){let Q=X;while(Q){let _=q.branches.find(($)=>$.name===Q.baseBranch);if(!_)return Q.baseBranch;Q=_}return"main"}async function qQ(q){let X=q.findIndex((v)=>!v.startsWith("--"));if(X===-1)throw Error("Branch name required: /speck.branch create <name> [--base <base>]");let Q=q[X],_=q.indexOf("--base"),$=q.indexOf("--spec"),J=q.includes("--skip-pr-prompt"),Y=q.includes("--create-pr"),H=q.indexOf("--title"),W=q.indexOf("--description"),G=q.indexOf("--pr-base"),z=q.includes("--json"),U=await p(),L=U.REPO_ROOT,A=await b(),P=await L6(),O=null;if(A.mode==="multi-repo"){let v=P?"child":"root",Dq=P?await QX(A.speckRoot):null,dq=P?await g3(A.repoRoot,A.speckRoot):null;O={...A,context:v,parentSpecId:Dq,childRepoName:dq}}let R="";try{R=await z3(L)}catch(v){R=""}let N,u=_!==-1?q[_+1]:void 0;if(u)N=u;else{if(!R)return console.error("Error: No commits in repository. Cannot determine current branch."),console.error("Please create an initial commit first, or specify --base explicitly."),1;N=R,console.log(`Defaulting base to current branch: ${N}`)}let g=$!==-1&&q[$+1]?q[$+1]:null;if(!await O6(Q))throw Error(`Invalid branch name: '${Q}'. Must be a valid git ref name.`);try{await t8(N,L)}catch(v){if(v instanceof Error)throw Error(v.message);throw v}if(!g){if(U.FEATURE_DIR&&U.FEATURE_DIR.includes("/specs/")){let v=U.FEATURE_DIR.match(/\/specs\/([^/]+)/);if(v&&v[1]){if(g=v[1],!z)console.log(`Auto-detected spec: ${g}`)}}if(!g)throw Error(`Could not auto-detect spec ID. Please specify with --spec flag:
  /speck.branch create <name> [--base <base>] --spec <spec-id>`)}let f=g,$q=O?A.specsDir:o3.join(L,"specs"),Uq=o3.join($q,f);try{await r3.access(Uq)}catch{throw Error(`Spec directory not found: specs/${f}/`)}if((await Iq`git -C ${L} status --porcelain`.quiet()).stdout.toString().split(`
`).filter((v)=>v.trim().length>0).filter((v)=>!v.includes(".speck/branches.json")).length>0){console.log(`
${"\u26A0".repeat(30)}`),console.log(`\u26A0 Warning: Current branch '${R}' has uncommitted changes`),console.log(`${"\u26A0".repeat(30)}
`);let v=await Iq`git -C ${L} diff --stat`.quiet();throw console.log("Changed files:"),console.log(v.stdout.toString()),console.log(`
Options:`),console.log("  1. Commit changes now (recommended)"),console.log("  2. Stash changes (saves for later)"),console.log("  3. Carry changes to new branch (creates new branch with changes)"),console.log("  4. Abort branch creation"),console.log(`
Choose an option or run one of these commands first:`),console.log('  git add . && git commit -m "message"  # Commit changes'),console.log("  git stash                              # Stash changes"),console.log(`
Then re-run: /speck.branch create `+q.join(" ")),Error("Uncommitted changes detected. Please commit or stash changes before creating a new branch.")}let c=await d(L);if(!J&&!Y){let v=await e9(R,N,c,L,O);if(v){if(z){let Dq={branch:R,title:v.title,body:v.body,base:v.prBase};console.log(JSON.stringify(Dq))}else{let Dq={type:"pr-suggestion",branch:R,suggestedTitle:v.title,suggestedDescription:v.body,suggestedBase:v.prBase,newBranch:Q};console.error(JSON.stringify(Dq)),console.log(`
${"=".repeat(60)}`),console.log(`\uD83D\uDCA1 PR Opportunity: Create PR for '${R}' before switching`),console.log(`${"=".repeat(60)}`),console.log(`
Suggested PR details:`),console.log(`  Title: ${v.title}`),console.log(`  Base: ${v.prBase}`),console.log(`
Description:`),console.log(v.body.split(`
`).map((dq)=>`  ${dq}`).join(`
`)),console.log(`
${"-".repeat(60)}`),console.log("Option 1: Create PR with gh CLI:"),console.log(`  gh pr create --base ${v.prBase} --title "${v.title}" --body "${v.body.replace(/"/g,"\\\"")}"`),console.log(`
Option 2: Create PR via GitHub URL:`),console.log(`  https://github.com/OWNER/REPO/compare/${v.prBase}...${R}?expand=1&title=${encodeURIComponent(v.title)}`),console.log(`
Option 3: Skip and create branch without PR`),console.log(`${"=".repeat(60)}
`)}return 2}}if(Y){let v=H!==-1&&q[H+1]?q[H+1]:null,Dq=W!==-1&&q[W+1]?q[W+1]:null,dq=G!==-1&&q[G+1]?q[G+1]:null;if(!v||!Dq||!dq)throw Error("--create-pr requires --title, --description, and --pr-base flags");console.log(`Creating PR for '${R}'...`);try{let Tq=await Iq`gh pr create --base ${dq} --title ${v} --body ${Dq}`.quiet();if(Tq.exitCode!==0)throw Error(`gh pr create failed: ${Tq.stderr.toString()}`);let q6=Tq.stdout.toString().match(/\/pull\/(\d+)/),X6=q6&&q6[1]?parseInt(q6[1],10):null;if(X6){if(console.log(`\u2713 Created PR #${X6} for '${R}'`),W3(c,R))c=f6(c,R,"submitted",X6),await uq(L,c)}else console.log(`\u2713 PR created for '${R}' (could not parse PR number from output)`)}catch(Tq){let cq=Tq instanceof Error?Tq.message:String(Tq);if(cq.includes("gh: command not found")||cq.includes("not found"))return console.error(`
\u274C Error: GitHub CLI (gh) is not installed`),console.error(`
To install gh:`),console.error("  brew install gh           # macOS"),console.error("  sudo apt install gh       # Ubuntu/Debian"),console.error("  winget install GitHub.cli # Windows"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${Q} --skip-pr-prompt`),1;if(cq.includes("authentication")||cq.includes("401"))return console.error(`
\u274C Error: GitHub CLI is not authenticated`),console.error(`
To authenticate:`),console.error("  gh auth login"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${Q} --skip-pr-prompt`),1;return console.error(`
\u274C Error creating PR: ${cq}`),console.error(`
You can:`),console.error("  1. Check your network connection and try again"),console.error("  2. Create the PR manually via GitHub web UI"),console.error("  3. Use --skip-pr-prompt to create branch without PR"),1}}let Bq=new Date().toISOString(),c6={name:Q,specId:f,baseBranch:N,status:"active",pr:null,createdAt:Bq,updatedAt:Bq,...O?.parentSpecId?{parentSpecId:O.parentSpecId}:{}},p6=n3(Q,{...c,branches:[...c.branches,c6]});if(p6)throw Error(`Circular dependency detected: ${p6.join(" \u2192 ")}`);if(c=C6(c,c6),await s8(Q,N,L),await a8(Q,L),await uq(L,c),!z)console.log(`\u2713 Created stacked branch '${Q}'`),console.log(`\u2713 Based on: ${N}`),console.log(`\u2713 Linked to spec: ${f}`),console.log(),console.log("Branch stack:"),g6(c,f,Q),console.log(),console.log("Next steps:"),console.log("  - Implement feature on this branch"),console.log(`  - Run /speck.tasks --branch ${Q} to generate tasks`),console.log(`  - When ready: /speck.branch create <next-branch> --base ${Q}`)}async function XQ(q){let X=q.includes("--all"),Q=await p(),_=await b(),$=Q.REPO_ROOT;if(X&&_.mode==="multi-repo"){await QQ(_.speckRoot,$);return}let J=await d($);if(J.branches.length===0){console.log("No stacked branches found."),console.log("Create your first stacked branch with:"),console.log("  /speck.branch create <name> --base main");return}let Y="";try{Y=await z3($)}catch(H){Y=""}if(X){let H=Object.keys(J.specIndex);for(let W of H)console.log(`
Spec: ${W}`),console.log("Branch Stack:"),g6(J,W,Y);console.log(`
Total: ${J.branches.length} branches across ${H.length} specs`)}else{let H=k6(J,Y);if(!H){console.log("Current branch is not in stacked mode."),console.log("Use --all to see all stacked branches.");return}console.log(`Spec: ${H}
`),console.log("Branch Stack:"),g6(J,H,Y),console.log(`
Legend:`),console.log("  (current) = checked out branch"),console.log("  (active) = development in progress"),console.log("  (submitted) = PR open for review")}}async function QQ(q,X){let Q=await G3(q,X);if(console.log(`Branch List (All Repositories)
`),Q.rootRepo&&Q.rootRepo.branchCount>0){console.log("Root Repository:"),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let $=await d(q);for(let J of $.branches){let Y=J.pr?String(J.pr).padEnd(5):"-".padEnd(5);console.log(`${J.name.padEnd(18)} ${J.baseBranch.padEnd(14)} ${J.specId.padEnd(23)} ${Y} ${J.status}`)}console.log("")}let _=Array.from(Q.childRepos.keys()).sort();for(let $ of _){let J=Q.childRepos.get($);console.log(`Child: ${$}`),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let Y=await d(J.repoPath);for(let H of Y.branches){let W=H.pr?String(H.pr).padEnd(5):"-".padEnd(5);console.log(`${H.name.padEnd(18)} ${H.baseBranch.padEnd(14)} ${H.specId.padEnd(23)} ${W} ${H.status}`)}console.log("")}if(_.length===0&&!Q.rootRepo)console.log("No branches found in any repository.")}async function _Q(q=[]){let X=q.includes("--all"),Q=await p(),_=await b(),$=Q.REPO_ROOT;if(X&&_.mode==="multi-repo"){await $Q(_.speckRoot,$);return}let J=await d($),Y="";try{Y=await z3($)}catch(U){Y=""}let H=k6(J,Y);if(!H){console.log("Current branch is not in stacked mode.");return}let W=J.branches.filter((U)=>U.specId===H),G=0;console.log(`Spec: ${H}
`);for(let U of W){if(!await s3(U.name,$)){console.log(`${U.name} (${U.status}${U.pr?`, PR #${U.pr}`:""})`),console.log("  \u26A0 ORPHANED: Branch no longer exists in git"),console.log(`  \u2192 Run: /speck.branch delete ${U.name} (cleanup metadata)`),G++;continue}let A=await o8(U.name,U.baseBranch,$);if(A&&U.status!=="merged")console.log(`${U.name} (${U.status}${U.pr?`, PR #${U.pr}`:""})`),console.log(`  \u26A0 MERGED: Branch merged into base but status is '${U.status}'`),console.log(`  \u2192 Run: /speck.branch update ${U.name} --status merged`),G++;if(A&&U.status==="merged"){let P=W.filter((O)=>O.baseBranch===U.name&&O.status!=="merged");if(P.length>0)for(let O of P)console.log(`
${O.name} (${O.status})`),console.log(`  \u26A0 REBASE NEEDED: Base branch '${U.name}' has been merged`),console.log(`  \u2192 Run: git rebase ${qX(J,U)}`),console.log(`  \u2192 Update base: /speck.branch update ${O.name} --base ${qX(J,U)}`),G++}}if(G===0)console.log("\u2713 Branch stack is healthy - no warnings");else console.log(`
\u26A0 ${G} warning(s) found`);let z=await iq();if(z.context==="child"&&J.branches.length>0)try{let{findChildRepos:U}=await Promise.resolve().then(() => (o(),A6)),L=z.speckRoot||"";if(!(await U(L)).includes($))console.log(`
\u26A0 Orphaned tracking detected:`),console.log(`  ${J.branches.length} branch(es) tracked but repo unlinked from parent spec`),console.log(`  Parent: ${L}`),console.log("  Fix: Re-link with /speck.link or archive .speck/branches.json")}catch{}}async function $Q(q,X){let Q=await G3(q,X);if(console.log(`Branch Status (All Repositories)
`),Q.rootRepo&&Q.rootRepo.branchCount>0)console.log("Root Repository:"),await XX(q,Q.rootRepo),console.log("");let _=Array.from(Q.childRepos.keys()).sort();for(let $ of _){let J=Q.childRepos.get($);console.log(`Child: ${$}`),await XX(J.repoPath,J),console.log("")}if(_.length===0&&!Q.rootRepo)console.log("No branches found in any repository.")}async function XX(q,X){let Q=await d(q),_=[];if(X.statusCounts.active>0)_.push(`${X.statusCounts.active} active`);if(X.statusCounts.submitted>0)_.push(`${X.statusCounts.submitted} submitted`);if(X.statusCounts.merged>0)_.push(`${X.statusCounts.merged} merged`);if(X.statusCounts.abandoned>0)_.push(`${X.statusCounts.abandoned} abandoned`);if(_.length>0)console.log(`  Total: ${X.branchCount} branches (${_.join(", ")})`);console.log("  Dependency Tree:");for(let $ of X.chains)if($.branches.length>0)JQ($.branches,Q)}function JQ(q,X){q.forEach((Q,_)=>{let $=X.branches.find((H)=>H.name===Q);if(!$)return;let Y=`${_===0?"    \u2514\u2500":"       \u2514\u2500"} ${Q}`;if($.pr)Y+=` (${$.status}, PR #${$.pr})`;else if($.status!=="active")Y+=` (${$.status})`;console.log(Y)})}async function YQ(q){let X=q[0];if(!X)throw Error("Branch name required: /speck.branch update <name> [options]");let Q=q.indexOf("--status"),_=q.indexOf("--pr"),$=q.indexOf("--base"),Y=(await p()).REPO_ROOT,H=await d(Y);if(!W3(H,X))throw Error(`Branch '${X}' not found in mapping`);if(Q!==-1){let G=q[Q+1];if(!G)throw Error("--status flag requires a value");let z=G;if(!["active","submitted","merged","abandoned"].includes(z))throw Error(`Invalid status: '${z}'. Must be: active, submitted, merged, or abandoned`);let U=_!==-1&&q[_+1]?parseInt(q[_+1],10):void 0;H=f6(H,X,z,U)}if($!==-1){let G=q[$+1];if(!G)throw Error("--base flag requires a branch name");if(!await s3(G,Y))throw Error(`Base branch '${G}' does not exist`);let U=H.branches.map((A)=>A.name===X?{...A,baseBranch:G,updatedAt:new Date().toISOString()}:A),L=n3(X,{...H,branches:U});if(L)throw Error(`Cannot update base: circular dependency detected: ${L.join(" \u2192 ")}`);H={...H,branches:U}}await uq(Y,H),console.log(`\u2713 Updated branch '${X}'`)}async function HQ(q){let X=q[0];if(!X)throw Error("Branch name required: /speck.branch delete <name>");let Q=q.includes("--force"),$=(await p()).REPO_ROOT,J=await d($),Y=J.branches.filter((W)=>W.baseBranch===X);if(Y.length>0&&!Q)throw console.error(`Error: Branch '${X}' has child branches:`),Y.forEach((W)=>console.error(`  - ${W.name}`)),console.error(`
Use --force to delete anyway (will orphan children)`),Error("Branch has children");let H=i8(J,X);await uq($,H),console.log(`\u2713 Removed branch '${X}' from metadata`),console.log(),console.log("Note: Git branch still exists. To delete it, run:"),console.log(`  git branch -D ${X}`)}async function WQ(q){let X=q.indexOf("--pattern"),Q=X!==-1?q[X+1]:void 0,_=q.indexOf("--batch"),$=_!==-1,Y=(await p()).REPO_ROOT,H=await iq(),W=H.context==="child"?await QX(H.speckRoot):null,G=await r8(Y,Q);if(G.length===0){console.log("No branches found to import.");return}let z=await d(Y),U=await y6(Y),L=G.filter(({name:g})=>!z.branches.some((Aq)=>Aq.name===g)&&g!==U);if(L.length===0){console.log("All branches are already in stacked mode.");return}let A=H.specsDir,O=(await r3.readdir(A)).filter((g)=>/^\d{3}-/.test(g));if(!$){let g=L.map(({name:f,upstream:$q})=>{let Uq="main";if($q){let Rq=$q.replace(/^origin\//,"");if(Rq&&Rq!==f)Uq=Rq}return{name:f,upstream:$q||null,inferredBase:Uq}});return console.error(JSON.stringify({type:"import-prompt",branches:g,availableSpecs:O})),console.log(`Found ${L.length} branches to import:
`),g.forEach((f)=>{console.log(`\u2022 ${f.name}`),console.log(`  Upstream: ${f.upstream||"(none)"}`),console.log(`  Inferred base: ${f.inferredBase}`),console.log()}),console.log(`Available specs: ${O.join(", ")}
`),console.log("Agent interaction required: Map each branch to a spec."),3}let R=q.slice(_+1),N=0,u=0;for(let g of R){let Aq=g.split(":"),f=Aq[0],$q=Aq[1];if(!f||!$q){console.log(`\u26A0 Invalid mapping format: ${g}`);continue}if($q==="skip"){console.log(`\u2298 Skipped ${f}`),u++;continue}let Uq=L.find((Bq)=>Bq.name===f);if(!Uq){console.log(`\u26A0 Branch not found: ${f}`);continue}let Rq="main";if(Uq.upstream){let Bq=Uq.upstream.replace(/^origin\//,"");if(Bq&&Bq!==Uq.name)Rq=Bq}let t3=new Date().toISOString(),e3={name:f,specId:$q,baseBranch:Rq,status:"active",pr:null,createdAt:t3,updatedAt:t3,...W&&{parentSpecId:W}},c=n3(f,{...z,branches:[...z.branches,e3]});if(c){console.log(`\u26A0 Skipped ${f} (would create cycle: ${c.join(" \u2192 ")})`),u++;continue}z=C6(z,e3),console.log(`\u2713 Imported ${f} \u2192 ${$q}`),N++}await uq(Y,z),console.log(`
\u2713 Import complete:`),console.log(`  Imported: ${N}`),console.log(`  Skipped: ${u}`)}async function GQ(q=process.argv.slice(2)){if(process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: This script is deprecated. Use 'speck-branch' virtual command or 'bun .speck/scripts/speck.ts branch' instead.\x1B[0m
`);if(q.length===0)return console.log("Usage: /speck.branch <command> [args]"),console.log(),console.log("Commands:"),console.log("  create <name> [--base <base>] [--spec <spec-id>]"),console.log("  list [--all]"),console.log("  status"),console.log("  update <name> [--status <status>] [--pr <number>] [--base <branch>]"),console.log("  delete <name> [--force]"),console.log("  import [--pattern <pattern>]"),1;let X=q[0],Q=q.slice(1);try{let _=void 0;switch(X){case"create":_=await qQ(Q);break;case"list":_=await XQ(Q);break;case"status":_=await _Q(Q);break;case"update":_=await YQ(Q);break;case"delete":_=await HQ(Q);break;case"import":_=await WQ(Q);break;default:return console.error(`Unknown command: ${X}`),console.error("Run '/speck.branch' for usage"),1}if(typeof _==="number")return _}catch(_){if(_ instanceof y||_ instanceof b6)return console.error(`Error: ${_.message}`),1;if(_ instanceof Error){if(console.error(`Error: ${_.message}`),_.stack)console.error(`Stack trace: ${_.stack}`);return 1}return console.error(`Unknown error: ${String(_)}`),1}return 0}var $X=Z(async()=>{Z6();h6();o();x6()});var HX={};wq(HX,{main:()=>MQ});import zQ from"fs/promises";import UQ from"path";async function MQ(q=process.argv.slice(2)){if(!q.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: This script is deprecated. Use 'speck-env' virtual command or 'bun .speck/scripts/speck.ts env' instead.\x1B[0m
`);if(q.includes("--help"))return jQ(),0;let X=q.includes("--json");try{return await VQ(X),0}catch(Q){if(X)console.error(JSON.stringify({error:Q instanceof Error?Q.message:String(Q)}));else console.error(`Error: ${Q instanceof Error?Q.message:String(Q)}`);return 1}}function jQ(){console.log(`
Speck Environment Check

Usage:
  bun run .speck/scripts/env-command.ts [options]

Options:
  --help     Show this help message
  --json     Output as JSON (for programmatic use)

Description:
  Displays comprehensive environment information including:
  - Multi-repo configuration
  - Branch stack status (single-repo or aggregate)
  - Feature detection
  - System diagnostics
  `.trim())}async function VQ(q){let X=await b(),Q=await iq();if(q)await wQ(X,Q);else await LQ(X,Q)}async function LQ(q,X){console.log(`=== Speck Environment Status ===
`),KQ(X),await OQ(q,X)}function KQ(q){if(q.mode==="single-repo")console.log("Mode: Single-repo"),console.log(`  Repo Root: ${q.repoRoot}`),console.log(`  Specs Directory: ${q.specsDir}`),console.log("");else if(q.context==="root")console.log("Mode: Multi-repo (Root)"),console.log(`  Speck Root: ${q.speckRoot}`),console.log(`  Specs Directory: ${q.specsDir}`),console.log("");else if(q.context==="child")console.log("Mode: Multi-repo (Child Repository)"),console.log(`  Context: Child repo (${q.childRepoName})`),console.log(`  Parent Spec: ${q.parentSpecId||"Unknown"}`),console.log(`  Repo Root: ${q.repoRoot}`),console.log(`  Speck Root: ${q.speckRoot}`),console.log("")}async function OQ(q,X){let _=(await K6(q.speckRoot)).size>0,$=UQ.join(q.repoRoot,".speck","branches.json"),J=!1;try{await zQ.access($),J=!0}catch{}if(!J&&!_){console.log("Branch Stack Status: Not enabled"),console.log(""),console.log("To enable stacked PRs:"),console.log("  /speck.branch create <branch-name> --base <base-branch>"),console.log("");return}if(X.mode==="multi-repo"&&X.context==="root"||X.mode==="single-repo"&&_)await AQ(q.speckRoot,q.repoRoot);else await DQ(q.repoRoot)}async function AQ(q,X){console.log(`=== Branch Stack Status (Multi-Repo) ===
`);let Q=await G3(q,X);if(Q.rootRepo)JX("Root",Q.rootRepo);else console.log("Root Repository: (no branches)"),console.log("");let _=Array.from(Q.childRepos.keys()).sort();for(let $ of _){let J=Q.childRepos.get($);JX(`Child: ${$}`,J)}if(_.length===0&&!Q.rootRepo)console.log("No branches found in any repository."),console.log("")}function JX(q,X){console.log(`${q}${X.specId?` (${X.specId})`:""}:`);let Q=[];if(X.statusCounts.active>0)Q.push(`${X.statusCounts.active} active`);if(X.statusCounts.submitted>0)Q.push(`${X.statusCounts.submitted} submitted`);if(X.statusCounts.merged>0)Q.push(`${X.statusCounts.merged} merged`);if(X.statusCounts.abandoned>0)Q.push(`${X.statusCounts.abandoned} abandoned`);if(Q.length>0)console.log(`  ${Q.join(", ")}`);for(let _ of X.chains)if(_.branches.length>0)BQ(_.branches,X.branches);console.log("")}function BQ(q,X){if(q.length===0)return;q.forEach((Q,_)=>{let $=_===0?"\u2514\u2500":"   \u2514\u2500",J=X.find((H)=>H.name===Q),Y=`  ${$} ${Q}`;if(J){if(J.pr)Y+=` (${J.status}, PR #${J.pr})`;else if(J.status!=="active")Y+=` (${J.status})`}console.log(Y)})}async function DQ(q){console.log(`=== Branch Stack Status ===
`);let X=await d(q);if(X.branches.length===0){console.log("No branches tracked yet."),console.log("");return}let Q="";try{Q=await z3(q)}catch(J){Q=""}let _=Object.keys(X.specIndex);for(let J of _){console.log(`Spec: ${J}`),console.log("Branch Stack:");let Y=X.specIndex[J]||[],H=Y.map((G)=>X.branches.find((z)=>z.name===G)).filter((G)=>G!==void 0);H.filter((G)=>G!==void 0&&!Y.includes(G.baseBranch)).forEach((G)=>{if(!G)return;console.log(`  ${G.baseBranch}`),YX(G.name,"  ",!0,H,Q)}),console.log("")}let $=X.branches.filter((J)=>J.status==="active"&&J.pr===null).length;if($>0)console.log(`\u26A0 ${$} branch(es) may need attention`),console.log("Run /speck.branch status for details"),console.log("")}function YX(q,X,Q,_,$){let J=_.find((z)=>z.name===q);if(!J)return;let Y=Q?"\u2514\u2500":"\u251C\u2500",H=q===$,W=`${X}${Y} ${q}`;if(J.pr)W+=` (${J.status}, PR #${J.pr})`;else if(J.status!=="active")W+=` (${J.status})`;if(H)W+=" (current)";console.log(W);let G=_.filter((z)=>z.baseBranch===q);G.forEach((z,U)=>{let L=X+(Q?"  ":"\u2502 ");YX(z.name,L,U===G.length-1,_,$)})}async function wQ(q,X){let Q={mode:X.mode,context:X.context,speckRoot:X.speckRoot,repoRoot:X.repoRoot,specsDir:X.specsDir};if(X.context==="child")Q.childRepoName=X.childRepoName,Q.parentSpecId=X.parentSpecId;if(X.mode==="multi-repo"&&X.context==="root"){let _=await G3(X.speckRoot,X.repoRoot);Q.branchStatus={type:"aggregate",rootRepo:_.rootRepo,childRepos:Object.fromEntries(_.childRepos)}}else try{let _=await d(X.repoRoot);Q.branchStatus={type:"local",branches:_.branches,specIndex:_.specIndex}}catch{Q.branchStatus={type:"none"}}console.log(JSON.stringify(Q,null,2))}var WX=Z(async()=>{Z6();h6();o()});var UX={};wq(UX,{main:()=>PQ});import{existsSync as U3,mkdirSync as l6,readdirSync as GX,copyFileSync as EQ,symlinkSync as SQ}from"fs";import n from"path";var{$:Oq}=globalThis.Bun;function FQ(q){let X={json:!1,sharedSpec:!1,localSpec:!1,help:!1,featureDescription:""},Q=[],_=0;while(_<q.length){let $=q[_];if($==="--json")X.json=!0,_++;else if($==="--short-name"){if(_+1>=q.length||q[_+1]?.startsWith("--"))console.error("Error: --short-name requires a value"),process.exit(1);X.shortName=q[_+1],_+=2}else if($==="--number"){if(_+1>=q.length||q[_+1]?.startsWith("--"))console.error("Error: --number requires a value"),process.exit(1);let J=parseInt(q[_+1],10);if(isNaN(J))console.error("Error: --number requires a numeric value"),process.exit(1);X.number=J,_+=2}else if($==="--shared-spec")X.sharedSpec=!0,_++;else if($==="--local-spec")X.localSpec=!0,_++;else if($==="--help"||$==="-h")X.help=!0,_++;else Q.push($),_++}return X.featureDescription=Q.join(" "),X}function NQ(){let q=n.basename(process.argv[1]);console.log(`Usage: ${q} [--json] [--short-name <name>] [--number N] [--shared-spec | --local-spec] <feature_description>

Options:
  --json              Output in JSON format
  --short-name <name> Provide a custom short name (2-4 words) for the branch
  --number N          Specify branch number manually (overrides auto-detection)
  --shared-spec       Create spec at speckRoot (multi-repo shared spec with local symlinks)
  --local-spec        Create spec locally in child repo (single-repo or child-only spec)
  --help, -h          Show this help message

Examples:
  ${q} 'Add user authentication system' --short-name 'user-auth'
  ${q} 'Implement OAuth2 integration for API' --number 5 --shared-spec`)}function vQ(q){let X=q;while(X!=="/"){if(U3(n.join(X,".git"))||U3(n.join(X,".specify"))||U3(n.join(X,".speck")))return X;X=n.dirname(X)}return null}function IQ(q){let X=0;if(U3(q)){let Q=GX(q,{withFileTypes:!0});for(let _ of Q)if(_.isDirectory()){let $=_.name.match(/^(\d+)/);if($&&$[1]){let J=parseInt($[1],10);if(J>X)X=J}}}return X}async function RQ(q,X){try{await Oq`git fetch --all --prune`.quiet()}catch{}let Q=0;try{let $=(await Oq`git ls-remote --heads origin`.quiet()).text().split(`
`);for(let J of $){let Y=J.match(new RegExp(`refs/heads/(\\d+)-${q}$`));if(Y&&Y[1]){let H=parseInt(Y[1],10);if(H>Q)Q=H}}}catch{}try{let $=(await Oq`git branch`.quiet()).text().split(`
`);for(let J of $){let Y=J.match(new RegExp(`^[* ]*?(\\d+)-${q}$`));if(Y&&Y[1]){let H=parseInt(Y[1],10);if(H>Q)Q=H}}}catch{}if(U3(X)){let _=GX(X,{withFileTypes:!0});for(let $ of _)if($.isDirectory()){let J=$.name.match(new RegExp(`^(\\d+)-${q}$`));if(J&&J[1]){let Y=parseInt(J[1],10);if(Y>Q)Q=Y}}}return Q+1}function zX(q){return q.toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/-+/g,"-").replace(/^-/,"").replace(/-$/,"")}function TQ(q){let X=new Set(["i","a","an","the","to","for","of","in","on","at","by","with","from","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","should","could","can","may","might","must","shall","this","that","these","those","my","your","our","their","want","need","add","get","set"]),_=q.toLowerCase().replace(/[^a-z0-9]+/g," ").split(/\s+/).filter((Y)=>Y.length>0),$=[];for(let Y of _){if(X.has(Y))continue;if(Y.length>=3)$.push(Y);else{let H=Y.toUpperCase();if(q.includes(H))$.push(Y)}}if($.length>0){let Y=$.length===4?4:3;return $.slice(0,Y).join("-")}return zX(q).split("-").filter((Y)=>Y.length>0).slice(0,3).join("-")}async function PQ(q){let X=FQ(q);if(X.help)return NQ(),0;if(!X.featureDescription)return console.error("Usage: create-new-feature [--json] [--short-name <name>] [--number N] <feature_description>"),1;let Q,_=!1;try{Q=(await Oq`git rev-parse --show-toplevel`.quiet()).text().trim(),_=!0}catch{let R=vQ(import.meta.dir);if(!R)return console.error("Error: Could not determine repository root. Please run this script from within the repository."),1;Q=R,_=!1}let $=await b(),J,Y=!1;if(X.sharedSpec&&$.mode==="multi-repo")J=n.join($.speckRoot,"specs"),Y=!0;else J=n.join(Q,"specs");l6(J,{recursive:!0});let H;if(X.shortName)H=zX(X.shortName);else H=TQ(X.featureDescription);let W;if(X.number!==void 0)W=X.number;else if(_)W=await RQ(H,J);else W=IQ(J)+1;let G=W.toString().padStart(3,"0"),z=`${G}-${H}`,U=244;if(z.length>U){let O=U-4,R=H.substring(0,O).replace(/-$/,"");console.error("[specify] Warning: Branch name exceeded GitHub's 244-byte limit"),console.error(`[specify] Original: ${z} (${z.length} bytes)`),z=`${G}-${R}`,console.error(`[specify] Truncated to: ${z} (${z.length} bytes)`)}if(_)try{await Oq`git checkout -b ${z}`}catch(O){return console.error(`Error: Failed to create git branch: ${String(O)}`),1}else console.error(`[specify] Warning: Git repository not detected; skipped branch creation for ${z}`);if(Y&&$.mode==="multi-repo"){let O=$.speckRoot,R=!1;try{if((await Oq`git -C ${O} rev-parse --git-dir`.quiet()).exitCode===0)R=!0}catch{}if(!R)console.error(`[specify] Notice: Parent directory is not a git repository: ${O}`),console.error("[specify] To enable branch coordination, initialize it as a git repo:"),console.error(`[specify]   cd ${O} && git init`),console.error("[specify] Skipping parent branch creation for now.");else try{let N=!1;try{N=(await Oq`git -C ${O} rev-parse --verify ${z}`.quiet()).exitCode===0}catch{N=!1}if(N){if(await Oq`git -C ${O} checkout ${z}`.quiet(),!X.json)console.log(`[specify] Checked out existing branch in parent repo: ${z}`)}else{let u=await Oq`git -C ${O} checkout -b ${z}`.quiet();if(u.exitCode!==0)throw Error(`git checkout -b failed with exit code ${String(u.exitCode)}: ${String(u.stderr)}`);if(!X.json)console.log(`[specify] Created branch in parent repo: ${z}`)}}catch(N){console.error(`[specify] Warning: Failed to create branch in parent repo: ${String(N)}`),console.error(`[specify] Parent repo: ${O}`),console.error(`[specify] You may need to manually create the branch: git -C ${O} checkout -b ${z}`)}}let L=n.join(J,z);l6(L,{recursive:!0});let A=n.join(fq(),"spec-template.md"),P=n.join(L,"spec.md");if(U3(A))EQ(A,P);else await Bun.write(P,"");if(X.sharedSpec&&$.mode==="multi-repo"){let O=n.join(Q,"specs",z);l6(O,{recursive:!0});let R=n.join(O,"spec.md"),N=n.relative(O,P);try{SQ(N,R,"file")}catch(u){if(u.code!=="EEXIST"){let Aq=u instanceof Error?u.message:String(u);console.error(`Warning: Failed to create symlink for spec.md: ${Aq}`),console.error(`  From: ${R}`),console.error(`  To: ${P}`)}}}if(process.env.SPECIFY_FEATURE=z,X.json)console.log(JSON.stringify({BRANCH_NAME:z,SPEC_FILE:P,FEATURE_NUM:G}));else console.log(`BRANCH_NAME: ${z}`),console.log(`SPEC_FILE: ${P}`),console.log(`FEATURE_NUM: ${G}`),console.log(`SPECIFY_FEATURE environment variable set to: ${z}`);return 0}var MX=Z(async()=>{w3();o()});var VX={};wq(VX,{main:()=>xQ});import{existsSync as jX,mkdirSync as kQ,copyFileSync as CQ}from"fs";import fQ from"path";var{$:k3}=globalThis.Bun;function ZQ(q){return{json:q.includes("--json"),help:q.includes("--help")||q.includes("-h")}}function bQ(){console.log(`Usage: setup-plan [--json]
  --json    Output results in JSON format
  --help    Show this help message`)}async function xQ(q){let X=ZQ(q);if(X.help)return bQ(),0;let Q=await p(),_=Q.HAS_GIT==="true";if(!await D3(Q.CURRENT_BRANCH,_,Q.REPO_ROOT))return 1;kQ(Q.FEATURE_DIR,{recursive:!0});let $=Q.CURRENT_BRANCH,J=await b();if(_){try{if((await k3`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()!==$)try{await k3`git checkout ${$}`.quiet(),console.log(`[specify] Checked out branch: ${$}`)}catch{await k3`git checkout -b ${$}`.quiet(),console.log(`[specify] Created and checked out branch: ${$}`)}}catch(G){console.error(`[specify] Warning: Could not manage git branch: ${String(G)}`)}let H=Q.FEATURE_SPEC;if(J.mode==="multi-repo"&&jX(H)){let G=J.speckRoot,z=!1;try{if((await k3`git -C ${G} rev-parse --git-dir`.quiet()).exitCode===0)z=!0}catch{}if(z)try{let L=(await k3`git -C ${G} rev-parse --abbrev-ref HEAD`.quiet()).text().trim();if(L!==$)console.error("[specify] Warning: Parent repo branch mismatch!"),console.error(`[specify]   Child repo (current): ${$}`),console.error(`[specify]   Parent repo: ${L}`),console.error(`[specify]   Parent location: ${G}`),console.error("[specify] Consider checking out matching branch in parent:"),console.error(`[specify]   git -C ${G} checkout ${$}`)}catch(U){console.error(`[specify] Warning: Could not check parent repo branch: ${String(U)}`)}}}let Y=fQ.join(fq(),"plan-template.md");if(jX(Y))CQ(Y,Q.IMPL_PLAN),console.log(`Copied plan template to ${Q.IMPL_PLAN}`);else console.log(`Warning: Plan template not found at ${Y}`),await Bun.write(Q.IMPL_PLAN,"");if(X.json){let H={FEATURE_SPEC:Q.FEATURE_SPEC,IMPL_PLAN:Q.IMPL_PLAN,SPECS_DIR:Q.FEATURE_DIR,BRANCH:Q.CURRENT_BRANCH,HAS_GIT:Q.HAS_GIT};console.log(JSON.stringify(H))}else console.log(`FEATURE_SPEC: ${Q.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${Q.IMPL_PLAN}`),console.log(`SPECS_DIR: ${Q.FEATURE_DIR}`),console.log(`BRANCH: ${Q.CURRENT_BRANCH}`),console.log(`HAS_GIT: ${Q.HAS_GIT}`);return 0}var LX=Z(async()=>{o();w3()});var OX={};wq(OX,{main:()=>hQ,linkRepo:()=>KX});import Qq from"fs/promises";import C3 from"path";async function KX(q){if(!q||q.trim()==="")throw Error(`Missing required argument: path-to-speck-root
Usage: /speck.link <path>
Examples:
  /speck.link ..          (parent directory)
  /speck.link ../..       (grandparent, for monorepo)
  /speck.link /abs/path   (absolute path)`);let X=await B3(),Q=C3.resolve(X,q);try{if(!(await Qq.stat(Q)).isDirectory())throw Error(`Target is not a directory: ${Q}`)}catch(H){if(H.code==="ENOENT")throw Error(`Target does not exist: ${Q}`);throw H}let _=C3.join(X,".speck","root"),$=C3.dirname(_),J=C3.relative($,Q);try{if(!(await Qq.lstat(_)).isSymbolicLink())throw Error(`.speck/root exists but is not a symlink
Fix: mv .speck/root .speck/root.backup && /speck.link `+q);let W=await Qq.readlink(_);if(await Qq.realpath(_)===Q){console.log(`\u2713 Already linked to ${J}`),console.log(`  Speck Root: ${Q}`);return}console.log(`Updating link from ${W} to ${J}`),await Qq.unlink(_)}catch(H){if(H.code!=="ENOENT")throw H}try{await Qq.symlink(J,_,"dir")}catch(H){let W=H;if(process.platform==="win32"&&(W.code==="EPERM"||W.code==="EACCES"))throw Error(`Symlink creation failed (Windows requires Developer Mode or WSL)

Fix options:
  1. Enable Developer Mode:
`+`     - Settings \u2192 Update & Security \u2192 For developers \u2192 Developer Mode
`+`  2. Use WSL (Windows Subsystem for Linux):
     - Run Speck commands from WSL terminal
  3. Create symlink manually with admin privileges:
     - mklink /D .speck\\root `+q.replace(/\//g,"\\"));throw H}V6();let Y=await b();if(Y.mode!=="multi-repo")throw Error(`Link created but detection failed - this is a bug
Please report at https://github.com/nprbst/speck/issues`);await yQ(X),console.log("\u2713 Multi-repo mode enabled"),console.log(`  Speck Root: ${Y.speckRoot}`),console.log(`  Repo Root: ${Y.repoRoot}`),console.log(`  Specs: ${Y.specsDir}`),console.log(`
Next steps:`),console.log('  1. Create shared spec: /speck.specify "Feature description"'),console.log("  2. Generate local plan: /speck.plan"),console.log("  3. Check configuration: /speck.env")}async function yQ(q){let X=C3.join(q,".gitignore");try{let Q="";try{Q=await Qq.readFile(X,"utf-8")}catch(Y){if(Y.code!=="ENOENT")throw Y}let _=Q.includes("specs/*/spec.md"),$=Q.includes("specs/*/contracts/");if(_&&$)return;let J=[];if(!Q.endsWith(`
`)&&Q.length>0)J.push("");if(!_||!$)J.push("# Speck multi-repo: ignore symlinked shared files");if(!_)J.push("specs/*/spec.md");if(!$)J.push("specs/*/contracts/");if(J.length>0){let Y=Q+`
`+J.join(`
`)+`
`;await Qq.writeFile(X,Y,"utf-8"),console.log("\u2713 Added .gitignore patterns for symlinked files")}}catch(Q){let _=Q instanceof Error?Q.message:String(Q);console.warn(`Warning: Could not update .gitignore: ${_}`)}}async function hQ(q){if(q.length===0)return console.error(`ERROR: Missing argument
`),console.error(`Usage: bun run .speck/scripts/link-repo.ts <path>
`),console.error("Examples:"),console.error("  bun run .speck/scripts/link-repo.ts .."),console.error("  bun run .speck/scripts/link-repo.ts ../.."),1;try{return await KX(q[0]),0}catch(X){let Q=X instanceof Error?X.message:String(X);return console.error("ERROR:",Q),1}}var AX=Z(async()=>{o()});var DX={};wq(DX,{main:()=>aQ});import{existsSync as M3,mkdirSync as gQ,readFileSync as m6,writeFileSync as BX}from"fs";import h from"path";function lQ(q){return{claude:h.join(q,"CLAUDE.md"),gemini:h.join(q,"GEMINI.md"),copilot:h.join(q,".github/agents/copilot-instructions.md"),"cursor-agent":h.join(q,".cursor/rules/specify-rules.mdc"),qwen:h.join(q,"QWEN.md"),opencode:h.join(q,"AGENTS.md"),codex:h.join(q,"AGENTS.md"),windsurf:h.join(q,".windsurf/rules/specify-rules.md"),kilocode:h.join(q,".kilocode/rules/specify-rules.md"),auggie:h.join(q,".augment/rules/specify-rules.md"),roo:h.join(q,".roo/rules/specify-rules.md"),codebuddy:h.join(q,"CODEBUDDY.md"),amp:h.join(q,"AGENTS.md"),shai:h.join(q,"SHAI.md"),q:h.join(q,"AGENTS.md")}}function a3(q,X){let Q=new RegExp(`^\\*\\*${q}\\*\\*: (.+)$`,"m"),_=X.match(Q);if(!_||!_[1])return"";let $=_[1].trim();if($==="NEEDS CLARIFICATION"||$==="N/A")return"";return $}function uQ(q){if(!M3(q))console.error(`ERROR: Plan file not found: ${q}`),process.exit(1);let X=m6(q,"utf-8"),Q=a3("Language/Version",X),_=a3("Primary Dependencies",X),$=a3("Storage",X),J=a3("Project Type",X);if(Q)console.log(`INFO: Found language: ${Q}`);else console.error("WARNING: No language information found in plan");if(_)console.log(`INFO: Found framework: ${_}`);if($&&$!=="N/A")console.log(`INFO: Found database: ${$}`);if(J)console.log(`INFO: Found project type: ${J}`);return{lang:Q,framework:_,db:$,projectType:J}}function mQ(q,X){let Q=[];if(q&&q!=="NEEDS CLARIFICATION")Q.push(q);if(X&&X!=="NEEDS CLARIFICATION"&&X!=="N/A")Q.push(X);return Q.join(" + ")}function dQ(q){if(q?.toLowerCase().includes("web"))return`backend/
frontend/
tests/`;return`src/
tests/`}function cQ(q){if(q?.includes("Python"))return"cd src && pytest && ruff check .";else if(q?.includes("Rust"))return"cargo test && cargo clippy";else if(q?.includes("JavaScript")||q?.includes("TypeScript"))return"npm test && npm run lint";return`# Add commands for ${q??"Unknown"}`}function pQ(q){return`${q??"Unknown"}: Follow standard conventions`}function iQ(q,X,Q,_,$,J,Y,H){if(!M3(X))console.error(`ERROR: Template not found at ${X}`),process.exit(1);console.log("INFO: Creating new agent context file from template...");let W=m6(X,"utf-8"),G="",z="";if(J&&Y)G=`- ${J} + ${Y} (${$})`,z=`- ${$}: Added ${J} + ${Y}`;else if(J)G=`- ${J} (${$})`,z=`- ${$}: Added ${J}`;else if(Y)G=`- ${Y} (${$})`,z=`- ${$}: Added ${Y}`;else G=`- (${$})`,z=`- ${$}: Added`;let U=dQ(H),L=cQ(J),A=pQ(J);W=W.replace(/\[PROJECT NAME\]/g,Q),W=W.replace(/\[DATE\]/g,_),W=W.replace(/\[EXTRACTED FROM ALL PLAN\.MD FILES\]/g,G),W=W.replace(/\[ACTUAL STRUCTURE FROM PLANS\]/g,U),W=W.replace(/\[ONLY COMMANDS FOR ACTIVE TECHNOLOGIES\]/g,L),W=W.replace(/\[LANGUAGE-SPECIFIC, ONLY FOR LANGUAGES IN USE\]/g,A),W=W.replace(/\[LAST 3 FEATURES AND WHAT THEY ADDED\]/g,z),BX(q,W,"utf-8"),console.log("\u2713 Created new agent context file")}function nQ(q,X,Q,_,$,J){console.log("INFO: Updating existing agent context file...");let Y=m6(q,"utf-8"),H=Y.split(`
`),W=[],G=mQ(_,$),z=[],U="";if(G&&!Y.includes(G))z.push(`- ${G} (${Q})`);if(J&&J!=="N/A"&&J!=="NEEDS CLARIFICATION"&&!Y.includes(J))z.push(`- ${J} (${Q})`);if(G)U=`- ${Q}: Added ${G}`;else if(J&&J!=="N/A"&&J!=="NEEDS CLARIFICATION")U=`- ${Q}: Added ${J}`;let L=!1,A=!1,P=!1,O=0;for(let R=0;R<H.length;R++){let N=H[R];if(N===void 0)continue;if(N==="## Active Technologies"){W.push(N),L=!0;continue}else if(L&&N.match(/^##\s/)){if(!P&&z.length>0)W.push(...z),P=!0;W.push(N),L=!1;continue}else if(L&&N===""){if(!P&&z.length>0)W.push(...z),P=!0;W.push(N);continue}if(N==="## Recent Changes"){if(W.push(N),U)W.push(U);A=!0;continue}else if(A&&N.match(/^##\s/)){W.push(N),A=!1;continue}else if(A&&N.startsWith("- ")){if(O<2)W.push(N),O++;continue}if(N.match(/\*\*Last updated\*\*:.*\d{4}-\d{2}-\d{2}/))W.push(N.replace(/\d{4}-\d{2}-\d{2}/,X));else W.push(N)}BX(q,W.join(`
`),"utf-8"),console.log("\u2713 Updated existing agent context file")}function u6(q,X,Q,_,$,J,Y,H){console.log(`INFO: Updating ${X} context file: ${q}`);let W=h.basename(Q),G=new Date().toISOString().split("T")[0],z=h.dirname(q);if(!M3(z))gQ(z,{recursive:!0});let U=h.join(fq(),"agent-file-template.md");if(!M3(q))iQ(q,U,W,G,_,$,J,H);else nQ(q,G,_,$,J,Y)}function sQ(q,X,Q,_,$,J,Y,H){let W={claude:"Claude Code",gemini:"Gemini CLI",copilot:"GitHub Copilot","cursor-agent":"Cursor IDE",qwen:"Qwen Code",opencode:"opencode",codex:"Codex CLI",windsurf:"Windsurf",kilocode:"Kilo Code",auggie:"Auggie CLI",roo:"Roo Code",codebuddy:"CodeBuddy CLI",amp:"Amp",shai:"SHAI",q:"Amazon Q Developer CLI"};if(!(q in X))console.error(`ERROR: Unknown agent type '${q}'`),console.error("Expected: claude|gemini|copilot|cursor-agent|qwen|opencode|codex|windsurf|kilocode|auggie|roo|amp|shai|q"),process.exit(1);let G=X[q],z=W[q];u6(G,z,Q,_,$,J,Y,H)}function oQ(q,X,Q,_,$,J,Y){let H=!1,W=[{key:"claude",name:"Claude Code"},{key:"gemini",name:"Gemini CLI"},{key:"copilot",name:"GitHub Copilot"},{key:"cursor-agent",name:"Cursor IDE"},{key:"qwen",name:"Qwen Code"},{key:"opencode",name:"Codex/opencode"},{key:"windsurf",name:"Windsurf"},{key:"kilocode",name:"Kilo Code"},{key:"auggie",name:"Auggie CLI"},{key:"roo",name:"Roo Code"},{key:"codebuddy",name:"CodeBuddy CLI"},{key:"shai",name:"SHAI"},{key:"q",name:"Amazon Q Developer CLI"}];for(let{key:G,name:z}of W){let U=q[G];if(M3(U))u6(U,z,X,Q,_,$,J,Y),H=!0}if(!H)console.log("INFO: No existing agent files found, creating default Claude file..."),u6(q.claude,"Claude Code",X,Q,_,$,J,Y)}function rQ(q,X,Q){if(console.log(""),console.log("INFO: Summary of changes:"),q)console.log(`  - Added language: ${q}`);if(X)console.log(`  - Added framework: ${X}`);if(Q&&Q!=="N/A")console.log(`  - Added database: ${Q}`);console.log(""),console.log("INFO: Usage: update-agent-context [claude|gemini|copilot|cursor-agent|qwen|opencode|codex|windsurf|kilocode|auggie|codebuddy|shai|q]")}async function aQ(q){let X=q[0]||"",Q=await p();if(!Q.CURRENT_BRANCH){if(console.error("ERROR: Unable to determine current feature"),Q.HAS_GIT==="true")console.log("INFO: Make sure you're on a feature branch");else console.log("INFO: Set SPECIFY_FEATURE environment variable or create a feature first");return 1}if(!M3(Q.IMPL_PLAN)){if(console.error(`ERROR: No plan.md found at ${Q.IMPL_PLAN}`),console.log("INFO: Make sure you're working on a feature with a corresponding spec directory"),Q.HAS_GIT!=="true")console.log("INFO: Use: export SPECIFY_FEATURE=your-feature-name or create a new feature first");return 1}console.log(`INFO: === Updating agent context files for feature ${Q.CURRENT_BRANCH} ===`);let _=uQ(Q.IMPL_PLAN),$=lQ(Q.REPO_ROOT);if(!X)console.log("INFO: No agent specified, updating all existing agent files..."),oQ($,Q.REPO_ROOT,Q.CURRENT_BRANCH,_.lang,_.framework,_.db,_.projectType);else console.log(`INFO: Updating specific agent: ${X}`),sQ(X,$,Q.REPO_ROOT,Q.CURRENT_BRANCH,_.lang,_.framework,_.db,_.projectType);return rQ(_.lang,_.framework,_.db),console.log("\u2713 Agent context update completed successfully"),0}var wX=Z(async()=>{o();w3()});var W8=_6(H8(),1),{program:A2,createCommand:B2,createArgument:D2,createOption:w2,CommanderError:E2,InvalidArgumentError:S2,InvalidOptionArgumentError:F2,Command:G8,Argument:N2,Option:v2,Help:I2}=W8.default;function Jq(){if(process.argv.includes("--hook"))return"hook";return process.stdin.isTTY===!1?"hook":"cli"}async function z8(){try{let q=await Bun.stdin.text(),X=JSON.parse(q);if(!X.tool_input||typeof X.tool_input.command!=="string")throw Error("Invalid hook input: missing tool_input.command field");return X}catch(q){if(q instanceof SyntaxError)throw Error(`Failed to parse hook input JSON: ${q.message}`);throw q}}function U8(q,X){return{hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"allow",updatedInput:{...X,command:`cat << 'OUTPUT_EOF'
${q}
OUTPUT_EOF`}}}}function M6(){return{}}class s extends Error{exitCode;metadata;constructor(q,X=1,Q){super(q);this.exitCode=X;this.metadata=Q;this.name="CommandError",Error.captureStackTrace(this,s)}}function O1(q){let X=q.message;if(process.stderr.isTTY)return`\x1B[31mError:\x1B[0m ${X}`;return`Error: ${X}`}function M8(q){let X=q instanceof s,Q=X?q.exitCode:1,_=X?q.metadata:void 0;return{success:!1,output:"",errorOutput:q.message,exitCode:Q,metadata:_??null}}function j8(q,X){if(X==="hook")return M8(q);return O1(q)}function pq(q){return M8(q)}var V8={INVALID_ARGUMENTS:(q)=>new s(`Invalid arguments: ${q}`,1),MISSING_REQUIRED_ARG:(q)=>new s(`Missing required argument: ${q}`,1),COMMAND_NOT_FOUND:(q)=>new s(`Command not found: ${q}`,127),PERMISSION_DENIED:(q)=>new s(`Permission denied: ${q}`,126),FILE_NOT_FOUND:(q)=>new s(`File not found: ${q}`,2),INVALID_STATE:(q)=>new s(`Invalid state: ${q}`,1),EXECUTION_FAILED:(q)=>new s(`Execution failed: ${q}`,1)};function b3(q,X){return{success:!0,output:q,errorOutput:null,exitCode:0,metadata:X??null}}var L8=(q)=>{let X=q.trim().split(/\s+/);if(X[0]==="speck-echo"||X[0]==="echo")X.shift();return{message:X.join(" ")}},K8=async(q)=>{try{if(!q.message)throw V8.MISSING_REQUIRED_ARG("message");let X=q.message;return b3(X,{message:q.message})}catch(X){return pq(X instanceof Error?X:Error(String(X)))}};o();var w8=async(q,X)=>{try{let Q=await b(),$=["Speck Environment","================",`Speck Root: ${Q.speckRoot}`,`Repo Root: ${Q.repoRoot}`,`Mode: ${Q.mode}`,`Execution Mode: ${X.mode}`,`Working Directory: ${X.workingDirectory}`,`Interactive: ${X.isInteractive}`].join(`
`);return b3($,{speckRoot:Q.speckRoot,repoRoot:Q.repoRoot,configMode:Q.mode,executionMode:X.mode,workingDirectory:X.workingDirectory,isInteractive:X.isInteractive})}catch(Q){return pq(Q instanceof Error?Q:Error(String(Q)))}};o();w3();import{existsSync as jq,readdirSync as S8,readFileSync as B6,statSync as v1}from"fs";import{join as bq,basename as I1}from"path";function D6(q,X=[]){if(!jq(q))return X;try{let Q=S8(q);for(let _ of Q){let $=bq(q,_);try{let J=v1($);if(J.isDirectory())D6($,X);else if(J.isFile())X.push($)}catch{continue}}}catch{}return X}function R1(q){return{json:q.includes("--json"),requireTasks:q.includes("--require-tasks"),includeTasks:q.includes("--include-tasks"),pathsOnly:q.includes("--paths-only"),skipFeatureCheck:q.includes("--skip-feature-check"),skipPlanCheck:q.includes("--skip-plan-check"),help:q.includes("--help")||q.includes("-h"),includeFileContents:q.includes("--include-file-contents"),includeWorkflowMode:q.includes("--include-workflow-mode"),validateCodeQuality:q.includes("--validate-code-quality")}}function T1(){console.log(`Usage: check-prerequisites.ts [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json                   Output in JSON format
  --require-tasks          Require tasks.md to exist (for implementation phase)
  --include-tasks          Include tasks.md in AVAILABLE_DOCS list
  --paths-only             Only output path variables (no prerequisite validation)
  --skip-feature-check     Skip feature directory and plan.md validation (for /speck.specify)
  --skip-plan-check        Skip plan.md validation but check feature directory (for /speck.plan)
  --validate-code-quality  Validate TypeScript typecheck and ESLint (Constitution Principle IX)
  --include-file-contents  Include file contents in JSON output
  --include-workflow-mode  Include workflow mode in JSON output
  --help, -h               Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  bun .speck/scripts/check-prerequisites.ts --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  bun .speck/scripts/check-prerequisites.ts --json --require-tasks --include-tasks

  # Validate code quality before feature completion
  bun .speck/scripts/check-prerequisites.ts --validate-code-quality

  # Get feature paths only (no validation)
  bun .speck/scripts/check-prerequisites.ts --paths-only
`)}function P1(q,X){if(X){let Q={MODE:q.MODE,REPO_ROOT:q.REPO_ROOT,BRANCH:q.CURRENT_BRANCH,FEATURE_DIR:q.FEATURE_DIR,FEATURE_SPEC:q.FEATURE_SPEC,IMPL_PLAN:q.IMPL_PLAN,TASKS:q.TASKS};console.log(JSON.stringify(Q))}else console.log(`MODE: ${q.MODE}`),console.log(`REPO_ROOT: ${q.REPO_ROOT}`),console.log(`BRANCH: ${q.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${q.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${q.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${q.IMPL_PLAN}`),console.log(`TASKS: ${q.TASKS}`)}function k1(q){let X=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--skip-plan-check","--help","-h","--include-file-contents","--include-workflow-mode","--validate-code-quality"];for(let Q of q)if(Q.startsWith("--")||Q.startsWith("-")){if(!X.includes(Q))console.error(`ERROR: Unknown option '${Q}'. Use --help for usage information.`),process.exit(1)}}var E8={maxSingleFile:24576,maxTotalFiles:102400};function Zq(q,X){if(!jq(q))return"NOT_FOUND";try{let _=Bun.file(q).size;if(_>E8.maxSingleFile)return"TOO_LARGE";if(X.value+_>E8.maxTotalFiles)return"TOO_LARGE";let $=B6(q,"utf-8");return X.value+=_,$}catch(Q){return"NOT_FOUND"}}async function C1(q){let{$:X}=awaitPromise.resolve(globalThis.Bun),Q=await X`bun run typecheck`.cwd(q).nothrow().quiet();if(Q.exitCode!==0)return{passed:!1,message:`\u274C TypeScript validation failed (exit code ${Q.exitCode})
${Q.stderr.toString()}`};let _=await X`bun run lint`.cwd(q).nothrow().quiet();if(_.exitCode!==0){let $=_.stdout.toString();return{passed:!1,message:`\u274C ESLint validation failed (exit code ${_.exitCode})
${$}`}}return{passed:!0,message:"\u2705 Code quality validation passed (0 typecheck errors, 0 lint errors/warnings)"}}function f1(q,X){let Q=bq(q,"plan.md");if(jq(Q))try{let J=B6(Q,"utf-8").match(/\*\*Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(J&&J[1])return J[1]}catch{}let _=bq(X,".speck","memory","constitution.md");if(jq(_))try{let J=B6(_,"utf-8").match(/\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(J&&J[1])return J[1]}catch{}return"single-branch"}async function F8(q){if(!q.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: Direct invocation deprecated. Prerequisites are now auto-checked via PrePromptSubmit hook.\x1B[0m
`);k1(q);let X=R1(q);if(X.help)return T1(),0;let Q=await p(),_=Q.HAS_GIT==="true";if(!X.skipFeatureCheck){if(!await D3(Q.CURRENT_BRANCH,_,Q.REPO_ROOT))return 1}if(X.pathsOnly||X.skipFeatureCheck)return P1(Q,X.json),0;if(!jq(Q.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${Q.FEATURE_DIR}`),console.error("Run /speck.specify first to create the feature structure."),1;if(!X.skipPlanCheck&&!jq(Q.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${Q.FEATURE_DIR}`),console.error("Run /speck.plan first to create the implementation plan."),1;if(X.requireTasks&&!jq(Q.TASKS))return console.error(`ERROR: tasks.md not found in ${Q.FEATURE_DIR}`),console.error("Run /speck.tasks first to create the task list."),1;let $=[],J=D6(Q.FEATURE_DIR);$.push(...J);let Y=bq(Q.SPECK_ROOT,".speck","linked-repos.md");if(jq(Y))$.push(Y);let H=I1(Q.FEATURE_DIR),W=bq(Q.REPO_ROOT,"specs",H);if(W!==Q.FEATURE_DIR){let L=D6(W);$.push(...L)}let G=X.includeTasks?$:$.filter((L)=>!L.endsWith("tasks.md")),z;if(X.includeFileContents){z={};let L={value:0};z["tasks.md"]=Zq(Q.TASKS,L),z["plan.md"]=Zq(Q.IMPL_PLAN,L),z["spec.md"]=Zq(Q.FEATURE_SPEC,L);let A=bq(Q.REPO_ROOT,".speck","memory","constitution.md");if(z["constitution.md"]=Zq(A,L),z["data-model.md"]=Zq(Q.DATA_MODEL,L),z["research.md"]=Zq(Q.RESEARCH,L),jq(Q.CHECKLISTS_DIR))try{let P=S8(Q.CHECKLISTS_DIR).filter((O)=>O.endsWith(".md"));for(let O of P){let R=bq(Q.CHECKLISTS_DIR,O);z[`checklists/${O}`]=Zq(R,L)}}catch{}}let U;if(X.includeWorkflowMode)U=f1(Q.FEATURE_DIR,Q.REPO_ROOT);if(X.validateCodeQuality){let L=await C1(Q.REPO_ROOT);if(!L.passed)return console.error(`
`+L.message),console.error(`
Constitution Principle IX requires zero typecheck errors and zero lint errors/warnings.`),console.error(`Fix all issues before marking the feature complete.
`),1;if(!X.json)console.log(`
`+L.message+`
`)}if(X.json){let L={MODE:Q.MODE,FEATURE_DIR:Q.FEATURE_DIR,AVAILABLE_DOCS:G,...z&&{FILE_CONTENTS:z},...U&&{WORKFLOW_MODE:U},IMPL_PLAN:Q.IMPL_PLAN,TASKS:Q.TASKS,REPO_ROOT:Q.REPO_ROOT};console.log(JSON.stringify(L))}else{console.log(`FEATURE_DIR:${Q.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:");for(let L of G)console.log(`  \u2713 ${L}`)}return 0}var tQ=async()=>{return(await $X().then(() => _X)).main},eQ=async()=>{return(await WX().then(() => HX)).main},q2=async()=>{return(await MX().then(() => UX)).main},X2=async()=>{return(await LX().then(() => VX)).main},Q2=async()=>{return(await AX().then(() => OX)).main},_2=async()=>{return(await wX().then(() => DX)).main},_q={echo:{handler:K8,parseArgs:L8,description:"Echo back the provided message",version:"1.0.0"},env:{handler:w8,lazyMain:eQ,description:"Show Speck environment and configuration info",version:"1.0.0"},branch:{lazyMain:tQ,description:"Manage stacked feature branches",version:"1.0.0"},"check-prerequisites":{main:F8,parseArgs:(q)=>{let X=q.trim().split(/\s+/);if(X[0]==="speck-check-prerequisites"||X[0]==="check-prerequisites")X.shift();return X},description:"Validate feature directory structure and prerequisites",version:"1.0.0"},"create-new-feature":{lazyMain:q2,description:"Create new feature specification directory",version:"1.0.0"},"setup-plan":{lazyMain:X2,description:"Initialize planning workflow",version:"1.0.0"},"link-repo":{lazyMain:Q2,description:"Link repository to multi-repo speck root",version:"1.0.0"},"update-agent-context":{lazyMain:_2,description:"Update agent-specific context files with technology stack",version:"1.0.0"}};import{appendFile as $2}from"fs/promises";var J2="/tmp/speck-hook-debug.log",E=async(q)=>{try{await $2(J2,`[${new Date().toISOString()}] ${q}
`)}catch(X){}},zq=new G8;zq.name("speck").description("Speck unified CLI for feature specification workflow").version("0.1.0");var EX=_q.echo;zq.command("echo <message...>").description(EX.description).action(async(q)=>{let X=Array.isArray(q)?q.join(" "):String(q),Q={mode:Jq(),rawCommand:`echo ${X}`,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},_=await EX.handler({message:X},Q);if(_.success)console.log(_.output);else console.error(_.errorOutput),process.exit(_.exitCode)});var d6=_q.env;if(!d6)throw Error("env command not found in registry");zq.command("env").description(d6.description).action(async()=>{let q={mode:Jq(),rawCommand:"env",workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},X=await d6.handler({},q);if(X.success)console.log(X.output);else console.error(X.errorOutput),process.exit(X.exitCode)});var mq=_q.branch;if(!mq)throw Error("branch command not found in registry");zq.command("branch [args...]").description(mq.description).allowUnknownOption().action(async(q)=>{let X=Array.isArray(q)?q:[String(q)];if(mq.lazyMain){let _=await(await mq.lazyMain())(X);process.exit(_)}else if(mq.handler){let Q=`branch ${X.join(" ")}`,_={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=mq.parseArgs(Q),J=await mq.handler($,_);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)}});var j3=_q["check-prerequisites"];zq.command("check-prerequisites [args...]").description(j3.description).allowUnknownOption().action(async(q)=>{let X=Array.isArray(q)?q:[String(q)];if(j3.main){let Q=await j3.main(X);process.exit(Q)}else if(j3.handler){let Q=`check-prerequisites ${X.join(" ")}`,_={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=j3.parseArgs(Q),J=await j3.handler($,_);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)}});var V3=_q["create-new-feature"];zq.command("create-new-feature [args...]").description(V3.description).allowUnknownOption().action(async(q)=>{let X=Array.isArray(q)?q:[String(q)];if(V3.lazyMain){let _=await(await V3.lazyMain())(X);process.exit(_)}else if(V3.handler){let Q=`create-new-feature ${X.join(" ")}`,_={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=V3.parseArgs(Q),J=await V3.handler($,_);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)}});var L3=_q["setup-plan"];zq.command("setup-plan [args...]").description(L3.description).allowUnknownOption().action(async(q)=>{let X=Array.isArray(q)?q:[String(q)];if(L3.lazyMain){let _=await(await L3.lazyMain())(X);process.exit(_)}else if(L3.handler){let Q=`setup-plan ${X.join(" ")}`,_={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=L3.parseArgs(Q),J=await L3.handler($,_);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)}});var K3=_q["link-repo"];zq.command("link-repo [args...]").description(K3.description).allowUnknownOption().action(async(q)=>{let X=Array.isArray(q)?q:[String(q)];if(K3.lazyMain){let _=await(await K3.lazyMain())(X);process.exit(_)}else if(K3.handler){let Q=`link-repo ${X.join(" ")}`,_={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=K3.parseArgs(Q),J=await K3.handler($,_);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)}});var O3=_q["update-agent-context"];zq.command("update-agent-context [args...]").description(O3.description).allowUnknownOption().action(async(q)=>{let X=Array.isArray(q)?q:[String(q)];if(O3.lazyMain){let _=await(await O3.lazyMain())(X);process.exit(_)}else if(O3.handler){let Q=`update-agent-context ${X.join(" ")}`,_={mode:Jq(),rawCommand:Q,workingDirectory:process.cwd(),isInteractive:process.stdin.isTTY??!1},$=O3.parseArgs(Q),J=await O3.handler($,_);if(J.success)console.log(J.output);else console.error(J.errorOutput),process.exit(J.exitCode)}});async function Y2(){let q=Jq();if(await E("=== SPECK ENTRY POINT ==="),await E(`Detected mode: ${q}`),await E(`Process argv: ${JSON.stringify(process.argv)}`),await E(`stdin isTTY: ${process.stdin.isTTY}`),q==="hook")await E("Entering hook mode..."),await H2();else await E("Entering CLI mode..."),await W2()}async function H2(){try{await E("=== HOOK INVOKED ==="),await E(`Environment: ${process.env.CLAUDE_PLUGIN_ROOT||"NOT SET"}`),await E(`CWD: ${process.cwd()}`),await E(`Platform: ${process.platform}`);let q=await z8();await E(`Hook input received: ${JSON.stringify(q)}`);let{command:X}=q.tool_input;if(await E(`Speck hook called - Command: ${X}`),await E(`Command type: ${typeof X}`),!X.match(/^speck-/)){await E(`Skip (not speck-*): ${X}`),console.log(JSON.stringify(M6()));return}await E(`Intercepting speck command: ${X}`);let Q=X.match(/^speck-(.+?)(?:\s+(.*))?$/);if(!Q)console.error("Failed to parse command:",X),process.exit(1);let[,_,$=""]=Q,J=$.split(/\s+/).filter((A)=>A.length>0);await E(`Parsed command name: ${_}`),await E(`Parsed args: ${JSON.stringify(J)}`),await E(`Registry keys: ${JSON.stringify(Object.keys(_q))}`);let Y=_?_q[_]:void 0;if(!Y){await E(`Unknown command: ${_} (not in registry)`),console.error(`Unknown command: ${_}`),console.log(JSON.stringify(M6()));return}await E(`Command found in registry: ${_}`),await E(`Command entry has main: ${!!Y.main}`),await E(`Command entry has lazyMain: ${!!Y.lazyMain}`),await E(`Command entry has handler: ${!!Y.handler}`);let{log:H,error:W}=console,G="",z="";console.log=(...A)=>{G+=A.join(" ")+`
`},console.error=(...A)=>{z+=A.join(" ")+`
`};try{if(await E("Starting command execution..."),Y.main)await E("Executing via main function"),await Y.main(J),await E("main function completed");else if(Y.lazyMain){await E("Executing via lazyMain function");let A=await Y.lazyMain();await E("lazyMain loaded, executing..."),await A(J),await E("lazyMain function completed")}else if(Y.handler){await E("Executing via handler");let A={mode:"hook",rawCommand:X,workingDirectory:process.cwd(),isInteractive:!1},P=Y.parseArgs?Y.parseArgs(X):{};await E(`Parsed args for handler: ${JSON.stringify(P)}`);let O=await Y.handler(P,A);if(await E(`Handler result: success=${O.success}, output length=${O.output?.length||0}`),O.success&&O.output)G+=O.output;if(!O.success&&O.errorOutput)z+=O.errorOutput}else throw Error(`Command ${_} has no main, lazyMain, or handler`)}catch(A){await E(`Command execution error: ${A instanceof Error?A.message:String(A)}`),await E(`Error stack: ${A instanceof Error?A.stack:"N/A"}`);let P=pq(A instanceof Error?A:Error(String(A)));z+=P.errorOutput||""}console.log=H,console.error=W,await E(`Captured output length: ${G.length}`),await E(`Captured error output length: ${z.length}`),await E(`Output preview: ${G.substring(0,200)}`),await E(`Error output preview: ${z.substring(0,200)}`);let U=G.trim()||z.trim()||"",L=U8(U,q.tool_input);await E(`Returning result length: ${U.length}`),await E(`Result preview: ${U.substring(0,100)}`),await E(`Hook output: ${JSON.stringify(L).substring(0,200)}`),await E("=== HOOK COMPLETE ==="),console.log(JSON.stringify(L))}catch(q){await E("!!! HOOK ERROR !!!"),await E(`Hook error: ${q instanceof Error?q.message:String(q)}`),await E(`Error stack: ${q instanceof Error?q.stack:"N/A"}`),await E("=== HOOK FAILED ==="),console.error("Hook error:",q instanceof Error?q.message:String(q)),console.log("{}"),process.exit(1)}}async function W2(){try{await zq.parseAsync(process.argv)}catch(q){let X=j8(q instanceof Error?q:Error(String(q)),"cli");if(typeof X==="string")console.error(X);let Q=q instanceof s?q.exitCode:1;process.exit(Q)}}if(import.meta.main)Y2();
