// @bun
var $=Object.create;var{getPrototypeOf:B,defineProperty:T,getOwnPropertyNames:L}=Object;var I=Object.prototype.hasOwnProperty;var F=(j,w,A)=>{A=j!=null?$(B(j)):{};let q=w||!j||!j.__esModule?T(A,"default",{value:j,enumerable:!0}):A;for(let Q of L(j))if(!I.call(q,Q))T(q,Q,{get:()=>j[Q],enumerable:!0});return q};var k=(j,w)=>()=>(w||j((w={exports:{}}).exports,w),w.exports);var D=(j,w)=>{for(var A in w)T(j,A,{get:w[A],enumerable:!0,configurable:!0,set:(q)=>w[A]=()=>q})};var x=import.meta.require;import{existsSync as Z}from"fs";import{readdirSync as X}from"fs";import V from"fs/promises";import z from"path";var{$:O}=globalThis.Bun;function v(){if(process.env.CLAUDE_PLUGIN_ROOT)return!0;let j=import.meta.dir;return j.includes("/.claude/plugins/")||j.includes("/.config/claude-code/plugins/")}function M(){if(process.env.CLAUDE_PLUGIN_ROOT)return process.env.CLAUDE_PLUGIN_ROOT;let j=import.meta.dir;if(v())return z.resolve(j,"../../..");else return z.resolve(j,"../../..")}function g(){let j=M();if(v())return z.join(j,"templates");else return z.join(j,".speck/templates")}function l(){let j=M();return z.join(j,".speck/scripts")}function h(){let j=M();if(v())return z.join(j,"memory");else return z.join(j,".speck/memory")}async function E(){try{return(await O`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{let j=import.meta.dir;return z.resolve(j,"../../..")}}var _=null;function p(){_=null}async function K(){if(_)return _;let j=await E(),w=z.join(j,".speck","root");try{if(!(await V.lstat(w)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let W={mode:"single-repo",speckRoot:j,repoRoot:j,specsDir:z.join(j,"specs")};return _=W,W}let q=await V.realpath(w),Q=["/","/etc","/usr","/bin","/sbin","/System","/Library"],H=process.env.HOME||process.env.USERPROFILE||"";if(Q.some((W)=>q===W||q.startsWith(W+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${q}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(H&&q===z.dirname(H))throw Error(`Security: .speck/root symlink points above home directory: ${q}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await V.access(q);let U=z.join(j,"specs");try{if((await V.stat(U)).isDirectory()&&q!==j)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${U}
  Shared: ${z.join(q,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${U}/* ${z.join(q,"specs")}/
  2. Remove local specs: rm -rf ${U}
`)}catch(W){if(W.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${W.message}`)}let Y={mode:"multi-repo",speckRoot:q,repoRoot:j,specsDir:z.join(q,"specs")};return _=Y,Y}catch(A){if(A.code==="ENOENT"){if((await N(j)).length>0){let U={mode:"multi-repo",speckRoot:j,repoRoot:j,specsDir:z.join(j,"specs")};return _=U,U}let H={mode:"single-repo",speckRoot:j,repoRoot:j,specsDir:z.join(j,"specs")};return _=H,H}if(A.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let q=await V.readlink(w).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${q} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}var s=K;async function i(){let j=await K();return j.mode==="multi-repo"&&j.repoRoot!==j.speckRoot}async function C(j,w){try{let A=await V.realpath(j),q=await V.readdir(w,{withFileTypes:!0});for(let Q of q)if(Q.isSymbolicLink()&&Q.name.startsWith(".speck-link-")){let H=z.join(w,Q.name);try{if(await V.realpath(H)===A)return Q.name.replace(/^\.speck-link-/,"")}catch{continue}}}catch{}return z.basename(j)}async function N(j){let w=[];try{let A=await V.readdir(j,{withFileTypes:!0});for(let q of A)if(q.isSymbolicLink()&&q.name.startsWith(".speck-link-")){let Q=z.join(j,q.name);try{let H=await V.realpath(Q);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((W)=>H===W||H.startsWith(W+"/"))){console.warn(`Security: Skipping ${q.name} - points to system directory: ${H}`);continue}let Y=z.join(H,".git");try{await V.access(Y),w.push(H)}catch{console.warn(`Warning: ${q.name} points to non-git directory: ${H}`)}}catch(H){console.warn(`Warning: Broken symlink ${q.name}: ${H.message}`)}}}catch(A){if(A.code!=="ENOENT")throw A}return w}async function n(j){let w=new Map;try{let A=await V.readdir(j,{withFileTypes:!0});for(let q of A)if(q.isSymbolicLink()&&q.name.startsWith(".speck-link-")){let Q=z.join(j,q.name),H=q.name.substring(12);try{let U=await V.realpath(Q);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((J)=>U===J||U.startsWith(J+"/"))){console.warn(`Security: Skipping ${q.name} - points to system directory: ${U}`);continue}let W=z.join(U,".git");try{await V.access(W),w.set(H,U)}catch{console.warn(`Warning: ${q.name} points to non-git directory: ${U}`)}}catch(U){console.warn(`Warning: Broken symlink ${q.name}: ${U.message}`)}}}catch(A){if(A.code!=="ENOENT")throw A}return w}async function c(){let j=await K();if(j.mode==="single-repo")return{...j,context:"single",parentSpecId:null,childRepoName:null};if(j.repoRoot===j.speckRoot)return{...j,context:"root",parentSpecId:null,childRepoName:null};else{let w=await C(j.repoRoot,j.speckRoot),A=null;try{let q=z.join(j.repoRoot,".speck","branches.json"),Q=await V.readFile(q,"utf-8"),H=JSON.parse(Q);if(H.branches&&H.branches.length>0)A=H.branches[0].parentSpecId||null}catch{}if(!A)try{let{$:q}=awaitPromise.resolve(globalThis.Bun),H=(await q`git -C ${j.speckRoot} rev-parse --abbrev-ref HEAD`.quiet()).stdout.toString().trim();if(/^\d{3}-/.test(H))A=H}catch{}return{...j,context:"child",parentSpecId:A,childRepoName:w}}}async function S(j){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await O`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let w=z.join(j,"specs");if(Z(w)){let A="",q=0,Q=X(w,{withFileTypes:!0});for(let H of Q)if(H.isDirectory()){let U=H.name.match(/^(\d{3})-/);if(U){let Y=parseInt(U[1],10);if(Y>q)q=Y,A=H.name}}if(A)return A}return"main"}}async function P(){try{return await O`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function r(j){try{return(await O`git check-ref-format --branch ${j}`.quiet()).exitCode===0}catch{return!1}}async function a(j,w,A){if(!w)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let q=z.join(A,".speck","branches.json");if(Z(q))try{let Q=await V.readFile(q,"utf-8"),H=JSON.parse(Q);if(H.branches&&Array.isArray(H.branches)){if(H.branches.some((Y)=>Y.name===j))return!0}}catch{}if(!/^\d{3}-/.test(j))return console.error(`ERROR: Not on a feature branch. Current branch: ${j}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}function o(j,w){return z.join(j,"specs",w)}async function y(j,w,A){let q=z.join(A,".speck","branches.json");if(Z(q))try{let Y=await V.readFile(q,"utf-8"),W=JSON.parse(Y);if(W.branches&&Array.isArray(W.branches)){let J=W.branches.find((G)=>G.name===w);if(J&&J.specId)return z.join(j,J.specId)}}catch{}let Q=w.match(/^(\d{3})-/);if(!Q)return z.join(j,w);let H=Q[1],U=[];if(Z(j)){let Y=X(j,{withFileTypes:!0});for(let W of Y)if(W.isDirectory()&&W.name.startsWith(`${H}-`))U.push(W.name)}if(U.length===0)return z.join(j,w);else if(U.length===1)return z.join(j,U[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${H}': ${U.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),z.join(j,w)}async function t(){let j=await K(),w=await S(j.repoRoot),A=await P(),q=await y(j.specsDir,w,j.repoRoot),Q=z.basename(q);return{MODE:j.mode,SPECK_ROOT:j.speckRoot,SPECS_DIR:j.specsDir,REPO_ROOT:j.repoRoot,CURRENT_BRANCH:w,HAS_GIT:A?"true":"false",FEATURE_DIR:q,FEATURE_SPEC:z.join(q,"spec.md"),IMPL_PLAN:z.join(j.repoRoot,"specs",Q,"plan.md"),TASKS:z.join(j.repoRoot,"specs",Q,"tasks.md"),RESEARCH:z.join(q,"research.md"),DATA_MODEL:z.join(q,"data-model.md"),QUICKSTART:z.join(q,"quickstart.md"),CONTRACTS_DIR:z.join(q,"contracts")}}async function e(){try{let j=await E(),w=z.join(j,".speck/memory/constitution.md");if(!Z(w))return null;let q=(await V.readFile(w,"utf-8")).match(/^\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)\s*$/m);if(q&&(q[1]==="stacked-pr"||q[1]==="single-branch"))return q[1];return null}catch(j){return null}}function jj(j,w){return Z(j)?`  \u2713 ${w}`:`  \u2717 ${w}`}function qj(j,w){if(!Z(j))return`  \u2717 ${w}`;try{return X(j).length>0?`  \u2713 ${w}`:`  \u2717 ${w}`}catch{return`  \u2717 ${w}`}}async function wj(j){let w=await K();if(w.mode!=="multi-repo")return!1;let A=z.join(w.speckRoot,"specs",j,"contracts");if(!Z(A))return!1;let q=z.join(w.repoRoot,"specs",j);if(!Z(q))return!1;let Q=z.join(q,"contracts");try{if((await V.lstat(Q)).isSymbolicLink()){let Y=await V.readlink(Q);if(await V.realpath(Q)===A)return!0;await V.unlink(Q)}else return console.warn(`WARNING: Local contracts/ directory exists but is not a symlink
  Local: ${Q}
  Shared: ${A}
  Skipping symlink creation to preserve local data.`),!1}catch(U){if(U.code!=="ENOENT")throw U}let H=z.relative(q,A);try{return await V.symlink(H,Q,"dir"),!0}catch(U){return console.warn(`Warning: Failed to create contracts/ symlink: ${U.message}`),!1}}export{r as validateBranchName,wj as syncSharedContracts,v as isPluginInstallation,i as isMultiRepoChild,P as hasGit,g as getTemplatesDir,l as getScriptsDir,E as getRepoRoot,M as getPluginRoot,c as getMultiRepoContext,h as getMemoryDir,t as getFeaturePaths,o as getFeatureDir,e as getDefaultWorkflowMode,S as getCurrentBranch,C as getChildRepoName,y as findFeatureDirByPrefix,n as findChildReposWithNames,N as findChildRepos,K as detectSpeckRoot,s as detectSpeckMode,p as clearSpeckCache,jj as checkFile,a as checkFeatureBranch,qj as checkDir};
export{F as u,k as v,D as w,x,g as y,E as z,p as A,K as B,i as C,C as D,n as E,c as F,r as G,a as H,t as I,jj as J,qj as K};
