#!/usr/bin/env bun
// @bun
import"./speck-ac2ebaf8.js";import{B as W,y as G}from"./paths-qqmkr5wb.js";import{existsSync as L,mkdirSync as I,readdirSync as C,copyFileSync as F,symlinkSync as E}from"fs";import O from"path";var{$:_}=globalThis.Bun;function y(z){let j={json:!1,sharedSpec:!1,localSpec:!1,help:!1,featureDescription:""},Z=[],J=0;while(J<z.length){let q=z[J];if(q==="--json")j.json=!0,J++;else if(q==="--short-name"){if(J+1>=z.length||z[J+1]?.startsWith("--"))console.error("Error: --short-name requires a value"),process.exit(1);j.shortName=z[J+1],J+=2}else if(q==="--number"){if(J+1>=z.length||z[J+1]?.startsWith("--"))console.error("Error: --number requires a value"),process.exit(1);let Q=parseInt(z[J+1],10);if(isNaN(Q))console.error("Error: --number requires a numeric value"),process.exit(1);j.number=Q,J+=2}else if(q==="--shared-spec")j.sharedSpec=!0,J++;else if(q==="--local-spec")j.localSpec=!0,J++;else if(q==="--help"||q==="-h")j.help=!0,J++;else Z.push(q),J++}return j.featureDescription=Z.join(" "),j}function D(){let z=O.basename(process.argv[1]);console.log(`Usage: ${z} [--json] [--short-name <name>] [--number N] [--shared-spec | --local-spec] <feature_description>

Options:
  --json              Output in JSON format
  --short-name <name> Provide a custom short name (2-4 words) for the branch
  --number N          Specify branch number manually (overrides auto-detection)
  --shared-spec       Create spec at speckRoot (multi-repo shared spec with local symlinks)
  --local-spec        Create spec locally in child repo (single-repo or child-only spec)
  --help, -h          Show this help message

Examples:
  ${z} 'Add user authentication system' --short-name 'user-auth'
  ${z} 'Implement OAuth2 integration for API' --number 5 --shared-spec`)}function R(z){let j=z;while(j!=="/"){if(L(O.join(j,".git"))||L(O.join(j,".specify"))||L(O.join(j,".speck")))return j;j=O.dirname(j)}return null}function S(z){let j=0;if(L(z)){let Z=C(z,{withFileTypes:!0});for(let J of Z)if(J.isDirectory()){let q=J.name.match(/^(\d+)/);if(q&&q[1]){let Q=parseInt(q[1],10);if(Q>j)j=Q}}}return j}async function x(z,j){try{await _`git fetch --all --prune`.quiet()}catch{}let Z=0;try{let q=(await _`git ls-remote --heads origin`.quiet()).text().split(`
`);for(let Q of q){let K=Q.match(new RegExp(`refs/heads/(\\d+)-${z}$`));if(K&&K[1]){let M=parseInt(K[1],10);if(M>Z)Z=M}}}catch{}try{let q=(await _`git branch`.quiet()).text().split(`
`);for(let Q of q){let K=Q.match(new RegExp(`^[* ]*?(\\d+)-${z}$`));if(K&&K[1]){let M=parseInt(K[1],10);if(M>Z)Z=M}}}catch{}if(L(j)){let J=C(j,{withFileTypes:!0});for(let q of J)if(q.isDirectory()){let Q=q.name.match(new RegExp(`^(\\d+)-${z}$`));if(Q&&Q[1]){let K=parseInt(Q[1],10);if(K>Z)Z=K}}}return Z+1}function $(z){return z.toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/-+/g,"-").replace(/^-/,"").replace(/-$/,"")}function f(z){let j=new Set(["i","a","an","the","to","for","of","in","on","at","by","with","from","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","should","could","can","may","might","must","shall","this","that","these","those","my","your","our","their","want","need","add","get","set"]),J=z.toLowerCase().replace(/[^a-z0-9]+/g," ").split(/\s+/).filter((K)=>K.length>0),q=[];for(let K of J){if(j.has(K))continue;if(K.length>=3)q.push(K);else{let M=K.toUpperCase();if(z.includes(M))q.push(K)}}if(q.length>0){let K=q.length===4?4:3;return q.slice(0,K).join("-")}return $(z).split("-").filter((K)=>K.length>0).slice(0,3).join("-")}async function m(z){let j=y(z);if(j.help)return D(),0;if(!j.featureDescription)return console.error("Usage: create-new-feature [--json] [--short-name <name>] [--number N] <feature_description>"),1;let Z,J=!1;try{Z=(await _`git rev-parse --show-toplevel`.quiet()).text().trim(),J=!0}catch{let U=R(import.meta.dir);if(!U)return console.error("Error: Could not determine repository root. Please run this script from within the repository."),1;Z=U,J=!1}let q=await W(),Q,K=!1;if(j.sharedSpec&&q.mode==="multi-repo")Q=O.join(q.speckRoot,"specs"),K=!0;else Q=O.join(Z,"specs");I(Q,{recursive:!0});let M;if(j.shortName)M=$(j.shortName);else M=f(j.featureDescription);let A;if(j.number!==void 0)A=j.number;else if(J)A=await x(M,Q);else A=S(Q)+1;let H=A.toString().padStart(3,"0"),V=`${H}-${M}`,P=244;if(V.length>P){let X=P-4,U=M.substring(0,X).replace(/-$/,"");console.error("[specify] Warning: Branch name exceeded GitHub's 244-byte limit"),console.error(`[specify] Original: ${V} (${V.length} bytes)`),V=`${H}-${U}`,console.error(`[specify] Truncated to: ${V} (${V.length} bytes)`)}if(J)try{await _`git checkout -b ${V}`}catch(X){return console.error(`Error: Failed to create git branch: ${String(X)}`),1}else console.error(`[specify] Warning: Git repository not detected; skipped branch creation for ${V}`);if(K&&q.mode==="multi-repo"){let X=q.speckRoot,U=!1;try{if((await _`git -C ${X} rev-parse --git-dir`.quiet()).exitCode===0)U=!0}catch{}if(!U)console.error(`[specify] Notice: Parent directory is not a git repository: ${X}`),console.error("[specify] To enable branch coordination, initialize it as a git repo:"),console.error(`[specify]   cd ${X} && git init`),console.error("[specify] Skipping parent branch creation for now.");else try{let T=!1;try{T=(await _`git -C ${X} rev-parse --verify ${V}`.quiet()).exitCode===0}catch{T=!1}if(T){if(await _`git -C ${X} checkout ${V}`.quiet(),!j.json)console.log(`[specify] Checked out existing branch in parent repo: ${V}`)}else{let Y=await _`git -C ${X} checkout -b ${V}`.quiet();if(Y.exitCode!==0)throw Error(`git checkout -b failed with exit code ${String(Y.exitCode)}: ${String(Y.stderr)}`);if(!j.json)console.log(`[specify] Created branch in parent repo: ${V}`)}}catch(T){console.error(`[specify] Warning: Failed to create branch in parent repo: ${String(T)}`),console.error(`[specify] Parent repo: ${X}`),console.error(`[specify] You may need to manually create the branch: git -C ${X} checkout -b ${V}`)}}let k=O.join(Q,V);I(k,{recursive:!0});let B=O.join(G(),"spec-template.md"),v=O.join(k,"spec.md");if(L(B))F(B,v);else await Bun.write(v,"");if(j.sharedSpec&&q.mode==="multi-repo"){let X=O.join(Z,"specs",V);I(X,{recursive:!0});let U=O.join(X,"spec.md"),T=O.relative(X,v);try{E(T,U,"file")}catch(Y){if(Y.code!=="EEXIST"){let w=Y instanceof Error?Y.message:String(Y);console.error(`Warning: Failed to create symlink for spec.md: ${w}`),console.error(`  From: ${U}`),console.error(`  To: ${v}`)}}}if(process.env.SPECIFY_FEATURE=V,j.json)console.log(JSON.stringify({BRANCH_NAME:V,SPEC_FILE:v,FEATURE_NUM:H}));else console.log(`BRANCH_NAME: ${V}`),console.log(`SPEC_FILE: ${v}`),console.log(`FEATURE_NUM: ${H}`),console.log(`SPECIFY_FEATURE environment variable set to: ${V}`);return 0}export{m as main};
