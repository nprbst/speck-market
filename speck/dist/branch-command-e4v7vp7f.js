#!/usr/bin/env bun
// @bun
import{a as w,b as R,c as p,d as u,e as s,f as c,g as Wq,h as i,i as t,j as Xq,k as Yq,l as Zq,m as _q,n as Uq,o as Vq,p as m,q as n,r as zq,s as e,t as Lq}from"./speck-7546wgqm.js";import{B as d,C as Jq,D as Kq,F as o,G as Qq,I as F,u as Gq,x as Tq}from"./paths-x5kskk5z.js";import l from"path";import b from"fs/promises";var{$:f}=globalThis.Bun;async function Oq(q){try{let H=(await f`git -C ${q} symbolic-ref --short HEAD 2>/dev/null || git -C ${q} rev-parse --short HEAD 2>/dev/null`.quiet()).text().trim();if(H&&/^\d{3}-.+$/.test(H)){let W=l.join(q,"specs",H);try{return await b.access(W),H}catch{}}let K=l.join(q,"specs"),Y=(await b.readdir(K)).filter((W)=>/^\d{3}-.+$/.test(W));if(Y.length===0)return null;return Y.sort(),Y[Y.length-1]}catch{return null}}async function jq(){try{return(await f`which gh`.quiet()).exitCode===0}catch{return!1}}async function Eq(q,J,H){try{let K=await f`git -C ${H} log ${q}..${J} --format=%s%n%b`.quiet();if(K.exitCode!==0)return[];return K.stdout.toString().trim().split(`
`).filter((Q)=>Q.trim())}catch{return[]}}function $q(q){let J=[/^wip/i,/^fix$/i,/^tmp/i,/^temp/i,/^test/i,/^update$/i,/^merge/i,/^rebase/i,/^\./],H=q.trim().toLowerCase();return!J.some((K)=>K.test(H))&&H.length>5}function vq(q){if(q.length===0)return null;let J=q.filter((Q)=>Q.trim()&&$q(Q));if(J.length===0)return null;let H=J[0].split(`
`)[0],K=J.map((Q)=>`- ${Q.split(`
`)[0]}`).join(`
`);return{title:H,body:K}}async function Aq(q,J,H){try{let Q=(await f`git -C ${H} diff ${q}...${J} --stat`.quiet()).stdout.toString().trim(),W=(await f`git -C ${H} diff ${q}...${J} --name-status`.quiet()).stdout.toString().trim().split(`
`).filter((U)=>U.trim()),X=`Update ${J} (${W.length} files changed)`,V=`## Changes

${Q}

## Files Modified
${W.map((U)=>`- ${U}`).join(`
`)}`;return{title:X,body:V}}catch{return{title:`Update ${J}`,body:"Changes made on this branch"}}}function Dq(q,J,H){if(J)return J;return"main"}async function Pq(q,J,H,K,Q){if(Q?.context==="child"){if(!await Lq(K))return console.warn(`
\u26A0\uFE0F  WARNING: No remote configured for this repository.`),console.warn("Branch created locally. PR creation unavailable."),console.warn(`
To configure remote:`),console.warn("  git remote add origin <url>"),console.warn(`  git push -u origin <branch-name>
`),null}if(!await jq())return null;let W=u(H,q),X;if(Q?.context==="child")X=await e(K)||"main";else X=Dq(q,W?.baseBranch||null,K);let V=await Eq(X,q,K);if(V.length===0)return null;let U=vq(V);if(!U)U=await Aq(X,q,K);let L=U.title;if(Q?.childRepoName)L=`[${Q.childRepoName}] ${U.title}`;return{title:L,body:U.body,prBase:X}}function h(q,J,H){let K=q.branches.filter((W)=>W.specId===J),Q=K.filter((W)=>!K.some((X)=>X.name===W.baseBranch));function Y(W,X,V){let U=K.find((O)=>O.name===W);if(!U)return;let L="  ".repeat(X),Z=X===0?"":V?"\u2514\u2500 ":"\u251C\u2500 ",z=W===H?" (current)":"",T=U.status!=="active"?` (${U.status}${U.pr?`, PR #${U.pr}`:""})`:"";console.log(`${L}${Z}${W}${z}${T}`);let P=K.filter((O)=>O.baseBranch===W);P.forEach((O,G)=>{Y(O.name,X+1,G===P.length-1)})}Q.forEach((W)=>{console.log(`  ${W.baseBranch}`),Y(W.name,1,!0)})}function qq(q,J){let H=J;while(H){let K=q.branches.find((Q)=>Q.name===H.baseBranch);if(!K)return H.baseBranch;H=K}return"main"}async function wq(q){let J=q.findIndex((_)=>!_.startsWith("--"));if(J===-1)throw Error("Branch name required: /speck.branch create <name> [--base <base>]");let H=q[J],K=q.indexOf("--base"),Q=q.indexOf("--spec"),Y=q.includes("--skip-pr-prompt"),W=q.includes("--create-pr"),X=q.indexOf("--title"),V=q.indexOf("--description"),U=q.indexOf("--pr-base"),L=q.includes("--json"),Z=await F(),z=Z.REPO_ROOT,T=await d(),P=await Jq(),O=null;if(T.mode==="multi-repo"){let _=P?"child":"root",k=P?await Oq(T.speckRoot):null,C=P?await Kq(T.repoRoot,T.speckRoot):null;O={...T,context:_,parentSpecId:k,childRepoName:C}}let G="";try{G=await m(z)}catch(_){G=""}let A;if(K!==-1&&q[K+1])A=q[K+1];else{if(!G)return console.error("Error: No commits in repository. Cannot determine current branch."),console.error("Please create an initial commit first, or specify --base explicitly."),1;A=G,console.log(`Defaulting base to current branch: ${A}`)}let E=Q!==-1?q[Q+1]:null;if(!await Qq(H))throw Error(`Invalid branch name: '${H}'. Must be a valid git ref name.`);try{await zq(A,z)}catch(_){if(_ instanceof Error)throw Error(_.message);throw _}if(!E){if(Z.FEATURE_DIR&&Z.FEATURE_DIR.includes("/specs/")){let _=Z.FEATURE_DIR.match(/\/specs\/([^\/]+)/);if(_){if(E=_[1],!L)console.log(`Auto-detected spec: ${E}`)}}if(!E)throw Error(`Could not auto-detect spec ID. Please specify with --spec flag:
  /speck.branch create <name> [--base <base>] --spec <spec-id>`)}let $=O?T.specsDir:l.join(z,"specs"),v=l.join($,E);try{await b.access(v)}catch{throw Error(`Spec directory not found: specs/${E}/`)}if((await f`git -C ${z} status --porcelain`.quiet()).stdout.toString().split(`
`).filter((_)=>_.trim().length>0).filter((_)=>!_.includes(".speck/branches.json")).length>0){console.log(`
${"\u26A0".repeat(30)}`),console.log(`\u26A0 Warning: Current branch '${G}' has uncommitted changes`),console.log(`${"\u26A0".repeat(30)}
`);let _=await f`git -C ${z} diff --stat`.quiet();throw console.log("Changed files:"),console.log(_.stdout.toString()),console.log(`
Options:`),console.log("  1. Commit changes now (recommended)"),console.log("  2. Stash changes (saves for later)"),console.log("  3. Carry changes to new branch (creates new branch with changes)"),console.log("  4. Abort branch creation"),console.log(`
Choose an option or run one of these commands first:`),console.log('  git add . && git commit -m "message"  # Commit changes'),console.log("  git stash                              # Stash changes"),console.log(`
Then re-run: /speck.branch create `+q.join(" ")),Error("Uncommitted changes detected. Please commit or stash changes before creating a new branch.")}let j=await w(z);if(!Y&&!W){let _=await Pq(G,A,j,z,O);if(_){if(L){let k={branch:G,title:_.title,body:_.body,base:_.prBase};console.log(JSON.stringify(k))}else{let k={type:"pr-suggestion",branch:G,suggestedTitle:_.title,suggestedDescription:_.body,suggestedBase:_.prBase,newBranch:H};console.error(JSON.stringify(k)),console.log(`
${"=".repeat(60)}`),console.log(`\uD83D\uDCA1 PR Opportunity: Create PR for '${G}' before switching`),console.log(`${"=".repeat(60)}`),console.log(`
Suggested PR details:`),console.log(`  Title: ${_.title}`),console.log(`  Base: ${_.prBase}`),console.log(`
Description:`),console.log(_.body.split(`
`).map((C)=>`  ${C}`).join(`
`)),console.log(`
${"-".repeat(60)}`),console.log("Option 1: Create PR with gh CLI:"),console.log(`  gh pr create --base ${_.prBase} --title "${_.title}" --body "${_.body.replace(/"/g,"\\\"")}"`),console.log(`
Option 2: Create PR via GitHub URL:`),console.log(`  https://github.com/OWNER/REPO/compare/${_.prBase}...${G}?expand=1&title=${encodeURIComponent(_.title)}`),console.log(`
Option 3: Skip and create branch without PR`),console.log(`${"=".repeat(60)}
`)}return 2}}if(W){let _=X!==-1?q[X+1]:null,k=V!==-1?q[V+1]:null,C=U!==-1?q[U+1]:null;if(!_||!k||!C)throw Error("--create-pr requires --title, --description, and --pr-base flags");console.log(`Creating PR for '${G}'...`);try{let N=await f`gh pr create --base ${C} --title ${_} --body ${k}`.quiet();if(N.exitCode!==0)throw Error(`gh pr create failed: ${N.stderr.toString()}`);let r=N.stdout.toString().match(/\/pull\/(\d+)/),g=r?parseInt(r[1],10):null;if(g){if(console.log(`\u2713 Created PR #${g} for '${G}'`),u(j,G))j=c(j,G,"submitted",g),await R(z,j)}else console.log(`\u2713 PR created for '${G}' (could not parse PR number from output)`)}catch(N){let y=N instanceof Error?N.message:String(N);if(y.includes("gh: command not found")||y.includes("not found"))return console.error(`
\u274C Error: GitHub CLI (gh) is not installed`),console.error(`
To install gh:`),console.error("  brew install gh           # macOS"),console.error("  sudo apt install gh       # Ubuntu/Debian"),console.error("  winget install GitHub.cli # Windows"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${H} --skip-pr-prompt`),1;if(y.includes("authentication")||y.includes("401"))return console.error(`
\u274C Error: GitHub CLI is not authenticated`),console.error(`
To authenticate:`),console.error("  gh auth login"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${H} --skip-pr-prompt`),1;return console.error(`
\u274C Error creating PR: ${y}`),console.error(`
You can:`),console.error("  1. Check your network connection and try again"),console.error("  2. Create the PR manually via GitHub web UI"),console.error("  3. Use --skip-pr-prompt to create branch without PR"),1}}let B=new Date().toISOString(),x={name:H,specId:E,baseBranch:A,status:"active",pr:null,createdAt:B,updatedAt:B,...O?.parentSpecId&&{parentSpecId:O.parentSpecId}},a=i(H,{...j,branches:[...j.branches,x]});if(a)throw Error(`Circular dependency detected: ${a.join(" \u2192 ")}`);if(j=s(j,x),await Zq(H,A,z),await Vq(H,z),await R(z,j),!L)console.log(`\u2713 Created stacked branch '${H}'`),console.log(`\u2713 Based on: ${A}`),console.log(`\u2713 Linked to spec: ${E}`),console.log(),console.log("Branch stack:"),h(j,E,H),console.log(),console.log("Next steps:"),console.log("  - Implement feature on this branch"),console.log(`  - Run /speck.tasks --branch ${H} to generate tasks`),console.log(`  - When ready: /speck.branch create <next-branch> --base ${H}`)}async function Mq(q){let J=q.includes("--all"),H=await F(),K=await d(),Q=H.REPO_ROOT;if(J&&K.mode==="multi-repo"){await xq(K.speckRoot,Q);return}let Y=await w(Q);if(Y.branches.length===0){console.log("No stacked branches found."),console.log("Create your first stacked branch with:"),console.log("  /speck.branch create <name> --base main");return}let W="";try{W=await m(Q)}catch(X){W=""}if(J){let X=Object.keys(Y.specIndex);for(let V of X)console.log(`
Spec: ${V}`),console.log("Branch Stack:"),h(Y,V,W);console.log(`
Total: ${Y.branches.length} branches across ${X.length} specs`)}else{let X=p(Y,W);if(!X){console.log("Current branch is not in stacked mode."),console.log("Use --all to see all stacked branches.");return}console.log(`Spec: ${X}
`),console.log("Branch Stack:"),h(Y,X,W),console.log(`
Legend:`),console.log("  (current) = checked out branch"),console.log("  (active) = development in progress"),console.log("  (submitted) = PR open for review")}}async function xq(q,J){let H=await t(q,J);if(console.log(`Branch List (All Repositories)
`),H.rootRepo&&H.rootRepo.branchCount>0){console.log("Root Repository:"),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let Q=await w(q);for(let Y of Q.branches){let W=Y.pr?String(Y.pr).padEnd(5):"-".padEnd(5);console.log(`${Y.name.padEnd(18)} ${Y.baseBranch.padEnd(14)} ${Y.specId.padEnd(23)} ${W} ${Y.status}`)}console.log("")}let K=Array.from(H.childRepos.keys()).sort();for(let Q of K){let Y=H.childRepos.get(Q);console.log(`Child: ${Q}`),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let W=await w(Y.repoPath);for(let X of W.branches){let V=X.pr?String(X.pr).padEnd(5):"-".padEnd(5);console.log(`${X.name.padEnd(18)} ${X.baseBranch.padEnd(14)} ${X.specId.padEnd(23)} ${V} ${X.status}`)}console.log("")}if(K.length===0&&!H.rootRepo)console.log("No branches found in any repository.")}async function kq(q=[]){let J=q.includes("--all"),H=await F(),K=await d(),Q=H.REPO_ROOT;if(J&&K.mode==="multi-repo"){await fq(K.speckRoot,Q);return}let Y=await w(Q),W="";try{W=await m(Q)}catch(Z){W=""}let X=p(Y,W);if(!X){console.log("Current branch is not in stacked mode.");return}let V=Y.branches.filter((Z)=>Z.specId===X),U=0;console.log(`Spec: ${X}
`);for(let Z of V){if(!await n(Z.name,Q)){console.log(`${Z.name} (${Z.status}${Z.pr?`, PR #${Z.pr}`:""})`),console.log("  \u26A0 ORPHANED: Branch no longer exists in git"),console.log(`  \u2192 Run: /speck.branch delete ${Z.name} (cleanup metadata)`),U++;continue}let T=await _q(Z.name,Z.baseBranch,Q);if(T&&Z.status!=="merged")console.log(`${Z.name} (${Z.status}${Z.pr?`, PR #${Z.pr}`:""})`),console.log(`  \u26A0 MERGED: Branch merged into base but status is '${Z.status}'`),console.log(`  \u2192 Run: /speck.branch update ${Z.name} --status merged`),U++;if(T&&Z.status==="merged"){let P=V.filter((O)=>O.baseBranch===Z.name&&O.status!=="merged");if(P.length>0)for(let O of P)console.log(`
${O.name} (${O.status})`),console.log(`  \u26A0 REBASE NEEDED: Base branch '${Z.name}' has been merged`),console.log(`  \u2192 Run: git rebase ${qq(Y,Z)}`),console.log(`  \u2192 Update base: /speck.branch update ${O.name} --base ${qq(Y,Z)}`),U++}}if(U===0)console.log("\u2713 Branch stack is healthy - no warnings");else console.log(`
\u26A0 ${U} warning(s) found`);let L=await o();if(L.mode==="child"&&Y.branches.length>0)try{let{findChildRepos:Z}=await import("./paths-x5kskk5z.js"),z=L.speckRoot||"";if(!(await Z(z)).includes(Q))console.log(`
\u26A0 Orphaned tracking detected:`),console.log(`  ${Y.branches.length} branch(es) tracked but repo unlinked from parent spec`),console.log(`  Parent: ${z}`),console.log("  Fix: Re-link with /speck.link or archive .speck/branches.json")}catch{}}async function fq(q,J){let H=await t(q,J);if(console.log(`Branch Status (All Repositories)
`),H.rootRepo&&H.rootRepo.branchCount>0)console.log("Root Repository:"),await Hq(q,H.rootRepo),console.log("");let K=Array.from(H.childRepos.keys()).sort();for(let Q of K){let Y=H.childRepos.get(Q);console.log(`Child: ${Q}`),await Hq(Y.repoPath,Y),console.log("")}if(K.length===0&&!H.rootRepo)console.log("No branches found in any repository.")}async function Hq(q,J){let H=await w(q),K=[];if(J.statusCounts.active>0)K.push(`${J.statusCounts.active} active`);if(J.statusCounts.submitted>0)K.push(`${J.statusCounts.submitted} submitted`);if(J.statusCounts.merged>0)K.push(`${J.statusCounts.merged} merged`);if(J.statusCounts.abandoned>0)K.push(`${J.statusCounts.abandoned} abandoned`);if(K.length>0)console.log(`  Total: ${J.branchCount} branches (${K.join(", ")})`);console.log("  Dependency Tree:");for(let Q of J.chains)if(Q.branches.length>0)Iq(Q.branches,H)}function Iq(q,J){q.forEach((H,K)=>{let Q=J.branches.find((X)=>X.name===H);if(!Q)return;let W=`${K===0?"    \u2514\u2500":"       \u2514\u2500"} ${H}`;if(Q.pr)W+=` (${Q.status}, PR #${Q.pr})`;else if(Q.status!=="active")W+=` (${Q.status})`;console.log(W)})}async function Nq(q){let J=q[0];if(!J)throw Error("Branch name required: /speck.branch update <name> [options]");let H=q.indexOf("--status"),K=q.indexOf("--pr"),Q=q.indexOf("--base"),W=(await F()).REPO_ROOT,X=await w(W);if(!u(X,J))throw Error(`Branch '${J}' not found in mapping`);if(H!==-1){let U=q[H+1];if(!["active","submitted","merged","abandoned"].includes(U))throw Error(`Invalid status: '${U}'. Must be: active, submitted, merged, or abandoned`);let L=K!==-1?parseInt(q[K+1],10):void 0;X=c(X,J,U,L)}if(Q!==-1){let U=q[Q+1];if(!await n(U,W))throw Error(`Base branch '${U}' does not exist`);let Z=X.branches.map((T)=>T.name===J?{...T,baseBranch:U,updatedAt:new Date().toISOString()}:T),z=i(J,{...X,branches:Z});if(z)throw Error(`Cannot update base: circular dependency detected: ${z.join(" \u2192 ")}`);X={...X,branches:Z}}await R(W,X),console.log(`\u2713 Updated branch '${J}'`)}async function Fq(q){let J=q[0];if(!J)throw Error("Branch name required: /speck.branch delete <name>");let H=q.includes("--force"),Q=(await F()).REPO_ROOT,Y=await w(Q),W=Y.branches.filter((V)=>V.baseBranch===J);if(W.length>0&&!H)throw console.error(`Error: Branch '${J}' has child branches:`),W.forEach((V)=>console.error(`  - ${V.name}`)),console.error(`
Use --force to delete anyway (will orphan children)`),Error("Branch has children");let X=Wq(Y,J);await R(Q,X),console.log(`\u2713 Removed branch '${J}' from metadata`),console.log(),console.log("Note: Git branch still exists. To delete it, run:"),console.log(`  git branch -D ${J}`)}async function Sq(q){let J=q.indexOf("--pattern"),H=J!==-1?q[J+1]:void 0,K=q.indexOf("--batch"),Q=K!==-1,W=(await F()).REPO_ROOT,X=await o(),V=X.context==="child"?await Oq(X.speckRoot):null,U=await Uq(W,H);if(U.length===0){console.log("No branches found to import.");return}let L=await w(W),Z=await e(W),z=U.filter(({name:D})=>!L.branches.some(($)=>$.name===D)&&D!==Z);if(z.length===0){console.log("All branches are already in stacked mode.");return}let T=X.specsDir,O=(await b.readdir(T)).filter((D)=>/^\d{3}-/.test(D));if(!Q){let D=z.map(({name:v,upstream:M})=>{let S="main";if(M){let I=M.replace(/^origin\//,"");if(I&&I!==v)S=I}return{name:v,upstream:M||null,inferredBase:S}});return console.error(JSON.stringify({type:"import-prompt",branches:D,availableSpecs:O})),console.log(`Found ${z.length} branches to import:
`),D.forEach((v)=>{console.log(`\u2022 ${v.name}`),console.log(`  Upstream: ${v.upstream||"(none)"}`),console.log(`  Inferred base: ${v.inferredBase}`),console.log()}),console.log(`Available specs: ${O.join(", ")}
`),console.log("Agent interaction required: Map each branch to a spec."),3}let G=q.slice(K+1),A=0,E=0;for(let D of G){let[$,v]=D.split(":");if(!$||!v){console.log(`\u26A0 Invalid mapping format: ${D}`);continue}if(v==="skip"){console.log(`\u2298 Skipped ${$}`),E++;continue}let M=z.find((x)=>x.name===$);if(!M){console.log(`\u26A0 Branch not found: ${$}`);continue}let S="main";if(M.upstream){let x=M.upstream.replace(/^origin\//,"");if(x&&x!==M.name)S=x}let I=new Date().toISOString(),j={name:$,specId:v,baseBranch:S,status:"active",pr:null,createdAt:I,updatedAt:I,...V&&{parentSpecId:V}},B=i($,{...L,branches:[...L.branches,j]});if(B){console.log(`\u26A0 Skipped ${$} (would create cycle: ${B.join(" \u2192 ")})`),E++;continue}L=s(L,j),console.log(`\u2713 Imported ${$} \u2192 ${v}`),A++}await R(W,L),console.log(`
\u2713 Import complete:`),console.log(`  Imported: ${A}`),console.log(`  Skipped: ${E}`)}async function iq(q=process.argv.slice(2)){if(process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: This script is deprecated. Use 'speck-branch' virtual command or 'bun .speck/scripts/speck.ts branch' instead.\x1B[0m
`);if(q.length===0)return console.log("Usage: /speck.branch <command> [args]"),console.log(),console.log("Commands:"),console.log("  create <name> [--base <base>] [--spec <spec-id>]"),console.log("  list [--all]"),console.log("  status"),console.log("  update <name> [--status <status>] [--pr <number>] [--base <branch>]"),console.log("  delete <name> [--force]"),console.log("  import [--pattern <pattern>]"),1;let J=q[0],H=q.slice(1);try{switch(J){case"create":await wq(H);break;case"list":await Mq(H);break;case"status":await kq(H);break;case"update":await Nq(H);break;case"delete":await Fq(H);break;case"import":await Sq(H);break;default:return console.error(`Unknown command: ${J}`),console.error("Run '/speck.branch' for usage"),1}}catch(K){if(K instanceof Yq||K instanceof Xq)return console.error(`Error: ${K.message}`),1;if(K instanceof Error){if(console.error(`Error: ${K.message}`),K.stack)console.error(`Stack trace: ${K.stack}`);return 1}return console.error(`Unknown error: ${String(K)}`),1}return 0}export{iq as main};
