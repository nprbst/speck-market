// @bun
import{u as H_,w as Q_,x as Y_}from"./paths-qqmkr5wb.js";import v$ from"fs/promises";import{existsSync as n$}from"fs";import R$ from"path";var E={};Q_(E,{void:()=>Pq,util:()=>U,unknown:()=>Cq,union:()=>xq,undefined:()=>Nq,tuple:()=>mq,transformer:()=>aq,symbol:()=>Rq,string:()=>l$,strictObject:()=>hq,setErrorMap:()=>t$,set:()=>cq,record:()=>Zq,quotelessJson:()=>a$,promise:()=>rq,preprocess:()=>eq,pipeline:()=>$_,ostring:()=>q_,optional:()=>sq,onumber:()=>__,oboolean:()=>W_,objectUtil:()=>f$,object:()=>Tq,number:()=>y$,nullable:()=>tq,null:()=>bq,never:()=>Iq,nativeEnum:()=>oq,nan:()=>fq,map:()=>uq,makeIssue:()=>G$,literal:()=>pq,lazy:()=>iq,late:()=>vq,isValid:()=>l,isDirty:()=>S$,isAsync:()=>r,isAborted:()=>U$,intersection:()=>yq,instanceof:()=>Dq,getParsedType:()=>I,getErrorMap:()=>o,function:()=>nq,enum:()=>dq,effect:()=>aq,discriminatedUnion:()=>lq,defaultErrorMap:()=>T,datetimeRegex:()=>T$,date:()=>Kq,custom:()=>x$,coerce:()=>J_,boolean:()=>m$,bigint:()=>Fq,array:()=>gq,any:()=>kq,addIssueToContext:()=>w,ZodVoid:()=>w$,ZodUnknown:()=>y,ZodUnion:()=>q$,ZodUndefined:()=>e,ZodType:()=>A,ZodTuple:()=>g,ZodTransformer:()=>k,ZodSymbol:()=>M$,ZodString:()=>K,ZodSet:()=>p,ZodSchema:()=>A,ZodRecord:()=>j$,ZodReadonly:()=>Y$,ZodPromise:()=>d,ZodPipeline:()=>O$,ZodParsedType:()=>M,ZodOptional:()=>N,ZodObject:()=>S,ZodNumber:()=>m,ZodNullable:()=>x,ZodNull:()=>$$,ZodNever:()=>P,ZodNativeEnum:()=>X$,ZodNaN:()=>B$,ZodMap:()=>z$,ZodLiteral:()=>J$,ZodLazy:()=>W$,ZodIssueCode:()=>H,ZodIntersection:()=>_$,ZodFunction:()=>s,ZodFirstPartyTypeKind:()=>B,ZodError:()=>F,ZodEnum:()=>u,ZodEffects:()=>k,ZodDiscriminatedUnion:()=>E$,ZodDefault:()=>Q$,ZodDate:()=>n,ZodCatch:()=>H$,ZodBranded:()=>L$,ZodBoolean:()=>t,ZodBigInt:()=>Z,ZodArray:()=>R,ZodAny:()=>i,Schema:()=>A,ParseStatus:()=>L,OK:()=>D,NEVER:()=>X_,INVALID:()=>z,EMPTY_PATH:()=>e$,DIRTY:()=>c,BRAND:()=>Lq});var U;(function($){$.assertEqual=(W)=>{};function q(W){}$.assertIs=q;function _(W){throw Error()}$.assertNever=_,$.arrayToEnum=(W)=>{let X={};for(let Q of W)X[Q]=Q;return X},$.getValidEnumValues=(W)=>{let X=$.objectKeys(W).filter((Y)=>typeof W[W[Y]]!=="number"),Q={};for(let Y of X)Q[Y]=W[Y];return $.objectValues(Q)},$.objectValues=(W)=>{return $.objectKeys(W).map(function(X){return W[X]})},$.objectKeys=typeof Object.keys==="function"?(W)=>Object.keys(W):(W)=>{let X=[];for(let Q in W)if(Object.prototype.hasOwnProperty.call(W,Q))X.push(Q);return X},$.find=(W,X)=>{for(let Q of W)if(X(Q))return Q;return},$.isInteger=typeof Number.isInteger==="function"?(W)=>Number.isInteger(W):(W)=>typeof W==="number"&&Number.isFinite(W)&&Math.floor(W)===W;function J(W,X=" | "){return W.map((Q)=>typeof Q==="string"?`'${Q}'`:Q).join(X)}$.joinValues=J,$.jsonStringifyReplacer=(W,X)=>{if(typeof X==="bigint")return X.toString();return X}})(U||(U={}));var f$;(function($){$.mergeShapes=(q,_)=>{return{...q,..._}}})(f$||(f$={}));var M=U.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),I=($)=>{switch(typeof $){case"undefined":return M.undefined;case"string":return M.string;case"number":return Number.isNaN($)?M.nan:M.number;case"boolean":return M.boolean;case"function":return M.function;case"bigint":return M.bigint;case"symbol":return M.symbol;case"object":if(Array.isArray($))return M.array;if($===null)return M.null;if($.then&&typeof $.then==="function"&&$.catch&&typeof $.catch==="function")return M.promise;if(typeof Map<"u"&&$ instanceof Map)return M.map;if(typeof Set<"u"&&$ instanceof Set)return M.set;if(typeof Date<"u"&&$ instanceof Date)return M.date;return M.object;default:return M.unknown}};var H=U.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]),a$=($)=>{return JSON.stringify($,null,2).replace(/"([^"]+)":/g,"$1:")};class F extends Error{get errors(){return this.issues}constructor($){super();this.issues=[],this.addIssue=(_)=>{this.issues=[...this.issues,_]},this.addIssues=(_=[])=>{this.issues=[...this.issues,..._]};let q=new.target.prototype;if(Object.setPrototypeOf)Object.setPrototypeOf(this,q);else this.__proto__=q;this.name="ZodError",this.issues=$}format($){let q=$||function(W){return W.message},_={_errors:[]},J=(W)=>{for(let X of W.issues)if(X.code==="invalid_union")X.unionErrors.map(J);else if(X.code==="invalid_return_type")J(X.returnTypeError);else if(X.code==="invalid_arguments")J(X.argumentsError);else if(X.path.length===0)_._errors.push(q(X));else{let Q=_,Y=0;while(Y<X.path.length){let G=X.path[Y];if(Y!==X.path.length-1)Q[G]=Q[G]||{_errors:[]};else Q[G]=Q[G]||{_errors:[]},Q[G]._errors.push(q(X));Q=Q[G],Y++}}};return J(this),_}static assert($){if(!($ instanceof F))throw Error(`Not a ZodError: ${$}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,U.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten($=(q)=>q.message){let q={},_=[];for(let J of this.issues)if(J.path.length>0){let W=J.path[0];q[W]=q[W]||[],q[W].push($(J))}else _.push($(J));return{formErrors:_,fieldErrors:q}}get formErrors(){return this.flatten()}}F.create=($)=>{return new F($)};var s$=($,q)=>{let _;switch($.code){case H.invalid_type:if($.received===M.undefined)_="Required";else _=`Expected ${$.expected}, received ${$.received}`;break;case H.invalid_literal:_=`Invalid literal value, expected ${JSON.stringify($.expected,U.jsonStringifyReplacer)}`;break;case H.unrecognized_keys:_=`Unrecognized key(s) in object: ${U.joinValues($.keys,", ")}`;break;case H.invalid_union:_="Invalid input";break;case H.invalid_union_discriminator:_=`Invalid discriminator value. Expected ${U.joinValues($.options)}`;break;case H.invalid_enum_value:_=`Invalid enum value. Expected ${U.joinValues($.options)}, received '${$.received}'`;break;case H.invalid_arguments:_="Invalid function arguments";break;case H.invalid_return_type:_="Invalid function return type";break;case H.invalid_date:_="Invalid date";break;case H.invalid_string:if(typeof $.validation==="object")if("includes"in $.validation){if(_=`Invalid input: must include "${$.validation.includes}"`,typeof $.validation.position==="number")_=`${_} at one or more positions greater than or equal to ${$.validation.position}`}else if("startsWith"in $.validation)_=`Invalid input: must start with "${$.validation.startsWith}"`;else if("endsWith"in $.validation)_=`Invalid input: must end with "${$.validation.endsWith}"`;else U.assertNever($.validation);else if($.validation!=="regex")_=`Invalid ${$.validation}`;else _="Invalid";break;case H.too_small:if($.type==="array")_=`Array must contain ${$.exact?"exactly":$.inclusive?"at least":"more than"} ${$.minimum} element(s)`;else if($.type==="string")_=`String must contain ${$.exact?"exactly":$.inclusive?"at least":"over"} ${$.minimum} character(s)`;else if($.type==="number")_=`Number must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${$.minimum}`;else if($.type==="bigint")_=`Number must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${$.minimum}`;else if($.type==="date")_=`Date must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${new Date(Number($.minimum))}`;else _="Invalid input";break;case H.too_big:if($.type==="array")_=`Array must contain ${$.exact?"exactly":$.inclusive?"at most":"less than"} ${$.maximum} element(s)`;else if($.type==="string")_=`String must contain ${$.exact?"exactly":$.inclusive?"at most":"under"} ${$.maximum} character(s)`;else if($.type==="number")_=`Number must be ${$.exact?"exactly":$.inclusive?"less than or equal to":"less than"} ${$.maximum}`;else if($.type==="bigint")_=`BigInt must be ${$.exact?"exactly":$.inclusive?"less than or equal to":"less than"} ${$.maximum}`;else if($.type==="date")_=`Date must be ${$.exact?"exactly":$.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number($.maximum))}`;else _="Invalid input";break;case H.custom:_="Invalid input";break;case H.invalid_intersection_types:_="Intersection results could not be merged";break;case H.not_multiple_of:_=`Number must be a multiple of ${$.multipleOf}`;break;case H.not_finite:_="Number must be finite";break;default:_=q.defaultError,U.assertNever($)}return{message:_}},T=s$;var k$=T;function t$($){k$=$}function o(){return k$}var G$=($)=>{let{data:q,path:_,errorMaps:J,issueData:W}=$,X=[..._,...W.path||[]],Q={...W,path:X};if(W.message!==void 0)return{...W,path:X,message:W.message};let Y="",G=J.filter((O)=>!!O).slice().reverse();for(let O of G)Y=O(Q,{data:q,defaultError:Y}).message;return{...W,path:X,message:Y}},e$=[];function w($,q){let _=o(),J=G$({issueData:q,data:$.data,path:$.path,errorMaps:[$.common.contextualErrorMap,$.schemaErrorMap,_,_===T?void 0:T].filter((W)=>!!W)});$.common.issues.push(J)}class L{constructor(){this.value="valid"}dirty(){if(this.value==="valid")this.value="dirty"}abort(){if(this.value!=="aborted")this.value="aborted"}static mergeArray($,q){let _=[];for(let J of q){if(J.status==="aborted")return z;if(J.status==="dirty")$.dirty();_.push(J.value)}return{status:$.value,value:_}}static async mergeObjectAsync($,q){let _=[];for(let J of q){let W=await J.key,X=await J.value;_.push({key:W,value:X})}return L.mergeObjectSync($,_)}static mergeObjectSync($,q){let _={};for(let J of q){let{key:W,value:X}=J;if(W.status==="aborted")return z;if(X.status==="aborted")return z;if(W.status==="dirty")$.dirty();if(X.status==="dirty")$.dirty();if(W.value!=="__proto__"&&(typeof X.value<"u"||J.alwaysSet))_[W.value]=X.value}return{status:$.value,value:_}}}var z=Object.freeze({status:"aborted"}),c=($)=>({status:"dirty",value:$}),D=($)=>({status:"valid",value:$}),U$=($)=>$.status==="aborted",S$=($)=>$.status==="dirty",l=($)=>$.status==="valid",r=($)=>typeof Promise<"u"&&$ instanceof Promise;var j;(function($){$.errToObj=(q)=>typeof q==="string"?{message:q}:q||{},$.toString=(q)=>typeof q==="string"?q:q?.message})(j||(j={}));class b{constructor($,q,_,J){this._cachedPath=[],this.parent=$,this.data=q,this._path=_,this._key=J}get path(){if(!this._cachedPath.length)if(Array.isArray(this._key))this._cachedPath.push(...this._path,...this._key);else this._cachedPath.push(...this._path,this._key);return this._cachedPath}}var C$=($,q)=>{if(l(q))return{success:!0,data:q.value};else{if(!$.common.issues.length)throw Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;let _=new F($.common.issues);return this._error=_,this._error}}}};function V($){if(!$)return{};let{errorMap:q,invalid_type_error:_,required_error:J,description:W}=$;if(q&&(_||J))throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);if(q)return{errorMap:q,description:W};return{errorMap:(Q,Y)=>{let{message:G}=$;if(Q.code==="invalid_enum_value")return{message:G??Y.defaultError};if(typeof Y.data>"u")return{message:G??J??Y.defaultError};if(Q.code!=="invalid_type")return{message:Y.defaultError};return{message:G??_??Y.defaultError}},description:W}}class A{get description(){return this._def.description}_getType($){return I($.data)}_getOrReturnCtx($,q){return q||{common:$.parent.common,data:$.data,parsedType:I($.data),schemaErrorMap:this._def.errorMap,path:$.path,parent:$.parent}}_processInputParams($){return{status:new L,ctx:{common:$.parent.common,data:$.data,parsedType:I($.data),schemaErrorMap:this._def.errorMap,path:$.path,parent:$.parent}}}_parseSync($){let q=this._parse($);if(r(q))throw Error("Synchronous parse encountered promise.");return q}_parseAsync($){let q=this._parse($);return Promise.resolve(q)}parse($,q){let _=this.safeParse($,q);if(_.success)return _.data;throw _.error}safeParse($,q){let _={common:{issues:[],async:q?.async??!1,contextualErrorMap:q?.errorMap},path:q?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:I($)},J=this._parseSync({data:$,path:_.path,parent:_});return C$(_,J)}"~validate"($){let q={common:{issues:[],async:!!this["~standard"].async},path:[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:I($)};if(!this["~standard"].async)try{let _=this._parseSync({data:$,path:[],parent:q});return l(_)?{value:_.value}:{issues:q.common.issues}}catch(_){if(_?.message?.toLowerCase()?.includes("encountered"))this["~standard"].async=!0;q.common={issues:[],async:!0}}return this._parseAsync({data:$,path:[],parent:q}).then((_)=>l(_)?{value:_.value}:{issues:q.common.issues})}async parseAsync($,q){let _=await this.safeParseAsync($,q);if(_.success)return _.data;throw _.error}async safeParseAsync($,q){let _={common:{issues:[],contextualErrorMap:q?.errorMap,async:!0},path:q?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:I($)},J=this._parse({data:$,path:_.path,parent:_}),W=await(r(J)?J:Promise.resolve(J));return C$(_,W)}refine($,q){let _=(J)=>{if(typeof q==="string"||typeof q>"u")return{message:q};else if(typeof q==="function")return q(J);else return q};return this._refinement((J,W)=>{let X=$(J),Q=()=>W.addIssue({code:H.custom,..._(J)});if(typeof Promise<"u"&&X instanceof Promise)return X.then((Y)=>{if(!Y)return Q(),!1;else return!0});if(!X)return Q(),!1;else return!0})}refinement($,q){return this._refinement((_,J)=>{if(!$(_))return J.addIssue(typeof q==="function"?q(_,J):q),!1;else return!0})}_refinement($){return new k({schema:this,typeName:B.ZodEffects,effect:{type:"refinement",refinement:$}})}superRefine($){return this._refinement($)}constructor($){this.spa=this.safeParseAsync,this._def=$,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this),this["~standard"]={version:1,vendor:"zod",validate:(q)=>this["~validate"](q)}}optional(){return N.create(this,this._def)}nullable(){return x.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return R.create(this)}promise(){return d.create(this,this._def)}or($){return q$.create([this,$],this._def)}and($){return _$.create(this,$,this._def)}transform($){return new k({...V(this._def),schema:this,typeName:B.ZodEffects,effect:{type:"transform",transform:$}})}default($){let q=typeof $==="function"?$:()=>$;return new Q$({...V(this._def),innerType:this,defaultValue:q,typeName:B.ZodDefault})}brand(){return new L$({typeName:B.ZodBranded,type:this,...V(this._def)})}catch($){let q=typeof $==="function"?$:()=>$;return new H$({...V(this._def),innerType:this,catchValue:q,typeName:B.ZodCatch})}describe($){return new this.constructor({...this._def,description:$})}pipe($){return O$.create(this,$)}readonly(){return Y$.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}var $q=/^c[^\s-]{8,}$/i,qq=/^[0-9a-z]+$/,_q=/^[0-9A-HJKMNP-TV-Z]{26}$/i,Wq=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,Jq=/^[a-z0-9_-]{21}$/i,Xq=/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,Qq=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,Hq=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,Yq="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",F$,Gq=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,Mq=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,wq=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,jq=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,zq=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,Bq=/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,P$="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",Oq=new RegExp(`^${P$}$`);function g$($){let q="[0-5]\\d";if($.precision)q=`${q}\\.\\d{${$.precision}}`;else if($.precision==null)q=`${q}(\\.\\d+)?`;let _=$.precision?"+":"?";return`([01]\\d|2[0-3]):[0-5]\\d(:${q})${_}`}function Vq($){return new RegExp(`^${g$($)}$`)}function T$($){let q=`${P$}T${g$($)}`,_=[];if(_.push($.local?"Z?":"Z"),$.offset)_.push("([+-]\\d{2}:?\\d{2})");return q=`${q}(${_.join("|")})`,new RegExp(`^${q}$`)}function Aq($,q){if((q==="v4"||!q)&&Gq.test($))return!0;if((q==="v6"||!q)&&wq.test($))return!0;return!1}function Uq($,q){if(!Xq.test($))return!1;try{let[_]=$.split(".");if(!_)return!1;let J=_.replace(/-/g,"+").replace(/_/g,"/").padEnd(_.length+(4-_.length%4)%4,"="),W=JSON.parse(atob(J));if(typeof W!=="object"||W===null)return!1;if("typ"in W&&W?.typ!=="JWT")return!1;if(!W.alg)return!1;if(q&&W.alg!==q)return!1;return!0}catch{return!1}}function Sq($,q){if((q==="v4"||!q)&&Mq.test($))return!0;if((q==="v6"||!q)&&jq.test($))return!0;return!1}class K extends A{_parse($){if(this._def.coerce)$.data=String($.data);if(this._getType($)!==M.string){let W=this._getOrReturnCtx($);return w(W,{code:H.invalid_type,expected:M.string,received:W.parsedType}),z}let _=new L,J=void 0;for(let W of this._def.checks)if(W.kind==="min"){if($.data.length<W.value)J=this._getOrReturnCtx($,J),w(J,{code:H.too_small,minimum:W.value,type:"string",inclusive:!0,exact:!1,message:W.message}),_.dirty()}else if(W.kind==="max"){if($.data.length>W.value)J=this._getOrReturnCtx($,J),w(J,{code:H.too_big,maximum:W.value,type:"string",inclusive:!0,exact:!1,message:W.message}),_.dirty()}else if(W.kind==="length"){let X=$.data.length>W.value,Q=$.data.length<W.value;if(X||Q){if(J=this._getOrReturnCtx($,J),X)w(J,{code:H.too_big,maximum:W.value,type:"string",inclusive:!0,exact:!0,message:W.message});else if(Q)w(J,{code:H.too_small,minimum:W.value,type:"string",inclusive:!0,exact:!0,message:W.message});_.dirty()}}else if(W.kind==="email"){if(!Hq.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"email",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="emoji"){if(!F$)F$=new RegExp(Yq,"u");if(!F$.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"emoji",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="uuid"){if(!Wq.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"uuid",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="nanoid"){if(!Jq.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"nanoid",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="cuid"){if(!$q.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"cuid",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="cuid2"){if(!qq.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"cuid2",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="ulid"){if(!_q.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"ulid",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="url")try{new URL($.data)}catch{J=this._getOrReturnCtx($,J),w(J,{validation:"url",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="regex"){if(W.regex.lastIndex=0,!W.regex.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"regex",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="trim")$.data=$.data.trim();else if(W.kind==="includes"){if(!$.data.includes(W.value,W.position))J=this._getOrReturnCtx($,J),w(J,{code:H.invalid_string,validation:{includes:W.value,position:W.position},message:W.message}),_.dirty()}else if(W.kind==="toLowerCase")$.data=$.data.toLowerCase();else if(W.kind==="toUpperCase")$.data=$.data.toUpperCase();else if(W.kind==="startsWith"){if(!$.data.startsWith(W.value))J=this._getOrReturnCtx($,J),w(J,{code:H.invalid_string,validation:{startsWith:W.value},message:W.message}),_.dirty()}else if(W.kind==="endsWith"){if(!$.data.endsWith(W.value))J=this._getOrReturnCtx($,J),w(J,{code:H.invalid_string,validation:{endsWith:W.value},message:W.message}),_.dirty()}else if(W.kind==="datetime"){if(!T$(W).test($.data))J=this._getOrReturnCtx($,J),w(J,{code:H.invalid_string,validation:"datetime",message:W.message}),_.dirty()}else if(W.kind==="date"){if(!Oq.test($.data))J=this._getOrReturnCtx($,J),w(J,{code:H.invalid_string,validation:"date",message:W.message}),_.dirty()}else if(W.kind==="time"){if(!Vq(W).test($.data))J=this._getOrReturnCtx($,J),w(J,{code:H.invalid_string,validation:"time",message:W.message}),_.dirty()}else if(W.kind==="duration"){if(!Qq.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"duration",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="ip"){if(!Aq($.data,W.version))J=this._getOrReturnCtx($,J),w(J,{validation:"ip",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="jwt"){if(!Uq($.data,W.alg))J=this._getOrReturnCtx($,J),w(J,{validation:"jwt",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="cidr"){if(!Sq($.data,W.version))J=this._getOrReturnCtx($,J),w(J,{validation:"cidr",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="base64"){if(!zq.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"base64",code:H.invalid_string,message:W.message}),_.dirty()}else if(W.kind==="base64url"){if(!Bq.test($.data))J=this._getOrReturnCtx($,J),w(J,{validation:"base64url",code:H.invalid_string,message:W.message}),_.dirty()}else U.assertNever(W);return{status:_.value,value:$.data}}_regex($,q,_){return this.refinement((J)=>$.test(J),{validation:q,code:H.invalid_string,...j.errToObj(_)})}_addCheck($){return new K({...this._def,checks:[...this._def.checks,$]})}email($){return this._addCheck({kind:"email",...j.errToObj($)})}url($){return this._addCheck({kind:"url",...j.errToObj($)})}emoji($){return this._addCheck({kind:"emoji",...j.errToObj($)})}uuid($){return this._addCheck({kind:"uuid",...j.errToObj($)})}nanoid($){return this._addCheck({kind:"nanoid",...j.errToObj($)})}cuid($){return this._addCheck({kind:"cuid",...j.errToObj($)})}cuid2($){return this._addCheck({kind:"cuid2",...j.errToObj($)})}ulid($){return this._addCheck({kind:"ulid",...j.errToObj($)})}base64($){return this._addCheck({kind:"base64",...j.errToObj($)})}base64url($){return this._addCheck({kind:"base64url",...j.errToObj($)})}jwt($){return this._addCheck({kind:"jwt",...j.errToObj($)})}ip($){return this._addCheck({kind:"ip",...j.errToObj($)})}cidr($){return this._addCheck({kind:"cidr",...j.errToObj($)})}datetime($){if(typeof $==="string")return this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:$});return this._addCheck({kind:"datetime",precision:typeof $?.precision>"u"?null:$?.precision,offset:$?.offset??!1,local:$?.local??!1,...j.errToObj($?.message)})}date($){return this._addCheck({kind:"date",message:$})}time($){if(typeof $==="string")return this._addCheck({kind:"time",precision:null,message:$});return this._addCheck({kind:"time",precision:typeof $?.precision>"u"?null:$?.precision,...j.errToObj($?.message)})}duration($){return this._addCheck({kind:"duration",...j.errToObj($)})}regex($,q){return this._addCheck({kind:"regex",regex:$,...j.errToObj(q)})}includes($,q){return this._addCheck({kind:"includes",value:$,position:q?.position,...j.errToObj(q?.message)})}startsWith($,q){return this._addCheck({kind:"startsWith",value:$,...j.errToObj(q)})}endsWith($,q){return this._addCheck({kind:"endsWith",value:$,...j.errToObj(q)})}min($,q){return this._addCheck({kind:"min",value:$,...j.errToObj(q)})}max($,q){return this._addCheck({kind:"max",value:$,...j.errToObj(q)})}length($,q){return this._addCheck({kind:"length",value:$,...j.errToObj(q)})}nonempty($){return this.min(1,j.errToObj($))}trim(){return new K({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new K({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new K({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(($)=>$.kind==="datetime")}get isDate(){return!!this._def.checks.find(($)=>$.kind==="date")}get isTime(){return!!this._def.checks.find(($)=>$.kind==="time")}get isDuration(){return!!this._def.checks.find(($)=>$.kind==="duration")}get isEmail(){return!!this._def.checks.find(($)=>$.kind==="email")}get isURL(){return!!this._def.checks.find(($)=>$.kind==="url")}get isEmoji(){return!!this._def.checks.find(($)=>$.kind==="emoji")}get isUUID(){return!!this._def.checks.find(($)=>$.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(($)=>$.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(($)=>$.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(($)=>$.kind==="cuid2")}get isULID(){return!!this._def.checks.find(($)=>$.kind==="ulid")}get isIP(){return!!this._def.checks.find(($)=>$.kind==="ip")}get isCIDR(){return!!this._def.checks.find(($)=>$.kind==="cidr")}get isBase64(){return!!this._def.checks.find(($)=>$.kind==="base64")}get isBase64url(){return!!this._def.checks.find(($)=>$.kind==="base64url")}get minLength(){let $=null;for(let q of this._def.checks)if(q.kind==="min"){if($===null||q.value>$)$=q.value}return $}get maxLength(){let $=null;for(let q of this._def.checks)if(q.kind==="max"){if($===null||q.value<$)$=q.value}return $}}K.create=($)=>{return new K({checks:[],typeName:B.ZodString,coerce:$?.coerce??!1,...V($)})};function Eq($,q){let _=($.toString().split(".")[1]||"").length,J=(q.toString().split(".")[1]||"").length,W=_>J?_:J,X=Number.parseInt($.toFixed(W).replace(".","")),Q=Number.parseInt(q.toFixed(W).replace(".",""));return X%Q/10**W}class m extends A{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse($){if(this._def.coerce)$.data=Number($.data);if(this._getType($)!==M.number){let W=this._getOrReturnCtx($);return w(W,{code:H.invalid_type,expected:M.number,received:W.parsedType}),z}let _=void 0,J=new L;for(let W of this._def.checks)if(W.kind==="int"){if(!U.isInteger($.data))_=this._getOrReturnCtx($,_),w(_,{code:H.invalid_type,expected:"integer",received:"float",message:W.message}),J.dirty()}else if(W.kind==="min"){if(W.inclusive?$.data<W.value:$.data<=W.value)_=this._getOrReturnCtx($,_),w(_,{code:H.too_small,minimum:W.value,type:"number",inclusive:W.inclusive,exact:!1,message:W.message}),J.dirty()}else if(W.kind==="max"){if(W.inclusive?$.data>W.value:$.data>=W.value)_=this._getOrReturnCtx($,_),w(_,{code:H.too_big,maximum:W.value,type:"number",inclusive:W.inclusive,exact:!1,message:W.message}),J.dirty()}else if(W.kind==="multipleOf"){if(Eq($.data,W.value)!==0)_=this._getOrReturnCtx($,_),w(_,{code:H.not_multiple_of,multipleOf:W.value,message:W.message}),J.dirty()}else if(W.kind==="finite"){if(!Number.isFinite($.data))_=this._getOrReturnCtx($,_),w(_,{code:H.not_finite,message:W.message}),J.dirty()}else U.assertNever(W);return{status:J.value,value:$.data}}gte($,q){return this.setLimit("min",$,!0,j.toString(q))}gt($,q){return this.setLimit("min",$,!1,j.toString(q))}lte($,q){return this.setLimit("max",$,!0,j.toString(q))}lt($,q){return this.setLimit("max",$,!1,j.toString(q))}setLimit($,q,_,J){return new m({...this._def,checks:[...this._def.checks,{kind:$,value:q,inclusive:_,message:j.toString(J)}]})}_addCheck($){return new m({...this._def,checks:[...this._def.checks,$]})}int($){return this._addCheck({kind:"int",message:j.toString($)})}positive($){return this._addCheck({kind:"min",value:0,inclusive:!1,message:j.toString($)})}negative($){return this._addCheck({kind:"max",value:0,inclusive:!1,message:j.toString($)})}nonpositive($){return this._addCheck({kind:"max",value:0,inclusive:!0,message:j.toString($)})}nonnegative($){return this._addCheck({kind:"min",value:0,inclusive:!0,message:j.toString($)})}multipleOf($,q){return this._addCheck({kind:"multipleOf",value:$,message:j.toString(q)})}finite($){return this._addCheck({kind:"finite",message:j.toString($)})}safe($){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:j.toString($)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:j.toString($)})}get minValue(){let $=null;for(let q of this._def.checks)if(q.kind==="min"){if($===null||q.value>$)$=q.value}return $}get maxValue(){let $=null;for(let q of this._def.checks)if(q.kind==="max"){if($===null||q.value<$)$=q.value}return $}get isInt(){return!!this._def.checks.find(($)=>$.kind==="int"||$.kind==="multipleOf"&&U.isInteger($.value))}get isFinite(){let $=null,q=null;for(let _ of this._def.checks)if(_.kind==="finite"||_.kind==="int"||_.kind==="multipleOf")return!0;else if(_.kind==="min"){if(q===null||_.value>q)q=_.value}else if(_.kind==="max"){if($===null||_.value<$)$=_.value}return Number.isFinite(q)&&Number.isFinite($)}}m.create=($)=>{return new m({checks:[],typeName:B.ZodNumber,coerce:$?.coerce||!1,...V($)})};class Z extends A{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte}_parse($){if(this._def.coerce)try{$.data=BigInt($.data)}catch{return this._getInvalidInput($)}if(this._getType($)!==M.bigint)return this._getInvalidInput($);let _=void 0,J=new L;for(let W of this._def.checks)if(W.kind==="min"){if(W.inclusive?$.data<W.value:$.data<=W.value)_=this._getOrReturnCtx($,_),w(_,{code:H.too_small,type:"bigint",minimum:W.value,inclusive:W.inclusive,message:W.message}),J.dirty()}else if(W.kind==="max"){if(W.inclusive?$.data>W.value:$.data>=W.value)_=this._getOrReturnCtx($,_),w(_,{code:H.too_big,type:"bigint",maximum:W.value,inclusive:W.inclusive,message:W.message}),J.dirty()}else if(W.kind==="multipleOf"){if($.data%W.value!==BigInt(0))_=this._getOrReturnCtx($,_),w(_,{code:H.not_multiple_of,multipleOf:W.value,message:W.message}),J.dirty()}else U.assertNever(W);return{status:J.value,value:$.data}}_getInvalidInput($){let q=this._getOrReturnCtx($);return w(q,{code:H.invalid_type,expected:M.bigint,received:q.parsedType}),z}gte($,q){return this.setLimit("min",$,!0,j.toString(q))}gt($,q){return this.setLimit("min",$,!1,j.toString(q))}lte($,q){return this.setLimit("max",$,!0,j.toString(q))}lt($,q){return this.setLimit("max",$,!1,j.toString(q))}setLimit($,q,_,J){return new Z({...this._def,checks:[...this._def.checks,{kind:$,value:q,inclusive:_,message:j.toString(J)}]})}_addCheck($){return new Z({...this._def,checks:[...this._def.checks,$]})}positive($){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:j.toString($)})}negative($){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:j.toString($)})}nonpositive($){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:j.toString($)})}nonnegative($){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:j.toString($)})}multipleOf($,q){return this._addCheck({kind:"multipleOf",value:$,message:j.toString(q)})}get minValue(){let $=null;for(let q of this._def.checks)if(q.kind==="min"){if($===null||q.value>$)$=q.value}return $}get maxValue(){let $=null;for(let q of this._def.checks)if(q.kind==="max"){if($===null||q.value<$)$=q.value}return $}}Z.create=($)=>{return new Z({checks:[],typeName:B.ZodBigInt,coerce:$?.coerce??!1,...V($)})};class t extends A{_parse($){if(this._def.coerce)$.data=Boolean($.data);if(this._getType($)!==M.boolean){let _=this._getOrReturnCtx($);return w(_,{code:H.invalid_type,expected:M.boolean,received:_.parsedType}),z}return D($.data)}}t.create=($)=>{return new t({typeName:B.ZodBoolean,coerce:$?.coerce||!1,...V($)})};class n extends A{_parse($){if(this._def.coerce)$.data=new Date($.data);if(this._getType($)!==M.date){let W=this._getOrReturnCtx($);return w(W,{code:H.invalid_type,expected:M.date,received:W.parsedType}),z}if(Number.isNaN($.data.getTime())){let W=this._getOrReturnCtx($);return w(W,{code:H.invalid_date}),z}let _=new L,J=void 0;for(let W of this._def.checks)if(W.kind==="min"){if($.data.getTime()<W.value)J=this._getOrReturnCtx($,J),w(J,{code:H.too_small,message:W.message,inclusive:!0,exact:!1,minimum:W.value,type:"date"}),_.dirty()}else if(W.kind==="max"){if($.data.getTime()>W.value)J=this._getOrReturnCtx($,J),w(J,{code:H.too_big,message:W.message,inclusive:!0,exact:!1,maximum:W.value,type:"date"}),_.dirty()}else U.assertNever(W);return{status:_.value,value:new Date($.data.getTime())}}_addCheck($){return new n({...this._def,checks:[...this._def.checks,$]})}min($,q){return this._addCheck({kind:"min",value:$.getTime(),message:j.toString(q)})}max($,q){return this._addCheck({kind:"max",value:$.getTime(),message:j.toString(q)})}get minDate(){let $=null;for(let q of this._def.checks)if(q.kind==="min"){if($===null||q.value>$)$=q.value}return $!=null?new Date($):null}get maxDate(){let $=null;for(let q of this._def.checks)if(q.kind==="max"){if($===null||q.value<$)$=q.value}return $!=null?new Date($):null}}n.create=($)=>{return new n({checks:[],coerce:$?.coerce||!1,typeName:B.ZodDate,...V($)})};class M$ extends A{_parse($){if(this._getType($)!==M.symbol){let _=this._getOrReturnCtx($);return w(_,{code:H.invalid_type,expected:M.symbol,received:_.parsedType}),z}return D($.data)}}M$.create=($)=>{return new M$({typeName:B.ZodSymbol,...V($)})};class e extends A{_parse($){if(this._getType($)!==M.undefined){let _=this._getOrReturnCtx($);return w(_,{code:H.invalid_type,expected:M.undefined,received:_.parsedType}),z}return D($.data)}}e.create=($)=>{return new e({typeName:B.ZodUndefined,...V($)})};class $$ extends A{_parse($){if(this._getType($)!==M.null){let _=this._getOrReturnCtx($);return w(_,{code:H.invalid_type,expected:M.null,received:_.parsedType}),z}return D($.data)}}$$.create=($)=>{return new $$({typeName:B.ZodNull,...V($)})};class i extends A{constructor(){super(...arguments);this._any=!0}_parse($){return D($.data)}}i.create=($)=>{return new i({typeName:B.ZodAny,...V($)})};class y extends A{constructor(){super(...arguments);this._unknown=!0}_parse($){return D($.data)}}y.create=($)=>{return new y({typeName:B.ZodUnknown,...V($)})};class P extends A{_parse($){let q=this._getOrReturnCtx($);return w(q,{code:H.invalid_type,expected:M.never,received:q.parsedType}),z}}P.create=($)=>{return new P({typeName:B.ZodNever,...V($)})};class w$ extends A{_parse($){if(this._getType($)!==M.undefined){let _=this._getOrReturnCtx($);return w(_,{code:H.invalid_type,expected:M.void,received:_.parsedType}),z}return D($.data)}}w$.create=($)=>{return new w$({typeName:B.ZodVoid,...V($)})};class R extends A{_parse($){let{ctx:q,status:_}=this._processInputParams($),J=this._def;if(q.parsedType!==M.array)return w(q,{code:H.invalid_type,expected:M.array,received:q.parsedType}),z;if(J.exactLength!==null){let X=q.data.length>J.exactLength.value,Q=q.data.length<J.exactLength.value;if(X||Q)w(q,{code:X?H.too_big:H.too_small,minimum:Q?J.exactLength.value:void 0,maximum:X?J.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:J.exactLength.message}),_.dirty()}if(J.minLength!==null){if(q.data.length<J.minLength.value)w(q,{code:H.too_small,minimum:J.minLength.value,type:"array",inclusive:!0,exact:!1,message:J.minLength.message}),_.dirty()}if(J.maxLength!==null){if(q.data.length>J.maxLength.value)w(q,{code:H.too_big,maximum:J.maxLength.value,type:"array",inclusive:!0,exact:!1,message:J.maxLength.message}),_.dirty()}if(q.common.async)return Promise.all([...q.data].map((X,Q)=>{return J.type._parseAsync(new b(q,X,q.path,Q))})).then((X)=>{return L.mergeArray(_,X)});let W=[...q.data].map((X,Q)=>{return J.type._parseSync(new b(q,X,q.path,Q))});return L.mergeArray(_,W)}get element(){return this._def.type}min($,q){return new R({...this._def,minLength:{value:$,message:j.toString(q)}})}max($,q){return new R({...this._def,maxLength:{value:$,message:j.toString(q)}})}length($,q){return new R({...this._def,exactLength:{value:$,message:j.toString(q)}})}nonempty($){return this.min(1,$)}}R.create=($,q)=>{return new R({type:$,minLength:null,maxLength:null,exactLength:null,typeName:B.ZodArray,...V(q)})};function a($){if($ instanceof S){let q={};for(let _ in $.shape){let J=$.shape[_];q[_]=N.create(a(J))}return new S({...$._def,shape:()=>q})}else if($ instanceof R)return new R({...$._def,type:a($.element)});else if($ instanceof N)return N.create(a($.unwrap()));else if($ instanceof x)return x.create(a($.unwrap()));else if($ instanceof g)return g.create($.items.map((q)=>a(q)));else return $}class S extends A{constructor(){super(...arguments);this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;let $=this._def.shape(),q=U.objectKeys($);return this._cached={shape:$,keys:q},this._cached}_parse($){if(this._getType($)!==M.object){let G=this._getOrReturnCtx($);return w(G,{code:H.invalid_type,expected:M.object,received:G.parsedType}),z}let{status:_,ctx:J}=this._processInputParams($),{shape:W,keys:X}=this._getCached(),Q=[];if(!(this._def.catchall instanceof P&&this._def.unknownKeys==="strip")){for(let G in J.data)if(!X.includes(G))Q.push(G)}let Y=[];for(let G of X){let O=W[G],v=J.data[G];Y.push({key:{status:"valid",value:G},value:O._parse(new b(J,v,J.path,G)),alwaysSet:G in J.data})}if(this._def.catchall instanceof P){let G=this._def.unknownKeys;if(G==="passthrough")for(let O of Q)Y.push({key:{status:"valid",value:O},value:{status:"valid",value:J.data[O]}});else if(G==="strict"){if(Q.length>0)w(J,{code:H.unrecognized_keys,keys:Q}),_.dirty()}else if(G==="strip");else throw Error("Internal ZodObject error: invalid unknownKeys value.")}else{let G=this._def.catchall;for(let O of Q){let v=J.data[O];Y.push({key:{status:"valid",value:O},value:G._parse(new b(J,v,J.path,O)),alwaysSet:O in J.data})}}if(J.common.async)return Promise.resolve().then(async()=>{let G=[];for(let O of Y){let v=await O.key,A$=await O.value;G.push({key:v,value:A$,alwaysSet:O.alwaysSet})}return G}).then((G)=>{return L.mergeObjectSync(_,G)});else return L.mergeObjectSync(_,Y)}get shape(){return this._def.shape()}strict($){return j.errToObj,new S({...this._def,unknownKeys:"strict",...$!==void 0?{errorMap:(q,_)=>{let J=this._def.errorMap?.(q,_).message??_.defaultError;if(q.code==="unrecognized_keys")return{message:j.errToObj($).message??J};return{message:J}}}:{}})}strip(){return new S({...this._def,unknownKeys:"strip"})}passthrough(){return new S({...this._def,unknownKeys:"passthrough"})}extend($){return new S({...this._def,shape:()=>({...this._def.shape(),...$})})}merge($){return new S({unknownKeys:$._def.unknownKeys,catchall:$._def.catchall,shape:()=>({...this._def.shape(),...$._def.shape()}),typeName:B.ZodObject})}setKey($,q){return this.augment({[$]:q})}catchall($){return new S({...this._def,catchall:$})}pick($){let q={};for(let _ of U.objectKeys($))if($[_]&&this.shape[_])q[_]=this.shape[_];return new S({...this._def,shape:()=>q})}omit($){let q={};for(let _ of U.objectKeys(this.shape))if(!$[_])q[_]=this.shape[_];return new S({...this._def,shape:()=>q})}deepPartial(){return a(this)}partial($){let q={};for(let _ of U.objectKeys(this.shape)){let J=this.shape[_];if($&&!$[_])q[_]=J;else q[_]=J.optional()}return new S({...this._def,shape:()=>q})}required($){let q={};for(let _ of U.objectKeys(this.shape))if($&&!$[_])q[_]=this.shape[_];else{let W=this.shape[_];while(W instanceof N)W=W._def.innerType;q[_]=W}return new S({...this._def,shape:()=>q})}keyof(){return h$(U.objectKeys(this.shape))}}S.create=($,q)=>{return new S({shape:()=>$,unknownKeys:"strip",catchall:P.create(),typeName:B.ZodObject,...V(q)})};S.strictCreate=($,q)=>{return new S({shape:()=>$,unknownKeys:"strict",catchall:P.create(),typeName:B.ZodObject,...V(q)})};S.lazycreate=($,q)=>{return new S({shape:$,unknownKeys:"strip",catchall:P.create(),typeName:B.ZodObject,...V(q)})};class q$ extends A{_parse($){let{ctx:q}=this._processInputParams($),_=this._def.options;function J(W){for(let Q of W)if(Q.result.status==="valid")return Q.result;for(let Q of W)if(Q.result.status==="dirty")return q.common.issues.push(...Q.ctx.common.issues),Q.result;let X=W.map((Q)=>new F(Q.ctx.common.issues));return w(q,{code:H.invalid_union,unionErrors:X}),z}if(q.common.async)return Promise.all(_.map(async(W)=>{let X={...q,common:{...q.common,issues:[]},parent:null};return{result:await W._parseAsync({data:q.data,path:q.path,parent:X}),ctx:X}})).then(J);else{let W=void 0,X=[];for(let Y of _){let G={...q,common:{...q.common,issues:[]},parent:null},O=Y._parseSync({data:q.data,path:q.path,parent:G});if(O.status==="valid")return O;else if(O.status==="dirty"&&!W)W={result:O,ctx:G};if(G.common.issues.length)X.push(G.common.issues)}if(W)return q.common.issues.push(...W.ctx.common.issues),W.result;let Q=X.map((Y)=>new F(Y));return w(q,{code:H.invalid_union,unionErrors:Q}),z}}get options(){return this._def.options}}q$.create=($,q)=>{return new q$({options:$,typeName:B.ZodUnion,...V(q)})};var h=($)=>{if($ instanceof W$)return h($.schema);else if($ instanceof k)return h($.innerType());else if($ instanceof J$)return[$.value];else if($ instanceof u)return $.options;else if($ instanceof X$)return U.objectValues($.enum);else if($ instanceof Q$)return h($._def.innerType);else if($ instanceof e)return[void 0];else if($ instanceof $$)return[null];else if($ instanceof N)return[void 0,...h($.unwrap())];else if($ instanceof x)return[null,...h($.unwrap())];else if($ instanceof L$)return h($.unwrap());else if($ instanceof Y$)return h($.unwrap());else if($ instanceof H$)return h($._def.innerType);else return[]};class E$ extends A{_parse($){let{ctx:q}=this._processInputParams($);if(q.parsedType!==M.object)return w(q,{code:H.invalid_type,expected:M.object,received:q.parsedType}),z;let _=this.discriminator,J=q.data[_],W=this.optionsMap.get(J);if(!W)return w(q,{code:H.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[_]}),z;if(q.common.async)return W._parseAsync({data:q.data,path:q.path,parent:q});else return W._parseSync({data:q.data,path:q.path,parent:q})}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create($,q,_){let J=new Map;for(let W of q){let X=h(W.shape[$]);if(!X.length)throw Error(`A discriminator value for key \`${$}\` could not be extracted from all schema options`);for(let Q of X){if(J.has(Q))throw Error(`Discriminator property ${String($)} has duplicate value ${String(Q)}`);J.set(Q,W)}}return new E$({typeName:B.ZodDiscriminatedUnion,discriminator:$,options:q,optionsMap:J,...V(_)})}}function K$($,q){let _=I($),J=I(q);if($===q)return{valid:!0,data:$};else if(_===M.object&&J===M.object){let W=U.objectKeys(q),X=U.objectKeys($).filter((Y)=>W.indexOf(Y)!==-1),Q={...$,...q};for(let Y of X){let G=K$($[Y],q[Y]);if(!G.valid)return{valid:!1};Q[Y]=G.data}return{valid:!0,data:Q}}else if(_===M.array&&J===M.array){if($.length!==q.length)return{valid:!1};let W=[];for(let X=0;X<$.length;X++){let Q=$[X],Y=q[X],G=K$(Q,Y);if(!G.valid)return{valid:!1};W.push(G.data)}return{valid:!0,data:W}}else if(_===M.date&&J===M.date&&+$===+q)return{valid:!0,data:$};else return{valid:!1}}class _$ extends A{_parse($){let{status:q,ctx:_}=this._processInputParams($),J=(W,X)=>{if(U$(W)||U$(X))return z;let Q=K$(W.value,X.value);if(!Q.valid)return w(_,{code:H.invalid_intersection_types}),z;if(S$(W)||S$(X))q.dirty();return{status:q.value,value:Q.data}};if(_.common.async)return Promise.all([this._def.left._parseAsync({data:_.data,path:_.path,parent:_}),this._def.right._parseAsync({data:_.data,path:_.path,parent:_})]).then(([W,X])=>J(W,X));else return J(this._def.left._parseSync({data:_.data,path:_.path,parent:_}),this._def.right._parseSync({data:_.data,path:_.path,parent:_}))}}_$.create=($,q,_)=>{return new _$({left:$,right:q,typeName:B.ZodIntersection,...V(_)})};class g extends A{_parse($){let{status:q,ctx:_}=this._processInputParams($);if(_.parsedType!==M.array)return w(_,{code:H.invalid_type,expected:M.array,received:_.parsedType}),z;if(_.data.length<this._def.items.length)return w(_,{code:H.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),z;if(!this._def.rest&&_.data.length>this._def.items.length)w(_,{code:H.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),q.dirty();let W=[..._.data].map((X,Q)=>{let Y=this._def.items[Q]||this._def.rest;if(!Y)return null;return Y._parse(new b(_,X,_.path,Q))}).filter((X)=>!!X);if(_.common.async)return Promise.all(W).then((X)=>{return L.mergeArray(q,X)});else return L.mergeArray(q,W)}get items(){return this._def.items}rest($){return new g({...this._def,rest:$})}}g.create=($,q)=>{if(!Array.isArray($))throw Error("You must pass an array of schemas to z.tuple([ ... ])");return new g({items:$,typeName:B.ZodTuple,rest:null,...V(q)})};class j$ extends A{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse($){let{status:q,ctx:_}=this._processInputParams($);if(_.parsedType!==M.object)return w(_,{code:H.invalid_type,expected:M.object,received:_.parsedType}),z;let J=[],W=this._def.keyType,X=this._def.valueType;for(let Q in _.data)J.push({key:W._parse(new b(_,Q,_.path,Q)),value:X._parse(new b(_,_.data[Q],_.path,Q)),alwaysSet:Q in _.data});if(_.common.async)return L.mergeObjectAsync(q,J);else return L.mergeObjectSync(q,J)}get element(){return this._def.valueType}static create($,q,_){if(q instanceof A)return new j$({keyType:$,valueType:q,typeName:B.ZodRecord,...V(_)});return new j$({keyType:K.create(),valueType:$,typeName:B.ZodRecord,...V(q)})}}class z$ extends A{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse($){let{status:q,ctx:_}=this._processInputParams($);if(_.parsedType!==M.map)return w(_,{code:H.invalid_type,expected:M.map,received:_.parsedType}),z;let J=this._def.keyType,W=this._def.valueType,X=[..._.data.entries()].map(([Q,Y],G)=>{return{key:J._parse(new b(_,Q,_.path,[G,"key"])),value:W._parse(new b(_,Y,_.path,[G,"value"]))}});if(_.common.async){let Q=new Map;return Promise.resolve().then(async()=>{for(let Y of X){let G=await Y.key,O=await Y.value;if(G.status==="aborted"||O.status==="aborted")return z;if(G.status==="dirty"||O.status==="dirty")q.dirty();Q.set(G.value,O.value)}return{status:q.value,value:Q}})}else{let Q=new Map;for(let Y of X){let{key:G,value:O}=Y;if(G.status==="aborted"||O.status==="aborted")return z;if(G.status==="dirty"||O.status==="dirty")q.dirty();Q.set(G.value,O.value)}return{status:q.value,value:Q}}}}z$.create=($,q,_)=>{return new z$({valueType:q,keyType:$,typeName:B.ZodMap,...V(_)})};class p extends A{_parse($){let{status:q,ctx:_}=this._processInputParams($);if(_.parsedType!==M.set)return w(_,{code:H.invalid_type,expected:M.set,received:_.parsedType}),z;let J=this._def;if(J.minSize!==null){if(_.data.size<J.minSize.value)w(_,{code:H.too_small,minimum:J.minSize.value,type:"set",inclusive:!0,exact:!1,message:J.minSize.message}),q.dirty()}if(J.maxSize!==null){if(_.data.size>J.maxSize.value)w(_,{code:H.too_big,maximum:J.maxSize.value,type:"set",inclusive:!0,exact:!1,message:J.maxSize.message}),q.dirty()}let W=this._def.valueType;function X(Y){let G=new Set;for(let O of Y){if(O.status==="aborted")return z;if(O.status==="dirty")q.dirty();G.add(O.value)}return{status:q.value,value:G}}let Q=[..._.data.values()].map((Y,G)=>W._parse(new b(_,Y,_.path,G)));if(_.common.async)return Promise.all(Q).then((Y)=>X(Y));else return X(Q)}min($,q){return new p({...this._def,minSize:{value:$,message:j.toString(q)}})}max($,q){return new p({...this._def,maxSize:{value:$,message:j.toString(q)}})}size($,q){return this.min($,q).max($,q)}nonempty($){return this.min(1,$)}}p.create=($,q)=>{return new p({valueType:$,minSize:null,maxSize:null,typeName:B.ZodSet,...V(q)})};class s extends A{constructor(){super(...arguments);this.validate=this.implement}_parse($){let{ctx:q}=this._processInputParams($);if(q.parsedType!==M.function)return w(q,{code:H.invalid_type,expected:M.function,received:q.parsedType}),z;function _(Q,Y){return G$({data:Q,path:q.path,errorMaps:[q.common.contextualErrorMap,q.schemaErrorMap,o(),T].filter((G)=>!!G),issueData:{code:H.invalid_arguments,argumentsError:Y}})}function J(Q,Y){return G$({data:Q,path:q.path,errorMaps:[q.common.contextualErrorMap,q.schemaErrorMap,o(),T].filter((G)=>!!G),issueData:{code:H.invalid_return_type,returnTypeError:Y}})}let W={errorMap:q.common.contextualErrorMap},X=q.data;if(this._def.returns instanceof d){let Q=this;return D(async function(...Y){let G=new F([]),O=await Q._def.args.parseAsync(Y,W).catch((D$)=>{throw G.addIssue(_(Y,D$)),G}),v=await Reflect.apply(X,this,O);return await Q._def.returns._def.type.parseAsync(v,W).catch((D$)=>{throw G.addIssue(J(v,D$)),G})})}else{let Q=this;return D(function(...Y){let G=Q._def.args.safeParse(Y,W);if(!G.success)throw new F([_(Y,G.error)]);let O=Reflect.apply(X,this,G.data),v=Q._def.returns.safeParse(O,W);if(!v.success)throw new F([J(O,v.error)]);return v.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...$){return new s({...this._def,args:g.create($).rest(y.create())})}returns($){return new s({...this._def,returns:$})}implement($){return this.parse($)}strictImplement($){return this.parse($)}static create($,q,_){return new s({args:$?$:g.create([]).rest(y.create()),returns:q||y.create(),typeName:B.ZodFunction,...V(_)})}}class W$ extends A{get schema(){return this._def.getter()}_parse($){let{ctx:q}=this._processInputParams($);return this._def.getter()._parse({data:q.data,path:q.path,parent:q})}}W$.create=($,q)=>{return new W$({getter:$,typeName:B.ZodLazy,...V(q)})};class J$ extends A{_parse($){if($.data!==this._def.value){let q=this._getOrReturnCtx($);return w(q,{received:q.data,code:H.invalid_literal,expected:this._def.value}),z}return{status:"valid",value:$.data}}get value(){return this._def.value}}J$.create=($,q)=>{return new J$({value:$,typeName:B.ZodLiteral,...V(q)})};function h$($,q){return new u({values:$,typeName:B.ZodEnum,...V(q)})}class u extends A{_parse($){if(typeof $.data!=="string"){let q=this._getOrReturnCtx($),_=this._def.values;return w(q,{expected:U.joinValues(_),received:q.parsedType,code:H.invalid_type}),z}if(!this._cache)this._cache=new Set(this._def.values);if(!this._cache.has($.data)){let q=this._getOrReturnCtx($),_=this._def.values;return w(q,{received:q.data,code:H.invalid_enum_value,options:_}),z}return D($.data)}get options(){return this._def.values}get enum(){let $={};for(let q of this._def.values)$[q]=q;return $}get Values(){let $={};for(let q of this._def.values)$[q]=q;return $}get Enum(){let $={};for(let q of this._def.values)$[q]=q;return $}extract($,q=this._def){return u.create($,{...this._def,...q})}exclude($,q=this._def){return u.create(this.options.filter((_)=>!$.includes(_)),{...this._def,...q})}}u.create=h$;class X$ extends A{_parse($){let q=U.getValidEnumValues(this._def.values),_=this._getOrReturnCtx($);if(_.parsedType!==M.string&&_.parsedType!==M.number){let J=U.objectValues(q);return w(_,{expected:U.joinValues(J),received:_.parsedType,code:H.invalid_type}),z}if(!this._cache)this._cache=new Set(U.getValidEnumValues(this._def.values));if(!this._cache.has($.data)){let J=U.objectValues(q);return w(_,{received:_.data,code:H.invalid_enum_value,options:J}),z}return D($.data)}get enum(){return this._def.values}}X$.create=($,q)=>{return new X$({values:$,typeName:B.ZodNativeEnum,...V(q)})};class d extends A{unwrap(){return this._def.type}_parse($){let{ctx:q}=this._processInputParams($);if(q.parsedType!==M.promise&&q.common.async===!1)return w(q,{code:H.invalid_type,expected:M.promise,received:q.parsedType}),z;let _=q.parsedType===M.promise?q.data:Promise.resolve(q.data);return D(_.then((J)=>{return this._def.type.parseAsync(J,{path:q.path,errorMap:q.common.contextualErrorMap})}))}}d.create=($,q)=>{return new d({type:$,typeName:B.ZodPromise,...V(q)})};class k extends A{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===B.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse($){let{status:q,ctx:_}=this._processInputParams($),J=this._def.effect||null,W={addIssue:(X)=>{if(w(_,X),X.fatal)q.abort();else q.dirty()},get path(){return _.path}};if(W.addIssue=W.addIssue.bind(W),J.type==="preprocess"){let X=J.transform(_.data,W);if(_.common.async)return Promise.resolve(X).then(async(Q)=>{if(q.value==="aborted")return z;let Y=await this._def.schema._parseAsync({data:Q,path:_.path,parent:_});if(Y.status==="aborted")return z;if(Y.status==="dirty")return c(Y.value);if(q.value==="dirty")return c(Y.value);return Y});else{if(q.value==="aborted")return z;let Q=this._def.schema._parseSync({data:X,path:_.path,parent:_});if(Q.status==="aborted")return z;if(Q.status==="dirty")return c(Q.value);if(q.value==="dirty")return c(Q.value);return Q}}if(J.type==="refinement"){let X=(Q)=>{let Y=J.refinement(Q,W);if(_.common.async)return Promise.resolve(Y);if(Y instanceof Promise)throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return Q};if(_.common.async===!1){let Q=this._def.schema._parseSync({data:_.data,path:_.path,parent:_});if(Q.status==="aborted")return z;if(Q.status==="dirty")q.dirty();return X(Q.value),{status:q.value,value:Q.value}}else return this._def.schema._parseAsync({data:_.data,path:_.path,parent:_}).then((Q)=>{if(Q.status==="aborted")return z;if(Q.status==="dirty")q.dirty();return X(Q.value).then(()=>{return{status:q.value,value:Q.value}})})}if(J.type==="transform")if(_.common.async===!1){let X=this._def.schema._parseSync({data:_.data,path:_.path,parent:_});if(!l(X))return z;let Q=J.transform(X.value,W);if(Q instanceof Promise)throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:q.value,value:Q}}else return this._def.schema._parseAsync({data:_.data,path:_.path,parent:_}).then((X)=>{if(!l(X))return z;return Promise.resolve(J.transform(X.value,W)).then((Q)=>({status:q.value,value:Q}))});U.assertNever(J)}}k.create=($,q,_)=>{return new k({schema:$,typeName:B.ZodEffects,effect:q,...V(_)})};k.createWithPreprocess=($,q,_)=>{return new k({schema:q,effect:{type:"preprocess",transform:$},typeName:B.ZodEffects,...V(_)})};class N extends A{_parse($){if(this._getType($)===M.undefined)return D(void 0);return this._def.innerType._parse($)}unwrap(){return this._def.innerType}}N.create=($,q)=>{return new N({innerType:$,typeName:B.ZodOptional,...V(q)})};class x extends A{_parse($){if(this._getType($)===M.null)return D(null);return this._def.innerType._parse($)}unwrap(){return this._def.innerType}}x.create=($,q)=>{return new x({innerType:$,typeName:B.ZodNullable,...V(q)})};class Q$ extends A{_parse($){let{ctx:q}=this._processInputParams($),_=q.data;if(q.parsedType===M.undefined)_=this._def.defaultValue();return this._def.innerType._parse({data:_,path:q.path,parent:q})}removeDefault(){return this._def.innerType}}Q$.create=($,q)=>{return new Q$({innerType:$,typeName:B.ZodDefault,defaultValue:typeof q.default==="function"?q.default:()=>q.default,...V(q)})};class H$ extends A{_parse($){let{ctx:q}=this._processInputParams($),_={...q,common:{...q.common,issues:[]}},J=this._def.innerType._parse({data:_.data,path:_.path,parent:{..._}});if(r(J))return J.then((W)=>{return{status:"valid",value:W.status==="valid"?W.value:this._def.catchValue({get error(){return new F(_.common.issues)},input:_.data})}});else return{status:"valid",value:J.status==="valid"?J.value:this._def.catchValue({get error(){return new F(_.common.issues)},input:_.data})}}removeCatch(){return this._def.innerType}}H$.create=($,q)=>{return new H$({innerType:$,typeName:B.ZodCatch,catchValue:typeof q.catch==="function"?q.catch:()=>q.catch,...V(q)})};class B$ extends A{_parse($){if(this._getType($)!==M.nan){let _=this._getOrReturnCtx($);return w(_,{code:H.invalid_type,expected:M.nan,received:_.parsedType}),z}return{status:"valid",value:$.data}}}B$.create=($)=>{return new B$({typeName:B.ZodNaN,...V($)})};var Lq=Symbol("zod_brand");class L$ extends A{_parse($){let{ctx:q}=this._processInputParams($),_=q.data;return this._def.type._parse({data:_,path:q.path,parent:q})}unwrap(){return this._def.type}}class O$ extends A{_parse($){let{status:q,ctx:_}=this._processInputParams($);if(_.common.async)return(async()=>{let W=await this._def.in._parseAsync({data:_.data,path:_.path,parent:_});if(W.status==="aborted")return z;if(W.status==="dirty")return q.dirty(),c(W.value);else return this._def.out._parseAsync({data:W.value,path:_.path,parent:_})})();else{let J=this._def.in._parseSync({data:_.data,path:_.path,parent:_});if(J.status==="aborted")return z;if(J.status==="dirty")return q.dirty(),{status:"dirty",value:J.value};else return this._def.out._parseSync({data:J.value,path:_.path,parent:_})}}static create($,q){return new O$({in:$,out:q,typeName:B.ZodPipeline})}}class Y$ extends A{_parse($){let q=this._def.innerType._parse($),_=(J)=>{if(l(J))J.value=Object.freeze(J.value);return J};return r(q)?q.then((J)=>_(J)):_(q)}unwrap(){return this._def.innerType}}Y$.create=($,q)=>{return new Y$({innerType:$,typeName:B.ZodReadonly,...V(q)})};function I$($,q){let _=typeof $==="function"?$(q):typeof $==="string"?{message:$}:$;return typeof _==="string"?{message:_}:_}function x$($,q={},_){if($)return i.create().superRefine((J,W)=>{let X=$(J);if(X instanceof Promise)return X.then((Q)=>{if(!Q){let Y=I$(q,J),G=Y.fatal??_??!0;W.addIssue({code:"custom",...Y,fatal:G})}});if(!X){let Q=I$(q,J),Y=Q.fatal??_??!0;W.addIssue({code:"custom",...Q,fatal:Y})}return});return i.create()}var vq={object:S.lazycreate},B;(function($){$.ZodString="ZodString",$.ZodNumber="ZodNumber",$.ZodNaN="ZodNaN",$.ZodBigInt="ZodBigInt",$.ZodBoolean="ZodBoolean",$.ZodDate="ZodDate",$.ZodSymbol="ZodSymbol",$.ZodUndefined="ZodUndefined",$.ZodNull="ZodNull",$.ZodAny="ZodAny",$.ZodUnknown="ZodUnknown",$.ZodNever="ZodNever",$.ZodVoid="ZodVoid",$.ZodArray="ZodArray",$.ZodObject="ZodObject",$.ZodUnion="ZodUnion",$.ZodDiscriminatedUnion="ZodDiscriminatedUnion",$.ZodIntersection="ZodIntersection",$.ZodTuple="ZodTuple",$.ZodRecord="ZodRecord",$.ZodMap="ZodMap",$.ZodSet="ZodSet",$.ZodFunction="ZodFunction",$.ZodLazy="ZodLazy",$.ZodLiteral="ZodLiteral",$.ZodEnum="ZodEnum",$.ZodEffects="ZodEffects",$.ZodNativeEnum="ZodNativeEnum",$.ZodOptional="ZodOptional",$.ZodNullable="ZodNullable",$.ZodDefault="ZodDefault",$.ZodCatch="ZodCatch",$.ZodPromise="ZodPromise",$.ZodBranded="ZodBranded",$.ZodPipeline="ZodPipeline",$.ZodReadonly="ZodReadonly"})(B||(B={}));var Dq=($,q={message:`Input not instance of ${$.name}`})=>x$((_)=>_ instanceof $,q),l$=K.create,y$=m.create,fq=B$.create,Fq=Z.create,m$=t.create,Kq=n.create,Rq=M$.create,Nq=e.create,bq=$$.create,kq=i.create,Cq=y.create,Iq=P.create,Pq=w$.create,gq=R.create,Tq=S.create,hq=S.strictCreate,xq=q$.create,lq=E$.create,yq=_$.create,mq=g.create,Zq=j$.create,uq=z$.create,cq=p.create,nq=s.create,iq=W$.create,pq=J$.create,dq=u.create,oq=X$.create,rq=d.create,aq=k.create,sq=N.create,tq=x.create,eq=k.createWithPreprocess,$_=O$.create,q_=()=>l$().optional(),__=()=>y$().optional(),W_=()=>m$().optional(),J_={string:($)=>K.create({...$,coerce:!0}),number:($)=>m.create({...$,coerce:!0}),boolean:($)=>t.create({...$,coerce:!0}),bigint:($)=>Z.create({...$,coerce:!0}),date:($)=>n.create({...$,coerce:!0})};var X_=z;var i$=E.object({name:E.string().min(1,"Branch name cannot be empty"),specId:E.string().regex(/^\d{3}-.+$/,"Spec ID must match pattern NNN-feature-name"),baseBranch:E.string().min(1,"Base branch cannot be empty"),status:E.enum(["active","submitted","merged","abandoned"]),pr:E.number().int().positive().nullable(),createdAt:E.string().datetime({message:"Invalid ISO 8601 timestamp"}),updatedAt:E.string().datetime({message:"Invalid ISO 8601 timestamp"}),parentSpecId:E.string().regex(/^\d{3}-.+$/,"Parent spec ID must match pattern NNN-feature-name").optional()}),N$=E.object({version:E.string().regex(/^\d+\.\d+\.\d+$/,"Version must be semver format"),branches:E.array(i$),specIndex:E.record(E.string(),E.array(E.string()))}),p$="1.1.0",d$=".speck/branches.json";async function Z$($){let q=R$.join($,d$);if(!n$(q))return{version:p$,branches:[],specIndex:{}};try{let _=await v$.readFile(q,"utf-8"),J=JSON.parse(_),W=N$.safeParse(J);if(!W.success){let X=w_(J,$);if(X)return console.warn("[WARN] Auto-repaired branches.json - review changes"),await G_($,X),X;throw Error(`Corrupted branches.json - restore from git history:
  git show HEAD:.speck/branches.json > .speck/branches.json

Validation errors:
${W.error.message}`)}return W.data}catch(_){if(_ instanceof SyntaxError)throw Error(`Corrupted branches.json (invalid JSON) - restore from git history:
  git show HEAD:.speck/branches.json > .speck/branches.json`);throw _}}async function G_($,q){let _=R$.join($,d$),J=`${_}.tmp`,W=N$.safeParse(q);if(!W.success)throw Error(`Invalid branch mapping: ${W.error.message}`);let X=R$.join($,".speck");if(!n$(X))await v$.mkdir(X,{recursive:!0});let Q=JSON.stringify(q,null,2);await v$.writeFile(J,Q,"utf-8"),await v$.rename(J,_)}function b$($){let q={};for(let _ of $.branches){if(!q[_.specId])q[_.specId]=[];q[_.specId].push(_.name)}return{...$,specIndex:q}}function i_($,q){let _=$.branches.find((J)=>J.name===q);return _?_.specId:null}function o$($,q){return $.branches.find((_)=>_.name===q)||null}function p_($,q){let _=i$.safeParse(q);if(!_.success)throw Error(`Invalid branch entry: ${_.error.message}`);if($.branches.some((W)=>W.name===q.name))throw Error(`Branch '${q.name}' already exists in mapping`);let J=[...$.branches,q];return b$({...$,branches:J})}function d_($,q,_,J){let W=o$($,q);if(!W)throw Error(`Branch '${q}' not found in mapping`);if(M_(W.status,_),_==="submitted"&&!J&&!W.pr)throw Error("PR number required for 'submitted' status");let X=$.branches.map((Q)=>Q.name===q?{...Q,status:_,pr:J!==void 0?J:Q.pr,updatedAt:new Date().toISOString()}:Q);return{...$,branches:X}}function o_($,q){if(!o$($,q))throw Error(`Branch '${q}' not found in mapping`);let J=$.branches.filter((W)=>W.name!==q);return b$({...$,branches:J})}function r_($,q){let _=new Set,J=new Set,W=[];function X(Q){if(J.has(Q)){let G=W.indexOf(Q);return[...W.slice(G),Q]}if(_.has(Q))return null;_.add(Q),J.add(Q),W.push(Q);let Y=q.branches.find((G)=>G.name===Q);if(Y&&Y.baseBranch){if(q.branches.some((O)=>O.name===Y.baseBranch)){let O=X(Y.baseBranch);if(O)return O}}return W.pop(),J.delete(Q),null}return X($)}function M_($,q){if($==="merged")throw Error("Cannot transition from 'merged' (terminal state)");if($==="abandoned")throw Error("Cannot transition from 'abandoned' (terminal state)")}function w_($,q){try{let _=$;if(!_.version)_.version=p$;if(!Array.isArray(_.branches))_.branches=[];for(let X of _.branches){if(!X.createdAt||!u$(X.createdAt))X.createdAt=new Date().toISOString();if(!X.updatedAt||!u$(X.updatedAt))X.updatedAt=new Date().toISOString()}if(!_.specIndex||typeof _.specIndex!=="object")_.specIndex={};let J=b$(_),W=N$.safeParse(J);if(W.success)return W.data;return null}catch{return null}}function u$($){try{return new Date($).toISOString()===$}catch{return!1}}async function a_($,q){let{findChildReposWithNames:_}=await import("./paths-qqmkr5wb.js"),J=null;try{let G=await Z$($);if(G.branches.length>0)J=c$($,"root",G)}catch(G){}let W=new Map,X=await _($),Q=Array.from(X.entries()).map(async([G,O])=>{try{let v=await Z$(O);if(v.branches.length>0){let A$=c$(O,G,v);return{childName:G,summary:A$}}}catch(v){}return null}),Y=await Promise.all(Q);for(let G of Y)if(G)W.set(G.childName,G.summary);return{rootRepo:J,childRepos:W}}function c$($,q,_){let J={active:0,submitted:0,merged:0,abandoned:0};for(let Y of _.branches)J[Y.status]++;let W=[...new Set(_.branches.map((Y)=>Y.specId))],X=W.length===1?W[0]??null:null,Q=j_(_);return{repoPath:$,repoName:q,specId:X,branchCount:_.branches.length,statusCounts:J,chains:Q,branches:_.branches}}function j_($){let q=[],_=new Set,J=new Set($.branches.map((X)=>X.name)),W=$.branches.filter((X)=>!J.has(X.baseBranch));for(let X of W)if(!_.has(X.name)){let Q=r$(X.name,$,_);if(Q.length>0)q.push({branches:Q})}return q}function r$($,q,_){_.add($);let J=q.branches.filter((X)=>X.baseBranch===$);if(J.length===0)return[$];let W=J[0];if(W&&!_.has(W.name))return[$,...r$(W.name,q,_)];return[$]}class z_ extends Error{constructor($){super($);this.name="ValidationError"}}class f extends Error{constructor($){super($);this.name="GitError"}}var{$:C}=globalThis.Bun;var V$=new Map;async function qW($,q,_){if((await C`git -C ${_} rev-parse --verify ${q}`.quiet()).exitCode!==0)throw new f(`Base branch '${q}' does not exist`);if((await C`git check-ref-format --branch ${$}`.quiet()).exitCode!==0)throw new f(`Invalid branch name: '${$}'`);let X=await C`git -C ${_} branch ${$} ${q}`.quiet();if(X.exitCode!==0){let Q=X.stderr.toString();throw new f(`Failed to create branch: ${Q}`)}}async function _W($,q,_){try{let J=await C`git -C ${_} branch --merged ${q}`.quiet();if(J.exitCode!==0)throw new f(`Failed to check merged status for '${$}'`);return J.text().split(`
`).map((Q)=>Q.trim().replace(/^\*\s*/,"")).filter(Boolean).includes($)}catch(J){if(J instanceof f)throw J;throw new f(`Failed to check merged status: ${String(J)}`)}}async function WW($,q){try{let _=q?`git -C ${$} branch --list --format='%(refname:short)|%(upstream:short)' ${q}`:`git -C ${$} branch --list --format='%(refname:short)|%(upstream:short)'`,J=await C`sh -c ${_}`.quiet();if(J.exitCode!==0){let X=J.stderr.toString();throw new f(`Failed to list branches: ${X}`)}return J.stdout.toString().split(`
`).filter(Boolean).map((X)=>{let[Q,Y]=X.split("|");if(!Q)throw new f("Invalid branch line format");return{name:Q.trim(),upstream:Y?.trim()||null}})}catch(_){if(_ instanceof f)throw _;throw new f(`Failed to list branches: ${String(_)}`)}}async function JW($,q){let _=await C`git -C ${q} checkout ${$}`.quiet();if(_.exitCode!==0){let J=_.stderr.toString();throw new f(`Failed to checkout branch '${$}': ${J}`)}}async function XW($){let q=await C`git -C ${$} rev-parse --abbrev-ref HEAD`.quiet();if(q.exitCode!==0)throw new f("Failed to get current branch");let _=q.stdout.toString().trim();if(_==="HEAD")throw new f("Currently in detached HEAD state");return _}async function B_($,q){try{return(await C`git -C ${q} rev-parse --verify ${$}`.quiet()).exitCode===0}catch{return!1}}async function QW($,q){let _=await C`git -C ${q} branch --list ${$}`.quiet();if(_.exitCode!==0||!_.stdout.toString().trim())throw new f(`Base branch '${$}' does not exist in current repository.

Cross-repo branch dependencies are not supported.

Alternatives:
  1. Complete work in other repo first and merge to main
  2. Use shared contracts/APIs for coordination
  3. Manually coordinate PR merge order across repos`)}async function HW($){if(V$.has($))return V$.get($);try{let _=await C`git -C ${$} symbolic-ref refs/remotes/origin/HEAD`.quiet();if(_.exitCode===0){let W=_.stdout.toString().trim().match(/refs\/remotes\/origin\/(.+)/);if(W&&W[1]){let X=W[1];return V$.set($,X),X}}}catch{}let q=["main","master","develop"];for(let _ of q)if(await B_(_,$))return V$.set($,_),_;return V$.set($,null),null}async function YW($){try{let q=await C`git -C ${$} remote get-url origin`.quiet();if(q.exitCode===0)return q.stdout.toString().trim();return null}catch{return null}}
export{Z$ as a,G_ as b,i_ as c,o$ as d,p_ as e,d_ as f,o_ as g,r_ as h,a_ as i,z_ as j,f as k,qW as l,_W as m,WW as n,JW as o,XW as p,B_ as q,QW as r,HW as s,YW as t};
