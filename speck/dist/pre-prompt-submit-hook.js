#!/usr/bin/env bun
// @bun
var f=Object.create;var{getPrototypeOf:d,defineProperty:E,getOwnPropertyNames:u}=Object;var g=Object.prototype.hasOwnProperty;var l=(Y,Q,H)=>{H=Y!=null?f(d(Y)):{};let V=Q||!Y||!Y.__esModule?E(H,"default",{value:Y,enumerable:!0}):H;for(let J of u(Y))if(!g.call(V,J))E(V,J,{get:()=>Y[J],enumerable:!0});return V};var h=import.meta.require;import{existsSync as $,readdirSync as D,readFileSync as M}from"fs";import{join as _}from"path";import{existsSync as j}from"fs";import{readdirSync as w}from"fs";import G from"fs/promises";import W from"path";var{$:N}=globalThis.Bun;async function p(){try{return(await N`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{return process.cwd()}}var T=null;async function c(){if(T)return T;let Y=await p(),Q=W.join(Y,".speck","root");try{if(!(await G.lstat(Q)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let K={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:W.join(Y,"specs")};return T=K,K}let V=await G.realpath(Q),J=["/","/etc","/usr","/bin","/sbin","/System","/Library"],X=process.env.HOME||process.env.USERPROFILE||"";if(J.some((K)=>V===K||V.startsWith(K+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${V}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(X&&V===W.dirname(X))throw Error(`Security: .speck/root symlink points above home directory: ${V}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await G.access(V);let Z=W.join(Y,"specs");try{if((await G.stat(Z)).isDirectory()&&V!==Y)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${Z}
  Shared: ${W.join(V,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${Z}/* ${W.join(V,"specs")}/
  2. Remove local specs: rm -rf ${Z}
`)}catch(K){let v=K;if(v.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${v.message}`)}let U={mode:"multi-repo",speckRoot:V,repoRoot:Y,specsDir:W.join(V,"specs")};return T=U,U}catch(H){let V=H;if(V.code==="ENOENT"){if((await n(Y)).length>0){let U={mode:"multi-repo",speckRoot:Y,repoRoot:Y,specsDir:W.join(Y,"specs")};return T=U,U}let Z={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:W.join(Y,"specs")};return T=Z,Z}if(V.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let J=await G.readlink(Q).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${J} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}async function n(Y){let Q=[];try{let H=await G.readdir(Y,{withFileTypes:!0});for(let V of H)if(V.isSymbolicLink()&&V.name.startsWith(".speck-link-")){let J=W.join(Y,V.name);try{let X=await G.realpath(J);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((K)=>X===K||X.startsWith(K+"/"))){console.warn(`Security: Skipping ${V.name} - points to system directory: ${X}`);continue}let U=W.join(X,".git");try{await G.access(U),Q.push(X)}catch{console.warn(`Warning: ${V.name} points to non-git directory: ${X}`)}}catch(X){let Z=X instanceof Error?X.message:String(X);console.warn(`Warning: Broken symlink ${V.name}: ${Z}`)}}}catch(H){if(H.code!=="ENOENT")throw H}return Q}async function i(Y){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await N`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let Q=W.join(Y,"specs");if(j(Q)){let H="",V=0,J=w(Q,{withFileTypes:!0});for(let X of J)if(X.isDirectory()){let Z=X.name.match(/^(\d{3})-/);if(Z&&Z[1]){let U=parseInt(Z[1],10);if(U>V)V=U,H=X.name}}if(H)return H}return"main"}}async function s(){try{let Y=process.cwd(),Q=W.join(Y,".git");if(j(Q))return!0;return await N`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function F(Y,Q,H){if(!Q)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let V=W.join(H,".speck","branches.json");if(j(V))try{let J=await G.readFile(V,"utf-8"),X=JSON.parse(J);if(X.branches&&Array.isArray(X.branches)){if(X.branches.some((U)=>U.name===Y))return!0}}catch{}if(!/^\d{3}-/.test(Y))return console.error(`ERROR: Not on a feature branch. Current branch: ${Y}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}async function a(Y,Q,H){let V=W.join(H,".speck","branches.json");if(j(V))try{let U=await G.readFile(V,"utf-8"),K=JSON.parse(U);if(K.branches&&Array.isArray(K.branches)){let v=K.branches.find((O)=>O.name===Q);if(v&&v.specId)return W.join(Y,v.specId)}}catch{}let J=Q.match(/^(\d{3})-/);if(!J)return W.join(Y,Q);let X=J[1],Z=[];if(j(Y)){let U=w(Y,{withFileTypes:!0});for(let K of U)if(K.isDirectory()&&K.name.startsWith(`${X}-`))Z.push(K.name)}if(Z.length===0)return W.join(Y,Q);else if(Z.length===1&&Z[0])return W.join(Y,Z[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${X}': ${Z.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),W.join(Y,Q)}async function x(){let Y=await c(),Q=await i(Y.repoRoot),H=await s(),V=await a(Y.specsDir,Q,Y.repoRoot),J=W.basename(V);return{MODE:Y.mode,SPECK_ROOT:Y.speckRoot,SPECS_DIR:Y.specsDir,REPO_ROOT:Y.repoRoot,CURRENT_BRANCH:Q,HAS_GIT:H?"true":"false",FEATURE_DIR:V,FEATURE_SPEC:W.join(V,"spec.md"),IMPL_PLAN:W.join(Y.repoRoot,"specs",J,"plan.md"),TASKS:W.join(Y.repoRoot,"specs",J,"tasks.md"),RESEARCH:W.join(V,"research.md"),DATA_MODEL:W.join(V,"data-model.md"),QUICKSTART:W.join(V,"quickstart.md"),CONTRACTS_DIR:W.join(V,"contracts")}}function q(Y,Q){return j(Y)?`  \u2713 ${Q}`:`  \u2717 ${Q}`}function b(Y,Q){if(!j(Y))return`  \u2717 ${Q}`;try{return w(Y).length>0?`  \u2713 ${Q}`:`  \u2717 ${Q}`}catch{return`  \u2717 ${Q}`}}function r(Y){return{json:Y.includes("--json"),requireTasks:Y.includes("--require-tasks"),includeTasks:Y.includes("--include-tasks"),pathsOnly:Y.includes("--paths-only"),skipFeatureCheck:Y.includes("--skip-feature-check"),skipPlanCheck:Y.includes("--skip-plan-check"),help:Y.includes("--help")||Y.includes("-h"),includeFileContents:Y.includes("--include-file-contents"),includeWorkflowMode:Y.includes("--include-workflow-mode"),validateCodeQuality:Y.includes("--validate-code-quality")}}function o(){console.log(`Usage: check-prerequisites.ts [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json                   Output in JSON format
  --require-tasks          Require tasks.md to exist (for implementation phase)
  --include-tasks          Include tasks.md in AVAILABLE_DOCS list
  --paths-only             Only output path variables (no prerequisite validation)
  --skip-feature-check     Skip feature directory and plan.md validation (for /speck.specify)
  --skip-plan-check        Skip plan.md validation but check feature directory (for /speck.plan)
  --validate-code-quality  Validate TypeScript typecheck and ESLint (Constitution Principle IX)
  --include-file-contents  Include file contents in JSON output
  --include-workflow-mode  Include workflow mode in JSON output
  --help, -h               Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  bun .speck/scripts/check-prerequisites.ts --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  bun .speck/scripts/check-prerequisites.ts --json --require-tasks --include-tasks

  # Validate code quality before feature completion
  bun .speck/scripts/check-prerequisites.ts --validate-code-quality

  # Get feature paths only (no validation)
  bun .speck/scripts/check-prerequisites.ts --paths-only
`)}function e(Y,Q){if(Q){let H={MODE:Y.MODE,REPO_ROOT:Y.REPO_ROOT,BRANCH:Y.CURRENT_BRANCH,FEATURE_DIR:Y.FEATURE_DIR,FEATURE_SPEC:Y.FEATURE_SPEC,IMPL_PLAN:Y.IMPL_PLAN,TASKS:Y.TASKS};console.log(JSON.stringify(H))}else console.log(`MODE: ${Y.MODE}`),console.log(`REPO_ROOT: ${Y.REPO_ROOT}`),console.log(`BRANCH: ${Y.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${Y.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${Y.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${Y.IMPL_PLAN}`),console.log(`TASKS: ${Y.TASKS}`)}function t(Y){let Q=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--skip-plan-check","--help","-h","--include-file-contents","--include-workflow-mode","--validate-code-quality"];for(let H of Y)if(H.startsWith("--")||H.startsWith("-")){if(!Q.includes(H))console.error(`ERROR: Unknown option '${H}'. Use --help for usage information.`),process.exit(1)}}var P={maxSingleFile:24576,maxTotalFiles:102400};function A(Y,Q){if(!$(Y))return"NOT_FOUND";try{let V=Bun.file(Y).size;if(V>P.maxSingleFile)return"TOO_LARGE";if(Q.value+V>P.maxTotalFiles)return"TOO_LARGE";let J=M(Y,"utf-8");return Q.value+=V,J}catch(H){return"NOT_FOUND"}}async function YY(Y){let{$:Q}=awaitPromise.resolve(globalThis.Bun),H=await Q`bun run typecheck`.cwd(Y).nothrow().quiet();if(H.exitCode!==0)return{passed:!1,message:`\u274C TypeScript validation failed (exit code ${H.exitCode})
${H.stderr.toString()}`};let V=await Q`bun run lint`.cwd(Y).nothrow().quiet();if(V.exitCode!==0){let J=V.stdout.toString();return{passed:!1,message:`\u274C ESLint validation failed (exit code ${V.exitCode})
${J}`}}return{passed:!0,message:"\u2705 Code quality validation passed (0 typecheck errors, 0 lint errors/warnings)"}}function HY(Y,Q){let H=_(Y,"plan.md");if($(H))try{let X=M(H,"utf-8").match(/\*\*Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(X&&X[1])return X[1]}catch{}let V=_(Q,".speck","memory","constitution.md");if($(V))try{let X=M(V,"utf-8").match(/\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(X&&X[1])return X[1]}catch{}return"single-branch"}async function y(Y){if(!Y.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: Direct invocation deprecated. Prerequisites are now auto-checked via PrePromptSubmit hook.\x1B[0m
`);t(Y);let Q=r(Y);if(Q.help)return o(),0;let H=await x(),V=H.HAS_GIT==="true";if(!Q.skipFeatureCheck){if(!await F(H.CURRENT_BRANCH,V,H.REPO_ROOT))return 1}if(Q.pathsOnly||Q.skipFeatureCheck)return e(H,Q.json),0;if(!$(H.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${H.FEATURE_DIR}`),console.error("Run /speck.specify first to create the feature structure."),1;if(!Q.skipPlanCheck&&!$(H.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.plan first to create the implementation plan."),1;if(Q.requireTasks&&!$(H.TASKS))return console.error(`ERROR: tasks.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.tasks first to create the task list."),1;let J=[];if($(H.RESEARCH))J.push("research.md");if($(H.DATA_MODEL))J.push("data-model.md");if($(H.CONTRACTS_DIR))try{if(D(H.CONTRACTS_DIR).length>0)J.push("contracts/")}catch{}if($(H.QUICKSTART))J.push("quickstart.md");if(Q.includeTasks&&$(H.TASKS))J.push("tasks.md");let X;if(Q.includeFileContents){X={};let U={value:0};X["tasks.md"]=A(H.TASKS,U),X["plan.md"]=A(H.IMPL_PLAN,U),X["spec.md"]=A(H.FEATURE_SPEC,U);let K=_(H.REPO_ROOT,".speck","memory","constitution.md");X["constitution.md"]=A(K,U),X["data-model.md"]=A(H.DATA_MODEL,U),X["research.md"]=A(H.RESEARCH,U);let v=_(H.FEATURE_DIR,"checklists");if($(v))try{let O=D(v).filter((I)=>I.endsWith(".md"));for(let I of O){let m=_(v,I);X[`checklists/${I}`]=A(m,U)}}catch{}}let Z;if(Q.includeWorkflowMode)Z=HY(H.FEATURE_DIR,H.REPO_ROOT);if(Q.validateCodeQuality){let U=await YY(H.REPO_ROOT);if(!U.passed)return console.error(`
`+U.message),console.error(`
Constitution Principle IX requires zero typecheck errors and zero lint errors/warnings.`),console.error(`Fix all issues before marking the feature complete.
`),1;if(!Q.json)console.log(`
`+U.message+`
`)}if(Q.json){let U={MODE:H.MODE,FEATURE_DIR:H.FEATURE_DIR,AVAILABLE_DOCS:J,...X&&{FILE_CONTENTS:X},...Z&&{WORKFLOW_MODE:Z},IMPL_PLAN:H.IMPL_PLAN,TASKS:H.TASKS,REPO_ROOT:H.REPO_ROOT};console.log(JSON.stringify(U))}else if(console.log(`FEATURE_DIR:${H.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:"),console.log(q(H.RESEARCH,"research.md")),console.log(q(H.DATA_MODEL,"data-model.md")),console.log(b(H.CONTRACTS_DIR,"contracts/")),console.log(q(H.QUICKSTART,"quickstart.md")),Q.includeTasks)console.log(q(H.TASKS,"tasks.md"));return 0}var z=null;function S(){if(!z)return null;if(Date.now()-z.timestamp>5000)return z=null,null;return z}function L(Y){z=Y}async function QY(Y){let{log:Q,error:H}=console,V="",J="";console.log=(...X)=>{V+=X.join(" ")+`
`},console.error=(...X)=>{J+=X.join(" ")+`
`};try{return{exitCode:await Y(),stdout:V.trim(),stderr:J.trim()}}catch(X){let Z=X instanceof Error?X:Error(String(X));return J+=`Error: ${Z.message}
`,{exitCode:2,stdout:V.trim(),stderr:J.trim()}}finally{console.log=Q,console.error=H}}async function C(Y={},Q=!0){if(Q){let H=S();if(H)return{success:H.success,output:H.output,error:H.error,cached:!0}}try{let H=["--json"];if(Y.requireTasks)H.push("--require-tasks");if(Y.includeTasks)H.push("--include-tasks");if(Y.skipFeatureCheck)H.push("--skip-feature-check");if(Y.skipPlanCheck)H.push("--skip-plan-check");if(Y.includeFileContents)H.push("--include-file-contents");if(Y.includeWorkflowMode)H.push("--include-workflow-mode");let{exitCode:V,stdout:J,stderr:X}=await QY(()=>y(H));if(V===0)try{let Z=JSON.parse(J),U={success:!0,output:Z,error:null,cached:!1};return L({success:!0,output:Z,error:null,timestamp:Date.now()}),U}catch(Z){let K=`Failed to parse check-prerequisites output: ${(Z instanceof Error?Z:Error(String(Z))).message}`,v={success:!1,output:null,error:K,cached:!1};return L({success:!1,output:null,error:K,timestamp:Date.now()}),v}else{let Z=X||`check-prerequisites exited with code ${V}`,U={success:!1,output:null,error:Z,cached:!1};return L({success:!1,output:null,error:Z,timestamp:Date.now()}),U}}catch(H){let J=`Failed to run check-prerequisites: ${(H instanceof Error?H:Error(String(H))).message}`,X={success:!1,output:null,error:J,cached:!1};return L({success:!1,output:null,error:J,timestamp:Date.now()}),X}}function k(Y){if(!Y.success||!Y.output)return"";let{FEATURE_DIR:Q,AVAILABLE_DOCS:H,MODE:V,WORKFLOW_MODE:J,IMPL_PLAN:X,TASKS:Z,REPO_ROOT:U}=Y.output,K={MODE:V,FEATURE_DIR:Q,AVAILABLE_DOCS:H};if(J)K.WORKFLOW_MODE=J;if(X)K.IMPL_PLAN=X;if(Z)K.TASKS=Z;if(U)K.REPO_ROOT=U;return`<!-- SPECK_PREREQ_CONTEXT
${JSON.stringify(K)}
-->`}function R(Y){return`\u26A0\uFE0F **Prerequisite Check Failed**

${Y}

Please ensure you're on a valid feature branch and have run the necessary Speck commands.
`.trim()}import{appendFile as VY}from"fs/promises";var XY="/private/tmp/.claude-hook-test/speck-hook-log.txt",B=async(Y)=>{await VY(XY,`[${new Date().toISOString()}] [PrePromptSubmit] ${Y}
`)};function JY(Y){return/^\/speck[.:]/.test(Y.trim())}function ZY(Y){let H=Y.match(/^\/speck[.:](\w+)/)?.[1]??"",V=["implement"],J=["implement","analyze"],X=["specify","constitution","env","link"],Z=["plan","clarify","constitution","env","link"],U=["implement","analyze","plan","tasks","checklist","clarify"],K=["implement"];return{requireTasks:V.includes(H),includeTasks:J.includes(H),skipFeatureCheck:X.includes(H),skipPlanCheck:Z.includes(H),includeFileContents:U.includes(H),includeWorkflowMode:K.includes(H)}}async function UY(){try{let Y=await Bun.stdin.text();await B(`Received hook input (length: ${Y.length})`);let Q=JSON.parse(Y),{prompt:H}=Q;if(await B(`Parsed prompt: ${H.substring(0,100)}${H.length>100?"...":""}`),!JY(H)){await B("Not a /speck.* command, passing through"),console.log(JSON.stringify({}));return}let V=H.match(/^\/speck[.:]\w+/);await B(`Detected /speck.* command: ${V?.[0]??"unknown"}`);let J=ZY(H);await B(`Check options: ${JSON.stringify(J)}`);let X=await C(J,!0);if(await B(`Prerequisite check result: success=${X.success}`),X.success&&X.output){let Z=k(X);await B(`Formatted context (length: ${Z.length})`),await B(`Context preview: ${Z.substring(0,200)}`);let U={hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:Z}};await B("Returning success with additionalContext"),console.log(JSON.stringify(U))}else{let Z=R(X.error||"Unknown error");await B(`Blocking with error: ${X.error}`),console.log(JSON.stringify({decision:"block",reason:Z,hookSpecificOutput:{hookEventName:"UserPromptSubmit"}}))}}catch(Y){let Q=Y instanceof Error?Y.message:String(Y);await B(`Hook error: ${Q}`),console.error(`PrePromptSubmit hook error: ${Q}`),console.log(JSON.stringify({}))}}UY();
