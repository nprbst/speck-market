#!/usr/bin/env bun
// @bun
var c=Object.create;var{getPrototypeOf:n,defineProperty:b,getOwnPropertyNames:i}=Object;var s=Object.prototype.hasOwnProperty;var r=(Y,X,H)=>{H=Y!=null?c(n(Y)):{};let Q=X||!Y||!Y.__esModule?b(H,"default",{value:Y,enumerable:!0}):H;for(let J of i(Y))if(!s.call(Q,J))b(Q,J,{get:()=>Y[J],enumerable:!0});return Q};var a=import.meta.require;import{existsSync as B,readdirSync as R,readFileSync as E,statSync as VY}from"fs";import{join as T,basename as XY,relative as C}from"path";import{existsSync as z}from"fs";import{readdirSync as D}from"fs";import $ from"fs/promises";import W from"path";var{$:M}=globalThis.Bun;async function o(){try{return(await M`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{return process.cwd()}}var _=null;async function e(){if(_)return _;let Y=await o(),X=W.join(Y,".speck","root");try{if(!(await $.lstat(X)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let U={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:W.join(Y,"specs")};return _=U,U}let Q=await $.realpath(X),J=["/","/etc","/usr","/bin","/sbin","/System","/Library"],V=process.env.HOME||process.env.USERPROFILE||"";if(J.some((U)=>Q===U||Q.startsWith(U+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${Q}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(V&&Q===W.dirname(V))throw Error(`Security: .speck/root symlink points above home directory: ${Q}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await $.access(Q);let Z=W.join(Y,"specs");try{if((await $.stat(Z)).isDirectory()&&Q!==Y)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${Z}
  Shared: ${W.join(Q,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${Z}/* ${W.join(Q,"specs")}/
  2. Remove local specs: rm -rf ${Z}
`)}catch(U){let v=U;if(v.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${v.message}`)}let K={mode:"multi-repo",speckRoot:Q,repoRoot:Y,specsDir:W.join(Q,"specs")};return _=K,K}catch(H){let Q=H;if(Q.code==="ENOENT"){if((await t(Y)).length>0){let K={mode:"multi-repo",speckRoot:Y,repoRoot:Y,specsDir:W.join(Y,"specs")};return _=K,K}let Z={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:W.join(Y,"specs")};return _=Z,Z}if(Q.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let J=await $.readlink(X).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${J} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}async function t(Y){let X=[];try{let H=await $.readdir(Y,{withFileTypes:!0});for(let Q of H)if(Q.isSymbolicLink()&&Q.name.startsWith(".speck-link-")){let J=W.join(Y,Q.name);try{let V=await $.realpath(J);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((U)=>V===U||V.startsWith(U+"/"))){console.warn(`Security: Skipping ${Q.name} - points to system directory: ${V}`);continue}let K=W.join(V,".git");try{await $.access(K),X.push(V)}catch{console.warn(`Warning: ${Q.name} points to non-git directory: ${V}`)}}catch(V){let Z=V instanceof Error?V.message:String(V);console.warn(`Warning: Broken symlink ${Q.name}: ${Z}`)}}}catch(H){if(H.code!=="ENOENT")throw H}return X}async function YY(Y){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await M`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let X=W.join(Y,"specs");if(z(X)){let H="",Q=0,J=D(X,{withFileTypes:!0});for(let V of J)if(V.isDirectory()){let Z=V.name.match(/^(\d{3})-/);if(Z&&Z[1]){let K=parseInt(Z[1],10);if(K>Q)Q=K,H=V.name}}if(H)return H}return"main"}}async function HY(){try{let Y=process.cwd(),X=W.join(Y,".git");if(z(X))return!0;return await M`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function k(Y,X,H){if(!X)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let Q=W.join(H,".speck","branches.json");if(z(Q))try{let J=await $.readFile(Q,"utf-8"),V=JSON.parse(J);if(V.branches&&Array.isArray(V.branches)){if(V.branches.some((K)=>K.name===Y))return!0}}catch{}if(!/^\d{3}-/.test(Y))return console.error(`ERROR: Not on a feature branch. Current branch: ${Y}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}async function QY(Y,X,H){let Q=W.join(H,".speck","branches.json");if(z(Q))try{let K=await $.readFile(Q,"utf-8"),U=JSON.parse(K);if(U.branches&&Array.isArray(U.branches)){let v=U.branches.find((w)=>w.name===X);if(v&&v.specId)return W.join(Y,v.specId)}}catch{}let J=X.match(/^(\d{3})-/);if(!J)return W.join(Y,X);let V=J[1],Z=[];if(z(Y)){let K=D(Y,{withFileTypes:!0});for(let U of K)if(U.isDirectory()&&U.name.startsWith(`${V}-`))Z.push(U.name)}if(Z.length===0)return W.join(Y,X);else if(Z.length===1&&Z[0])return W.join(Y,Z[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${V}': ${Z.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),W.join(Y,X)}async function S(){let Y=await e(),X=await YY(Y.repoRoot),H=await HY(),Q=await QY(Y.specsDir,X,Y.repoRoot),J=W.basename(Q),V=W.join(Y.repoRoot,"specs",J);return{MODE:Y.mode,SPECK_ROOT:Y.speckRoot,SPECS_DIR:Y.specsDir,REPO_ROOT:Y.repoRoot,CURRENT_BRANCH:X,HAS_GIT:H?"true":"false",FEATURE_DIR:Q,FEATURE_SPEC:W.join(Q,"spec.md"),CHECKLISTS_DIR:W.join(Q,"checklists"),LINKED_REPOS:W.join(Q,"linked-repos.md"),IMPL_PLAN:W.join(V,"plan.md"),TASKS:W.join(V,"tasks.md"),RESEARCH:W.join(V,"research.md"),DATA_MODEL:W.join(V,"data-model.md"),QUICKSTART:W.join(V,"quickstart.md"),CONTRACTS_DIR:W.join(V,"contracts")}}function F(Y,X=[]){if(!B(Y))return X;try{let H=R(Y);for(let Q of H){let J=T(Y,Q);try{let V=VY(J);if(V.isDirectory())F(J,X);else if(V.isFile())X.push(J)}catch{continue}}}catch{}return X}function JY(Y){return{json:Y.includes("--json"),requireTasks:Y.includes("--require-tasks"),includeTasks:Y.includes("--include-tasks"),pathsOnly:Y.includes("--paths-only"),skipFeatureCheck:Y.includes("--skip-feature-check"),skipPlanCheck:Y.includes("--skip-plan-check"),help:Y.includes("--help")||Y.includes("-h"),includeFileContents:Y.includes("--include-file-contents"),includeWorkflowMode:Y.includes("--include-workflow-mode"),validateCodeQuality:Y.includes("--validate-code-quality")}}function ZY(){console.log(`Usage: check-prerequisites.ts [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json                   Output in JSON format
  --require-tasks          Require tasks.md to exist (for implementation phase)
  --include-tasks          Include tasks.md in AVAILABLE_DOCS list
  --paths-only             Only output path variables (no prerequisite validation)
  --skip-feature-check     Skip feature directory and plan.md validation (for /speck.specify)
  --skip-plan-check        Skip plan.md validation but check feature directory (for /speck.plan)
  --validate-code-quality  Validate TypeScript typecheck and ESLint (Constitution Principle IX)
  --include-file-contents  Include file contents in JSON output
  --include-workflow-mode  Include workflow mode in JSON output
  --help, -h               Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  bun .speck/scripts/check-prerequisites.ts --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  bun .speck/scripts/check-prerequisites.ts --json --require-tasks --include-tasks

  # Validate code quality before feature completion
  bun .speck/scripts/check-prerequisites.ts --validate-code-quality

  # Get feature paths only (no validation)
  bun .speck/scripts/check-prerequisites.ts --paths-only
`)}function UY(Y,X){if(X){let H={MODE:Y.MODE,REPO_ROOT:Y.REPO_ROOT,BRANCH:Y.CURRENT_BRANCH,FEATURE_DIR:Y.FEATURE_DIR,FEATURE_SPEC:Y.FEATURE_SPEC,IMPL_PLAN:Y.IMPL_PLAN,TASKS:Y.TASKS};console.log(JSON.stringify(H))}else console.log(`MODE: ${Y.MODE}`),console.log(`REPO_ROOT: ${Y.REPO_ROOT}`),console.log(`BRANCH: ${Y.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${Y.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${Y.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${Y.IMPL_PLAN}`),console.log(`TASKS: ${Y.TASKS}`)}function KY(Y){let X=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--skip-plan-check","--help","-h","--include-file-contents","--include-workflow-mode","--validate-code-quality"];for(let H of Y)if(H.startsWith("--")||H.startsWith("-")){if(!X.includes(H))console.error(`ERROR: Unknown option '${H}'. Use --help for usage information.`),process.exit(1)}}var P={maxSingleFile:24576,maxTotalFiles:102400};function j(Y,X){if(!B(Y))return"NOT_FOUND";try{let Q=Bun.file(Y).size;if(Q>P.maxSingleFile)return"TOO_LARGE";if(X.value+Q>P.maxTotalFiles)return"TOO_LARGE";let J=E(Y,"utf-8");return X.value+=Q,J}catch(H){return"NOT_FOUND"}}async function WY(Y){let{$:X}=awaitPromise.resolve(globalThis.Bun),H=await X`bun run typecheck`.cwd(Y).nothrow().quiet();if(H.exitCode!==0)return{passed:!1,message:`\u274C TypeScript validation failed (exit code ${H.exitCode})
${H.stderr.toString()}`};let Q=await X`bun run lint`.cwd(Y).nothrow().quiet();if(Q.exitCode!==0){let J=Q.stdout.toString();return{passed:!1,message:`\u274C ESLint validation failed (exit code ${Q.exitCode})
${J}`}}return{passed:!0,message:"\u2705 Code quality validation passed (0 typecheck errors, 0 lint errors/warnings)"}}function GY(Y,X){let H=T(Y,"plan.md");if(B(H))try{let V=E(H,"utf-8").match(/\*\*Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(V&&V[1])return V[1]}catch{}let Q=T(X,".speck","memory","constitution.md");if(B(Q))try{let V=E(Q,"utf-8").match(/\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(V&&V[1])return V[1]}catch{}return"single-branch"}async function m(Y){if(!Y.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: Direct invocation deprecated. Prerequisites are now auto-checked via PrePromptSubmit hook.\x1B[0m
`);KY(Y);let X=JY(Y);if(X.help)return ZY(),0;let H=await S(),Q=H.HAS_GIT==="true";if(!X.skipFeatureCheck){if(!await k(H.CURRENT_BRANCH,Q,H.REPO_ROOT))return 1}if(X.pathsOnly||X.skipFeatureCheck)return UY(H,X.json),0;if(!B(H.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${H.FEATURE_DIR}`),console.error("Run /speck.specify first to create the feature structure."),1;if(!X.skipPlanCheck&&!B(H.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.plan first to create the implementation plan."),1;if(X.requireTasks&&!B(H.TASKS))return console.error(`ERROR: tasks.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.tasks first to create the task list."),1;let J=[],V=F(H.FEATURE_DIR);J.push(...V);let Z=T(H.SPECK_ROOT,".speck","linked-repos.md");if(B(Z))J.push(Z);let K=T(H.SPECK_ROOT,".speck","memory","constitution.md");if(B(K))J.push(K);let U=T(H.REPO_ROOT,".speck","memory","constitution.md");if(U!==K&&B(U))J.push(U);let v=XY(H.FEATURE_DIR),w=T(H.REPO_ROOT,"specs",v);if(w!==H.FEATURE_DIR){let G=F(w);J.push(...G)}let x=J.map((G)=>{if(G.startsWith(H.REPO_ROOT))return C(H.REPO_ROOT,G);if(G.startsWith(H.SPECK_ROOT))return C(H.SPECK_ROOT,G);return G}),y=X.includeTasks?x:x.filter((G)=>!G.endsWith("tasks.md")),A;if(X.includeFileContents){A={};let G={value:0};A["tasks.md"]=j(H.TASKS,G),A["plan.md"]=j(H.IMPL_PLAN,G),A["spec.md"]=j(H.FEATURE_SPEC,G);let h=T(H.REPO_ROOT,".speck","memory","constitution.md");if(A["constitution.md"]=j(h,G),A["data-model.md"]=j(H.DATA_MODEL,G),A["research.md"]=j(H.RESEARCH,G),B(H.CHECKLISTS_DIR))try{let l=R(H.CHECKLISTS_DIR).filter((L)=>L.endsWith(".md"));for(let L of l){let p=T(H.CHECKLISTS_DIR,L);A[`checklists/${L}`]=j(p,G)}}catch{}}let N;if(X.includeWorkflowMode)N=GY(H.FEATURE_DIR,H.REPO_ROOT);if(X.validateCodeQuality){let G=await WY(H.REPO_ROOT);if(!G.passed)return console.error(`
`+G.message),console.error(`
Constitution Principle IX requires zero typecheck errors and zero lint errors/warnings.`),console.error(`Fix all issues before marking the feature complete.
`),1;if(!X.json)console.log(`
`+G.message+`
`)}if(X.json){let G={MODE:H.MODE,FEATURE_DIR:H.FEATURE_DIR,AVAILABLE_DOCS:y,...A&&{FILE_CONTENTS:A},...N&&{WORKFLOW_MODE:N},IMPL_PLAN:H.IMPL_PLAN,TASKS:H.TASKS,REPO_ROOT:H.REPO_ROOT};console.log(JSON.stringify(G))}else{console.log(`FEATURE_DIR:${H.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:");for(let G of y)console.log(`  \u2713 ${G}`)}return 0}var O=null;function f(){if(!O)return null;if(Date.now()-O.timestamp>5000)return O=null,null;return O}function I(Y){O=Y}async function $Y(Y){let{log:X,error:H}=console,Q="",J="";console.log=(...V)=>{Q+=V.join(" ")+`
`},console.error=(...V)=>{J+=V.join(" ")+`
`};try{return{exitCode:await Y(),stdout:Q.trim(),stderr:J.trim()}}catch(V){let Z=V instanceof Error?V:Error(String(V));return J+=`Error: ${Z.message}
`,{exitCode:2,stdout:Q.trim(),stderr:J.trim()}}finally{console.log=X,console.error=H}}async function d(Y={},X=!0){if(X){let H=f();if(H)return{success:H.success,output:H.output,error:H.error,cached:!0}}try{let H=["--json"];if(Y.requireTasks)H.push("--require-tasks");if(Y.includeTasks)H.push("--include-tasks");if(Y.skipFeatureCheck)H.push("--skip-feature-check");if(Y.skipPlanCheck)H.push("--skip-plan-check");if(Y.includeFileContents)H.push("--include-file-contents");if(Y.includeWorkflowMode)H.push("--include-workflow-mode");let{exitCode:Q,stdout:J,stderr:V}=await $Y(()=>m(H));if(Q===0)try{let Z=JSON.parse(J),K={success:!0,output:Z,error:null,cached:!1};return I({success:!0,output:Z,error:null,timestamp:Date.now()}),K}catch(Z){let U=`Failed to parse check-prerequisites output: ${(Z instanceof Error?Z:Error(String(Z))).message}`,v={success:!1,output:null,error:U,cached:!1};return I({success:!1,output:null,error:U,timestamp:Date.now()}),v}else{let Z=V||`check-prerequisites exited with code ${Q}`,K={success:!1,output:null,error:Z,cached:!1};return I({success:!1,output:null,error:Z,timestamp:Date.now()}),K}}catch(H){let J=`Failed to run check-prerequisites: ${(H instanceof Error?H:Error(String(H))).message}`,V={success:!1,output:null,error:J,cached:!1};return I({success:!1,output:null,error:J,timestamp:Date.now()}),V}}function g(Y){if(!Y.success||!Y.output)return"";let{FEATURE_DIR:X,AVAILABLE_DOCS:H,MODE:Q,WORKFLOW_MODE:J,IMPL_PLAN:V,TASKS:Z,REPO_ROOT:K}=Y.output,U={MODE:Q,FEATURE_DIR:X,AVAILABLE_DOCS:H};if(J)U.WORKFLOW_MODE=J;if(V)U.IMPL_PLAN=V;if(Z)U.TASKS=Z;if(K)U.REPO_ROOT=K;return`<!-- SPECK_PREREQ_CONTEXT
${JSON.stringify(U)}
-->`}function u(Y){return`\u26A0\uFE0F **Prerequisite Check Failed**

${Y}

Please ensure you're on a valid feature branch and have run the necessary Speck commands.
`.trim()}import{appendFile as BY}from"fs/promises";var qY="/private/tmp/.claude-hook-test/speck-hook-log.txt",q=async(Y)=>{await BY(qY,`[${new Date().toISOString()}] [PrePromptSubmit] ${Y}
`)};function vY(Y){return/^\/speck[.:]/.test(Y.trim())}function AY(Y){let H=Y.match(/^\/speck[.:](\w+)/)?.[1]??"",Q=["implement"],J=["implement","analyze"],V=["specify","constitution","env","link"],Z=["plan","clarify","constitution","env","link"],K=["implement","analyze","plan","tasks","checklist","clarify"],U=["implement"];return{requireTasks:Q.includes(H),includeTasks:J.includes(H),skipFeatureCheck:V.includes(H),skipPlanCheck:Z.includes(H),includeFileContents:K.includes(H),includeWorkflowMode:U.includes(H)}}async function TY(){try{let Y=await Bun.stdin.text();await q(`Received hook input (length: ${Y.length})`);let X=JSON.parse(Y),{prompt:H}=X;if(await q(`Parsed prompt: ${H.substring(0,100)}${H.length>100?"...":""}`),!vY(H)){await q("Not a /speck.* command, passing through"),console.log(JSON.stringify({}));return}let Q=H.match(/^\/speck[.:]\w+/);await q(`Detected /speck.* command: ${Q?.[0]??"unknown"}`);let J=AY(H);await q(`Check options: ${JSON.stringify(J)}`);let V=await d(J,!0);if(await q(`Prerequisite check result: success=${V.success}`),V.success&&V.output){let Z=g(V);await q(`Formatted context (length: ${Z.length})`),await q(`Context preview: ${Z.substring(0,200)}`);let K={hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:Z}};await q("Returning success with additionalContext"),console.log(JSON.stringify(K))}else{let Z=u(V.error||"Unknown error");await q(`Blocking with error: ${V.error}`),console.log(JSON.stringify({decision:"block",reason:Z,hookSpecificOutput:{hookEventName:"UserPromptSubmit"}}))}}catch(Y){let X=Y instanceof Error?Y.message:String(Y);await q(`Hook error: ${X}`),console.error(`PrePromptSubmit hook error: ${X}`),console.log(JSON.stringify({}))}}TY();
