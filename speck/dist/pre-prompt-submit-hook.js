#!/usr/bin/env bun
// @bun
var m=Object.create;var{getPrototypeOf:f,defineProperty:F,getOwnPropertyNames:u}=Object;var d=Object.prototype.hasOwnProperty;var g=(H,V,Y)=>{Y=H!=null?m(f(H)):{};let X=V||!H||!H.__esModule?F(Y,"default",{value:H,enumerable:!0}):Y;for(let J of u(H))if(!d.call(X,J))F(X,J,{get:()=>H[J],enumerable:!0});return X};var l=import.meta.require;import{existsSync as v,readdirSync as M,readFileSync as E}from"fs";import{join as z}from"path";import{existsSync as A}from"fs";import{readdirSync as O}from"fs";import $ from"fs/promises";import W from"path";var{$:w}=globalThis.Bun;async function h(){try{return(await w`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{return process.cwd()}}var _=null;async function n(){if(_)return _;let H=await h(),V=W.join(H,".speck","root");try{if(!(await $.lstat(V)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let K={mode:"single-repo",speckRoot:H,repoRoot:H,specsDir:W.join(H,"specs")};return _=K,K}let X=await $.realpath(V),J=["/","/etc","/usr","/bin","/sbin","/System","/Library"],Q=process.env.HOME||process.env.USERPROFILE||"";if(J.some((K)=>X===K||X.startsWith(K+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${X}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(Q&&X===W.dirname(Q))throw Error(`Security: .speck/root symlink points above home directory: ${X}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await $.access(X);let Z=W.join(H,"specs");try{if((await $.stat(Z)).isDirectory()&&X!==H)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${Z}
  Shared: ${W.join(X,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${Z}/* ${W.join(X,"specs")}/
  2. Remove local specs: rm -rf ${Z}
`)}catch(K){let G=K;if(G.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${G.message}`)}let U={mode:"multi-repo",speckRoot:X,repoRoot:H,specsDir:W.join(X,"specs")};return _=U,U}catch(Y){let X=Y;if(X.code==="ENOENT"){if((await p(H)).length>0){let U={mode:"multi-repo",speckRoot:H,repoRoot:H,specsDir:W.join(H,"specs")};return _=U,U}let Z={mode:"single-repo",speckRoot:H,repoRoot:H,specsDir:W.join(H,"specs")};return _=Z,Z}if(X.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let J=await $.readlink(V).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${J} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}async function p(H){let V=[];try{let Y=await $.readdir(H,{withFileTypes:!0});for(let X of Y)if(X.isSymbolicLink()&&X.name.startsWith(".speck-link-")){let J=W.join(H,X.name);try{let Q=await $.realpath(J);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((K)=>Q===K||Q.startsWith(K+"/"))){console.warn(`Security: Skipping ${X.name} - points to system directory: ${Q}`);continue}let U=W.join(Q,".git");try{await $.access(U),V.push(Q)}catch{console.warn(`Warning: ${X.name} points to non-git directory: ${Q}`)}}catch(Q){let Z=Q instanceof Error?Q.message:String(Q);console.warn(`Warning: Broken symlink ${X.name}: ${Z}`)}}}catch(Y){if(Y.code!=="ENOENT")throw Y}return V}async function c(H){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await w`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let V=W.join(H,"specs");if(A(V)){let Y="",X=0,J=O(V,{withFileTypes:!0});for(let Q of J)if(Q.isDirectory()){let Z=Q.name.match(/^(\d{3})-/);if(Z&&Z[1]){let U=parseInt(Z[1],10);if(U>X)X=U,Y=Q.name}}if(Y)return Y}return"main"}}async function i(){try{let H=process.cwd(),V=W.join(H,".git");if(A(V))return!0;return await w`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function b(H,V,Y){if(!V)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let X=W.join(Y,".speck","branches.json");if(A(X))try{let J=await $.readFile(X,"utf-8"),Q=JSON.parse(J);if(Q.branches&&Array.isArray(Q.branches)){if(Q.branches.some((U)=>U.name===H))return!0}}catch{}if(!/^\d{3}-/.test(H))return console.error(`ERROR: Not on a feature branch. Current branch: ${H}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}async function s(H,V,Y){let X=W.join(Y,".speck","branches.json");if(A(X))try{let U=await $.readFile(X,"utf-8"),K=JSON.parse(U);if(K.branches&&Array.isArray(K.branches)){let G=K.branches.find((q)=>q.name===V);if(G&&G.specId)return W.join(H,G.specId)}}catch{}let J=V.match(/^(\d{3})-/);if(!J)return W.join(H,V);let Q=J[1],Z=[];if(A(H)){let U=O(H,{withFileTypes:!0});for(let K of U)if(K.isDirectory()&&K.name.startsWith(`${Q}-`))Z.push(K.name)}if(Z.length===0)return W.join(H,V);else if(Z.length===1&&Z[0])return W.join(H,Z[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${Q}': ${Z.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),W.join(H,V)}async function x(){let H=await n(),V=await c(H.repoRoot),Y=await i(),X=await s(H.specsDir,V,H.repoRoot),J=W.basename(X),Q=W.join(H.repoRoot,"specs",J);return{MODE:H.mode,SPECK_ROOT:H.speckRoot,SPECS_DIR:H.specsDir,REPO_ROOT:H.repoRoot,CURRENT_BRANCH:V,HAS_GIT:Y?"true":"false",FEATURE_DIR:X,FEATURE_SPEC:W.join(X,"spec.md"),CHECKLISTS_DIR:W.join(X,"checklists"),LINKED_REPOS:W.join(X,"linked-repos.md"),IMPL_PLAN:W.join(Q,"plan.md"),TASKS:W.join(Q,"tasks.md"),RESEARCH:W.join(Q,"research.md"),DATA_MODEL:W.join(Q,"data-model.md"),QUICKSTART:W.join(Q,"quickstart.md"),CONTRACTS_DIR:W.join(Q,"contracts")}}function j(H,V){return A(H)?`  \u2713 ${V}`:`  \u2717 ${V}`}function N(H,V){if(!A(H))return`  \u2717 ${V}`;try{return O(H).length>0?`  \u2713 ${V}`:`  \u2717 ${V}`}catch{return`  \u2717 ${V}`}}function r(H){return{json:H.includes("--json"),requireTasks:H.includes("--require-tasks"),includeTasks:H.includes("--include-tasks"),pathsOnly:H.includes("--paths-only"),skipFeatureCheck:H.includes("--skip-feature-check"),skipPlanCheck:H.includes("--skip-plan-check"),help:H.includes("--help")||H.includes("-h"),includeFileContents:H.includes("--include-file-contents"),includeWorkflowMode:H.includes("--include-workflow-mode"),validateCodeQuality:H.includes("--validate-code-quality")}}function a(){console.log(`Usage: check-prerequisites.ts [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json                   Output in JSON format
  --require-tasks          Require tasks.md to exist (for implementation phase)
  --include-tasks          Include tasks.md in AVAILABLE_DOCS list
  --paths-only             Only output path variables (no prerequisite validation)
  --skip-feature-check     Skip feature directory and plan.md validation (for /speck.specify)
  --skip-plan-check        Skip plan.md validation but check feature directory (for /speck.plan)
  --validate-code-quality  Validate TypeScript typecheck and ESLint (Constitution Principle IX)
  --include-file-contents  Include file contents in JSON output
  --include-workflow-mode  Include workflow mode in JSON output
  --help, -h               Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  bun .speck/scripts/check-prerequisites.ts --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  bun .speck/scripts/check-prerequisites.ts --json --require-tasks --include-tasks

  # Validate code quality before feature completion
  bun .speck/scripts/check-prerequisites.ts --validate-code-quality

  # Get feature paths only (no validation)
  bun .speck/scripts/check-prerequisites.ts --paths-only
`)}function o(H,V){if(V){let Y={MODE:H.MODE,REPO_ROOT:H.REPO_ROOT,BRANCH:H.CURRENT_BRANCH,FEATURE_DIR:H.FEATURE_DIR,FEATURE_SPEC:H.FEATURE_SPEC,IMPL_PLAN:H.IMPL_PLAN,TASKS:H.TASKS};console.log(JSON.stringify(Y))}else console.log(`MODE: ${H.MODE}`),console.log(`REPO_ROOT: ${H.REPO_ROOT}`),console.log(`BRANCH: ${H.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${H.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${H.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${H.IMPL_PLAN}`),console.log(`TASKS: ${H.TASKS}`)}function e(H){let V=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--skip-plan-check","--help","-h","--include-file-contents","--include-workflow-mode","--validate-code-quality"];for(let Y of H)if(Y.startsWith("--")||Y.startsWith("-")){if(!V.includes(Y))console.error(`ERROR: Unknown option '${Y}'. Use --help for usage information.`),process.exit(1)}}var P={maxSingleFile:24576,maxTotalFiles:102400};function T(H,V){if(!v(H))return"NOT_FOUND";try{let X=Bun.file(H).size;if(X>P.maxSingleFile)return"TOO_LARGE";if(V.value+X>P.maxTotalFiles)return"TOO_LARGE";let J=E(H,"utf-8");return V.value+=X,J}catch(Y){return"NOT_FOUND"}}async function t(H){let{$:V}=awaitPromise.resolve(globalThis.Bun),Y=await V`bun run typecheck`.cwd(H).nothrow().quiet();if(Y.exitCode!==0)return{passed:!1,message:`\u274C TypeScript validation failed (exit code ${Y.exitCode})
${Y.stderr.toString()}`};let X=await V`bun run lint`.cwd(H).nothrow().quiet();if(X.exitCode!==0){let J=X.stdout.toString();return{passed:!1,message:`\u274C ESLint validation failed (exit code ${X.exitCode})
${J}`}}return{passed:!0,message:"\u2705 Code quality validation passed (0 typecheck errors, 0 lint errors/warnings)"}}function YY(H,V){let Y=z(H,"plan.md");if(v(Y))try{let Q=E(Y,"utf-8").match(/\*\*Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(Q&&Q[1])return Q[1]}catch{}let X=z(V,".speck","memory","constitution.md");if(v(X))try{let Q=E(X,"utf-8").match(/\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(Q&&Q[1])return Q[1]}catch{}return"single-branch"}async function D(H){if(!H.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: Direct invocation deprecated. Prerequisites are now auto-checked via PrePromptSubmit hook.\x1B[0m
`);e(H);let V=r(H);if(V.help)return a(),0;let Y=await x(),X=Y.HAS_GIT==="true";if(!V.skipFeatureCheck){if(!await b(Y.CURRENT_BRANCH,X,Y.REPO_ROOT))return 1}if(V.pathsOnly||V.skipFeatureCheck)return o(Y,V.json),0;if(!v(Y.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${Y.FEATURE_DIR}`),console.error("Run /speck.specify first to create the feature structure."),1;if(!V.skipPlanCheck&&!v(Y.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${Y.FEATURE_DIR}`),console.error("Run /speck.plan first to create the implementation plan."),1;if(V.requireTasks&&!v(Y.TASKS))return console.error(`ERROR: tasks.md not found in ${Y.FEATURE_DIR}`),console.error("Run /speck.tasks first to create the task list."),1;let J=[];if(v(Y.FEATURE_SPEC))J.push(Y.FEATURE_SPEC);if(v(Y.LINKED_REPOS))J.push(Y.LINKED_REPOS);if(v(Y.CHECKLISTS_DIR))try{let K=M(Y.CHECKLISTS_DIR).filter((G)=>G.endsWith(".md"));for(let G of K)J.push(z(Y.CHECKLISTS_DIR,G))}catch{}if(v(Y.IMPL_PLAN))J.push(Y.IMPL_PLAN);if(v(Y.RESEARCH))J.push(Y.RESEARCH);if(v(Y.DATA_MODEL))J.push(Y.DATA_MODEL);if(v(Y.QUICKSTART))J.push(Y.QUICKSTART);if(v(Y.CONTRACTS_DIR))try{if(M(Y.CONTRACTS_DIR).length>0)J.push(Y.CONTRACTS_DIR)}catch{}if(V.includeTasks&&v(Y.TASKS))J.push(Y.TASKS);let Q;if(V.includeFileContents){Q={};let U={value:0};Q["tasks.md"]=T(Y.TASKS,U),Q["plan.md"]=T(Y.IMPL_PLAN,U),Q["spec.md"]=T(Y.FEATURE_SPEC,U);let K=z(Y.REPO_ROOT,".speck","memory","constitution.md");if(Q["constitution.md"]=T(K,U),Q["data-model.md"]=T(Y.DATA_MODEL,U),Q["research.md"]=T(Y.RESEARCH,U),v(Y.CHECKLISTS_DIR))try{let G=M(Y.CHECKLISTS_DIR).filter((q)=>q.endsWith(".md"));for(let q of G){let R=z(Y.CHECKLISTS_DIR,q);Q[`checklists/${q}`]=T(R,U)}}catch{}}let Z;if(V.includeWorkflowMode)Z=YY(Y.FEATURE_DIR,Y.REPO_ROOT);if(V.validateCodeQuality){let U=await t(Y.REPO_ROOT);if(!U.passed)return console.error(`
`+U.message),console.error(`
Constitution Principle IX requires zero typecheck errors and zero lint errors/warnings.`),console.error(`Fix all issues before marking the feature complete.
`),1;if(!V.json)console.log(`
`+U.message+`
`)}if(V.json){let U={MODE:Y.MODE,FEATURE_DIR:Y.FEATURE_DIR,AVAILABLE_DOCS:J,...Q&&{FILE_CONTENTS:Q},...Z&&{WORKFLOW_MODE:Z},IMPL_PLAN:Y.IMPL_PLAN,TASKS:Y.TASKS,REPO_ROOT:Y.REPO_ROOT};console.log(JSON.stringify(U))}else if(console.log(`FEATURE_DIR:${Y.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:"),console.log(j(Y.FEATURE_SPEC,Y.FEATURE_SPEC)),console.log(j(Y.LINKED_REPOS,Y.LINKED_REPOS)),console.log(N(Y.CHECKLISTS_DIR,Y.CHECKLISTS_DIR)),console.log(j(Y.IMPL_PLAN,Y.IMPL_PLAN)),console.log(j(Y.RESEARCH,Y.RESEARCH)),console.log(j(Y.DATA_MODEL,Y.DATA_MODEL)),console.log(j(Y.QUICKSTART,Y.QUICKSTART)),console.log(N(Y.CONTRACTS_DIR,Y.CONTRACTS_DIR)),V.includeTasks)console.log(j(Y.TASKS,Y.TASKS));return 0}var L=null;function y(){if(!L)return null;if(Date.now()-L.timestamp>5000)return L=null,null;return L}function I(H){L=H}async function HY(H){let{log:V,error:Y}=console,X="",J="";console.log=(...Q)=>{X+=Q.join(" ")+`
`},console.error=(...Q)=>{J+=Q.join(" ")+`
`};try{return{exitCode:await H(),stdout:X.trim(),stderr:J.trim()}}catch(Q){let Z=Q instanceof Error?Q:Error(String(Q));return J+=`Error: ${Z.message}
`,{exitCode:2,stdout:X.trim(),stderr:J.trim()}}finally{console.log=V,console.error=Y}}async function C(H={},V=!0){if(V){let Y=y();if(Y)return{success:Y.success,output:Y.output,error:Y.error,cached:!0}}try{let Y=["--json"];if(H.requireTasks)Y.push("--require-tasks");if(H.includeTasks)Y.push("--include-tasks");if(H.skipFeatureCheck)Y.push("--skip-feature-check");if(H.skipPlanCheck)Y.push("--skip-plan-check");if(H.includeFileContents)Y.push("--include-file-contents");if(H.includeWorkflowMode)Y.push("--include-workflow-mode");let{exitCode:X,stdout:J,stderr:Q}=await HY(()=>D(Y));if(X===0)try{let Z=JSON.parse(J),U={success:!0,output:Z,error:null,cached:!1};return I({success:!0,output:Z,error:null,timestamp:Date.now()}),U}catch(Z){let K=`Failed to parse check-prerequisites output: ${(Z instanceof Error?Z:Error(String(Z))).message}`,G={success:!1,output:null,error:K,cached:!1};return I({success:!1,output:null,error:K,timestamp:Date.now()}),G}else{let Z=Q||`check-prerequisites exited with code ${X}`,U={success:!1,output:null,error:Z,cached:!1};return I({success:!1,output:null,error:Z,timestamp:Date.now()}),U}}catch(Y){let J=`Failed to run check-prerequisites: ${(Y instanceof Error?Y:Error(String(Y))).message}`,Q={success:!1,output:null,error:J,cached:!1};return I({success:!1,output:null,error:J,timestamp:Date.now()}),Q}}function S(H){if(!H.success||!H.output)return"";let{FEATURE_DIR:V,AVAILABLE_DOCS:Y,MODE:X,WORKFLOW_MODE:J,IMPL_PLAN:Q,TASKS:Z,REPO_ROOT:U}=H.output,K={MODE:X,FEATURE_DIR:V,AVAILABLE_DOCS:Y};if(J)K.WORKFLOW_MODE=J;if(Q)K.IMPL_PLAN=Q;if(Z)K.TASKS=Z;if(U)K.REPO_ROOT=U;return`<!-- SPECK_PREREQ_CONTEXT
${JSON.stringify(K)}
-->`}function k(H){return`\u26A0\uFE0F **Prerequisite Check Failed**

${H}

Please ensure you're on a valid feature branch and have run the necessary Speck commands.
`.trim()}import{appendFile as QY}from"fs/promises";var VY="/private/tmp/.claude-hook-test/speck-hook-log.txt",B=async(H)=>{await QY(VY,`[${new Date().toISOString()}] [PrePromptSubmit] ${H}
`)};function XY(H){return/^\/speck[.:]/.test(H.trim())}function JY(H){let Y=H.match(/^\/speck[.:](\w+)/)?.[1]??"",X=["implement"],J=["implement","analyze"],Q=["specify","constitution","env","link"],Z=["plan","clarify","constitution","env","link"],U=["implement","analyze","plan","tasks","checklist","clarify"],K=["implement"];return{requireTasks:X.includes(Y),includeTasks:J.includes(Y),skipFeatureCheck:Q.includes(Y),skipPlanCheck:Z.includes(Y),includeFileContents:U.includes(Y),includeWorkflowMode:K.includes(Y)}}async function ZY(){try{let H=await Bun.stdin.text();await B(`Received hook input (length: ${H.length})`);let V=JSON.parse(H),{prompt:Y}=V;if(await B(`Parsed prompt: ${Y.substring(0,100)}${Y.length>100?"...":""}`),!XY(Y)){await B("Not a /speck.* command, passing through"),console.log(JSON.stringify({}));return}let X=Y.match(/^\/speck[.:]\w+/);await B(`Detected /speck.* command: ${X?.[0]??"unknown"}`);let J=JY(Y);await B(`Check options: ${JSON.stringify(J)}`);let Q=await C(J,!0);if(await B(`Prerequisite check result: success=${Q.success}`),Q.success&&Q.output){let Z=S(Q);await B(`Formatted context (length: ${Z.length})`),await B(`Context preview: ${Z.substring(0,200)}`);let U={hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:Z}};await B("Returning success with additionalContext"),console.log(JSON.stringify(U))}else{let Z=k(Q.error||"Unknown error");await B(`Blocking with error: ${Q.error}`),console.log(JSON.stringify({decision:"block",reason:Z,hookSpecificOutput:{hookEventName:"UserPromptSubmit"}}))}}catch(H){let V=H instanceof Error?H.message:String(H);await B(`Hook error: ${V}`),console.error(`PrePromptSubmit hook error: ${V}`),console.log(JSON.stringify({}))}}ZY();
