#!/usr/bin/env bun
// @bun
var p=Object.create;var{getPrototypeOf:c,defineProperty:y,getOwnPropertyNames:n}=Object;var i=Object.prototype.hasOwnProperty;var s=(Y,V,H)=>{H=Y!=null?p(c(Y)):{};let X=V||!Y||!Y.__esModule?y(H,"default",{value:Y,enumerable:!0}):H;for(let J of n(Y))if(!i.call(X,J))y(X,J,{get:()=>Y[J],enumerable:!0});return X};var r=import.meta.require;import{existsSync as $,readdirSync as P,readFileSync as E,statSync as QY}from"fs";import{join as A,basename as VY,relative as XY}from"path";import{existsSync as z}from"fs";import{readdirSync as D}from"fs";import q from"fs/promises";import K from"path";var{$:M}=globalThis.Bun;async function a(){try{return(await M`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{return process.cwd()}}var _=null;async function o(){if(_)return _;let Y=await a(),V=K.join(Y,".speck","root");try{if(!(await q.lstat(V)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let U={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:K.join(Y,"specs")};return _=U,U}let X=await q.realpath(V),J=["/","/etc","/usr","/bin","/sbin","/System","/Library"],Q=process.env.HOME||process.env.USERPROFILE||"";if(J.some((U)=>X===U||X.startsWith(U+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${X}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(Q&&X===K.dirname(Q))throw Error(`Security: .speck/root symlink points above home directory: ${X}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await q.access(X);let Z={mode:"multi-repo",speckRoot:X,repoRoot:Y,specsDir:K.join(X,"specs")};return _=Z,Z}catch(H){let X=H;if(X.code==="ENOENT"){if((await e(Y)).length>0){let U={mode:"multi-repo",speckRoot:Y,repoRoot:Y,specsDir:K.join(Y,"specs")};return _=U,U}let Z={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:K.join(Y,"specs")};return _=Z,Z}if(X.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let J=await q.readlink(V).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${J} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}async function e(Y){let V=[];try{let H=await q.readdir(Y,{withFileTypes:!0});for(let X of H)if(X.isSymbolicLink()&&X.name.startsWith(".speck-link-")){let J=K.join(Y,X.name);try{let Q=await q.realpath(J);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((W)=>Q===W||Q.startsWith(W+"/"))){console.warn(`Security: Skipping ${X.name} - points to system directory: ${Q}`);continue}let U=K.join(Q,".git");try{await q.access(U),V.push(Q)}catch{console.warn(`Warning: ${X.name} points to non-git directory: ${Q}`)}}catch(Q){let Z=Q instanceof Error?Q.message:String(Q);console.warn(`Warning: Broken symlink ${X.name}: ${Z}`)}}}catch(H){if(H.code!=="ENOENT")throw H}return V}async function t(Y){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await M`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let V=K.join(Y,"specs");if(z(V)){let H="",X=0,J=D(V,{withFileTypes:!0});for(let Q of J)if(Q.isDirectory()){let Z=Q.name.match(/^(\d{3})-/);if(Z&&Z[1]){let U=parseInt(Z[1],10);if(U>X)X=U,H=Q.name}}if(H)return H}return"main"}}async function YY(){try{let Y=process.cwd(),V=K.join(Y,".git");if(z(V))return!0;return await M`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function S(Y,V,H){if(!V)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let X=K.join(H,".speck","branches.json");if(z(X))try{let J=await q.readFile(X,"utf-8"),Q=JSON.parse(J);if(Q.branches&&Array.isArray(Q.branches)){if(Q.branches.some((U)=>U.name===Y))return!0}}catch{}if(!/^\d{3}-/.test(Y))return console.error(`ERROR: Not on a feature branch. Current branch: ${Y}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}async function HY(Y,V,H){let X=K.join(H,".speck","branches.json");if(z(X))try{let U=await q.readFile(X,"utf-8"),W=JSON.parse(U);if(W.branches&&Array.isArray(W.branches)){let T=W.branches.find((w)=>w.name===V);if(T&&T.specId)return K.join(Y,T.specId)}}catch{}let J=V.match(/^(\d{3})-/);if(!J)return K.join(Y,V);let Q=J[1],Z=[];if(z(Y)){let U=D(Y,{withFileTypes:!0});for(let W of U)if(W.isDirectory()&&W.name.startsWith(`${Q}-`))Z.push(W.name)}if(Z.length===0)return K.join(Y,V);else if(Z.length===1&&Z[0])return K.join(Y,Z[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${Q}': ${Z.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),K.join(Y,V)}async function k(){let Y=await o(),V=await t(Y.repoRoot),H=await YY(),X=await HY(Y.specsDir,V,Y.repoRoot),J=K.basename(X),Q=K.join(Y.repoRoot,"specs",J);return{MODE:Y.mode,SPECK_ROOT:Y.speckRoot,SPECS_DIR:Y.specsDir,REPO_ROOT:Y.repoRoot,CURRENT_BRANCH:V,HAS_GIT:H?"true":"false",FEATURE_DIR:X,FEATURE_SPEC:K.join(X,"spec.md"),CHECKLISTS_DIR:K.join(X,"checklists"),LINKED_REPOS:K.join(X,"linked-repos.md"),IMPL_PLAN:K.join(Q,"plan.md"),TASKS:K.join(Q,"tasks.md"),RESEARCH:K.join(Q,"research.md"),DATA_MODEL:K.join(Q,"data-model.md"),QUICKSTART:K.join(Q,"quickstart.md"),CONTRACTS_DIR:K.join(Q,"contracts")}}function F(Y,V=[]){if(!$(Y))return V;try{let H=P(Y);for(let X of H){let J=A(Y,X);try{let Q=QY(J);if(Q.isDirectory())F(J,V);else if(Q.isFile())V.push(J)}catch{continue}}}catch{}return V}function JY(Y){return{json:Y.includes("--json"),requireTasks:Y.includes("--require-tasks"),includeTasks:Y.includes("--include-tasks"),pathsOnly:Y.includes("--paths-only"),skipFeatureCheck:Y.includes("--skip-feature-check"),skipPlanCheck:Y.includes("--skip-plan-check"),help:Y.includes("--help")||Y.includes("-h"),includeFileContents:Y.includes("--include-file-contents"),includeWorkflowMode:Y.includes("--include-workflow-mode"),validateCodeQuality:Y.includes("--validate-code-quality")}}function ZY(){console.log(`Usage: check-prerequisites.ts [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json                   Output in JSON format
  --require-tasks          Require tasks.md to exist (for implementation phase)
  --include-tasks          Include tasks.md in AVAILABLE_DOCS list
  --paths-only             Only output path variables (no prerequisite validation)
  --skip-feature-check     Skip feature directory and plan.md validation (for /speck.specify)
  --skip-plan-check        Skip plan.md validation but check feature directory (for /speck.plan)
  --validate-code-quality  Validate TypeScript typecheck and ESLint (Constitution Principle IX)
  --include-file-contents  Include file contents in JSON output
  --include-workflow-mode  Include workflow mode in JSON output
  --help, -h               Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  bun .speck/scripts/check-prerequisites.ts --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  bun .speck/scripts/check-prerequisites.ts --json --require-tasks --include-tasks

  # Validate code quality before feature completion
  bun .speck/scripts/check-prerequisites.ts --validate-code-quality

  # Get feature paths only (no validation)
  bun .speck/scripts/check-prerequisites.ts --paths-only
`)}function UY(Y,V){if(V){let H={MODE:Y.MODE,REPO_ROOT:Y.REPO_ROOT,BRANCH:Y.CURRENT_BRANCH,FEATURE_DIR:Y.FEATURE_DIR,FEATURE_SPEC:Y.FEATURE_SPEC,IMPL_PLAN:Y.IMPL_PLAN,TASKS:Y.TASKS};console.log(JSON.stringify(H))}else console.log(`MODE: ${Y.MODE}`),console.log(`REPO_ROOT: ${Y.REPO_ROOT}`),console.log(`BRANCH: ${Y.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${Y.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${Y.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${Y.IMPL_PLAN}`),console.log(`TASKS: ${Y.TASKS}`)}function KY(Y){let V=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--skip-plan-check","--help","-h","--include-file-contents","--include-workflow-mode","--validate-code-quality"];for(let H of Y)if(H.startsWith("--")||H.startsWith("-")){if(!V.includes(H))console.error(`ERROR: Unknown option '${H}'. Use --help for usage information.`),process.exit(1)}}var C={maxSingleFile:24576,maxTotalFiles:102400};function j(Y,V){if(!$(Y))return"NOT_FOUND";try{let X=Bun.file(Y).size;if(X>C.maxSingleFile)return"TOO_LARGE";if(V.value+X>C.maxTotalFiles)return"TOO_LARGE";let J=E(Y,"utf-8");return V.value+=X,J}catch(H){return"NOT_FOUND"}}async function WY(Y){let{$:V}=awaitPromise.resolve(globalThis.Bun),H=await V`bun run typecheck`.cwd(Y).nothrow().quiet();if(H.exitCode!==0)return{passed:!1,message:`\u274C TypeScript validation failed (exit code ${H.exitCode})
${H.stderr.toString()}`};let X=await V`bun run lint`.cwd(Y).nothrow().quiet();if(X.exitCode!==0){let J=X.stdout.toString();return{passed:!1,message:`\u274C ESLint validation failed (exit code ${X.exitCode})
${J}`}}return{passed:!0,message:"\u2705 Code quality validation passed (0 typecheck errors, 0 lint errors/warnings)"}}function GY(Y,V){let H=A(Y,"plan.md");if($(H))try{let Q=E(H,"utf-8").match(/\*\*Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(Q&&Q[1])return Q[1]}catch{}let X=A(V,".speck","memory","constitution.md");if($(X))try{let Q=E(X,"utf-8").match(/\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(Q&&Q[1])return Q[1]}catch{}return"single-branch"}async function R(Y){if(!Y.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: Direct invocation deprecated. Prerequisites are now auto-checked via PrePromptSubmit hook.\x1B[0m
`);KY(Y);let V=JY(Y);if(V.help)return ZY(),0;let H=await k(),X=H.HAS_GIT==="true";if(!V.skipFeatureCheck){if(!await S(H.CURRENT_BRANCH,X,H.REPO_ROOT))return 1}if(V.pathsOnly||V.skipFeatureCheck)return UY(H,V.json),0;if(!$(H.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${H.FEATURE_DIR}`),console.error("Run /speck.specify first to create the feature structure."),1;if(!V.skipPlanCheck&&!$(H.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.plan first to create the implementation plan."),1;if(V.requireTasks&&!$(H.TASKS))return console.error(`ERROR: tasks.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.tasks first to create the task list."),1;let J=[],Q=F(H.FEATURE_DIR);J.push(...Q);let Z=A(H.SPECK_ROOT,".speck","linked-repos.md");if($(Z))J.push(Z);let U=A(H.SPECK_ROOT,".speck","memory","constitution.md");if($(U))J.push(U);let W=A(H.REPO_ROOT,".speck","memory","constitution.md");if(W!==U&&$(W))J.push(W);let T=VY(H.FEATURE_DIR),w=A(H.REPO_ROOT,"specs",T);if(w!==H.FEATURE_DIR){let G=F(w);J.push(...G)}let x=J.map((G)=>{return XY(H.REPO_ROOT,G)}),b=V.includeTasks?x:x.filter((G)=>!G.endsWith("tasks.md")),v;if(V.includeFileContents){v={};let G={value:0};v["tasks.md"]=j(H.TASKS,G),v["plan.md"]=j(H.IMPL_PLAN,G),v["spec.md"]=j(H.FEATURE_SPEC,G);let u=A(H.REPO_ROOT,".speck","memory","constitution.md");if(v["constitution.md"]=j(u,G),v["data-model.md"]=j(H.DATA_MODEL,G),v["research.md"]=j(H.RESEARCH,G),$(H.CHECKLISTS_DIR))try{let h=P(H.CHECKLISTS_DIR).filter((L)=>L.endsWith(".md"));for(let L of h){let l=A(H.CHECKLISTS_DIR,L);v[`checklists/${L}`]=j(l,G)}}catch{}}let N;if(V.includeWorkflowMode)N=GY(H.FEATURE_DIR,H.REPO_ROOT);if(V.validateCodeQuality){let G=await WY(H.REPO_ROOT);if(!G.passed)return console.error(`
`+G.message),console.error(`
Constitution Principle IX requires zero typecheck errors and zero lint errors/warnings.`),console.error(`Fix all issues before marking the feature complete.
`),1;if(!V.json)console.log(`
`+G.message+`
`)}if(V.json){let G={MODE:H.MODE,FEATURE_DIR:H.FEATURE_DIR,AVAILABLE_DOCS:b,...v&&{FILE_CONTENTS:v},...N&&{WORKFLOW_MODE:N},IMPL_PLAN:H.IMPL_PLAN,TASKS:H.TASKS,REPO_ROOT:H.REPO_ROOT};console.log(JSON.stringify(G))}else{console.log(`FEATURE_DIR:${H.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:");for(let G of b)console.log(`  \u2713 ${G}`)}return 0}var O=null;function m(){if(!O)return null;if(Date.now()-O.timestamp>5000)return O=null,null;return O}function I(Y){O=Y}async function $Y(Y){let{log:V,error:H}=console,X="",J="";console.log=(...Q)=>{X+=Q.join(" ")+`
`},console.error=(...Q)=>{J+=Q.join(" ")+`
`};try{return{exitCode:await Y(),stdout:X.trim(),stderr:J.trim()}}catch(Q){let Z=Q instanceof Error?Q:Error(String(Q));return J+=`Error: ${Z.message}
`,{exitCode:2,stdout:X.trim(),stderr:J.trim()}}finally{console.log=V,console.error=H}}async function f(Y={},V=!0){if(V){let H=m();if(H)return{success:H.success,output:H.output,error:H.error,cached:!0}}try{let H=["--json"];if(Y.requireTasks)H.push("--require-tasks");if(Y.includeTasks)H.push("--include-tasks");if(Y.skipFeatureCheck)H.push("--skip-feature-check");if(Y.skipPlanCheck)H.push("--skip-plan-check");if(Y.includeFileContents)H.push("--include-file-contents");if(Y.includeWorkflowMode)H.push("--include-workflow-mode");let{exitCode:X,stdout:J,stderr:Q}=await $Y(()=>R(H));if(X===0)try{let Z=JSON.parse(J),U={success:!0,output:Z,error:null,cached:!1};return I({success:!0,output:Z,error:null,timestamp:Date.now()}),U}catch(Z){let W=`Failed to parse check-prerequisites output: ${(Z instanceof Error?Z:Error(String(Z))).message}`,T={success:!1,output:null,error:W,cached:!1};return I({success:!1,output:null,error:W,timestamp:Date.now()}),T}else{let Z=Q||`check-prerequisites exited with code ${X}`,U={success:!1,output:null,error:Z,cached:!1};return I({success:!1,output:null,error:Z,timestamp:Date.now()}),U}}catch(H){let J=`Failed to run check-prerequisites: ${(H instanceof Error?H:Error(String(H))).message}`,Q={success:!1,output:null,error:J,cached:!1};return I({success:!1,output:null,error:J,timestamp:Date.now()}),Q}}function d(Y){if(!Y.success||!Y.output)return"";let{FEATURE_DIR:V,AVAILABLE_DOCS:H,MODE:X,WORKFLOW_MODE:J,IMPL_PLAN:Q,TASKS:Z,REPO_ROOT:U}=Y.output,W={MODE:X,FEATURE_DIR:V,AVAILABLE_DOCS:H};if(J)W.WORKFLOW_MODE=J;if(Q)W.IMPL_PLAN=Q;if(Z)W.TASKS=Z;if(U)W.REPO_ROOT=U;return`<!-- SPECK_PREREQ_CONTEXT
${JSON.stringify(W)}
-->`}function g(Y){return`\u26A0\uFE0F **Prerequisite Check Failed**

${Y}

Please ensure you're on a valid feature branch and have run the necessary Speck commands.
`.trim()}import{appendFile as BY}from"fs/promises";var vY="/private/tmp/.claude-hook-test/speck-hook-log.txt",B=async(Y)=>{await BY(vY,`[${new Date().toISOString()}] [PrePromptSubmit] ${Y}
`)};function qY(Y){return/^\/speck[.:]/.test(Y.trim())}function AY(Y){let H=Y.match(/^\/speck[.:](\w+)/)?.[1]??"",X=["implement"],J=["implement","analyze"],Q=["specify","constitution","env","link"],Z=["plan","clarify","constitution","env","link"],U=["implement","analyze","plan","tasks","checklist","clarify"],W=["implement"];return{requireTasks:X.includes(H),includeTasks:J.includes(H),skipFeatureCheck:Q.includes(H),skipPlanCheck:Z.includes(H),includeFileContents:U.includes(H),includeWorkflowMode:W.includes(H)}}async function TY(){try{let Y=await Bun.stdin.text();await B(`Received hook input (length: ${Y.length})`);let V=JSON.parse(Y),{prompt:H}=V;if(await B(`Parsed prompt: ${H.substring(0,100)}${H.length>100?"...":""}`),!qY(H)){await B("Not a /speck.* command, passing through"),console.log(JSON.stringify({}));return}let X=H.match(/^\/speck[.:]\w+/);await B(`Detected /speck.* command: ${X?.[0]??"unknown"}`);let J=AY(H);await B(`Check options: ${JSON.stringify(J)}`);let Q=await f(J,!0);if(await B(`Prerequisite check result: success=${Q.success}`),Q.success&&Q.output){let Z=d(Q);await B(`Formatted context (length: ${Z.length})`),await B(`Context preview: ${Z.substring(0,200)}`);let U={hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:Z}};await B("Returning success with additionalContext"),console.log(JSON.stringify(U))}else{let Z=g(Q.error||"Unknown error");await B(`Blocking with error: ${Q.error}`),console.log(JSON.stringify({decision:"block",reason:Z,hookSpecificOutput:{hookEventName:"UserPromptSubmit"}}))}}catch(Y){let V=Y instanceof Error?Y.message:String(Y);await B(`Hook error: ${V}`),console.error(`PrePromptSubmit hook error: ${V}`),console.log(JSON.stringify({}))}}TY();
