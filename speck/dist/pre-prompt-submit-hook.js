#!/usr/bin/env bun
// @bun
var f=Object.create;var{getPrototypeOf:d,defineProperty:E,getOwnPropertyNames:u}=Object;var g=Object.prototype.hasOwnProperty;var l=(Y,Q,H)=>{H=Y!=null?f(d(Y)):{};let V=Q||!Y||!Y.__esModule?E(H,"default",{value:Y,enumerable:!0}):H;for(let J of u(Y))if(!g.call(V,J))E(V,J,{get:()=>Y[J],enumerable:!0});return V};var h=import.meta.require;import{existsSync as G,readdirSync as P,readFileSync as N}from"fs";import{join as q}from"path";import{existsSync as T}from"fs";import{readdirSync as w}from"fs";import v from"fs/promises";import U from"path";var{$:M}=globalThis.Bun;async function p(){try{return(await M`git rev-parse --show-toplevel`.quiet()).text().trim()}catch{let Y=import.meta.dir;return U.resolve(Y,"../../..")}}var j=null;async function c(){if(j)return j;let Y=await p(),Q=U.join(Y,".speck","root");try{if(!(await v.lstat(Q)).isSymbolicLink()){console.warn(`WARNING: .speck/root exists but is not a symlink
Expected: symlink to speck root directory
Found: regular file/directory
Falling back to single-repo mode.
To enable multi-repo: mv .speck/root .speck/root.backup && /speck.link <path>`);let A={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:U.join(Y,"specs")};return j=A,A}let V=await v.realpath(Q),J=["/","/etc","/usr","/bin","/sbin","/System","/Library"],X=process.env.HOME||process.env.USERPROFILE||"";if(J.some((A)=>V===A||V.startsWith(A+"/")))throw Error(`Security: .speck/root symlink points to system directory: ${V}
Speck root must be a user-owned project directory.
Fix: rm .speck/root && /speck.link <safe-project-path>`);if(X&&V===U.dirname(X))throw Error(`Security: .speck/root symlink points above home directory: ${V}
Fix: rm .speck/root && /speck.link <project-path-within-home>`);await v.access(V);let Z=U.join(Y,"specs");try{if((await v.stat(Z)).isDirectory()&&V!==Y)console.warn(`WARNING: Local specs/ directory exists in multi-repo mode
  Local: ${Z}
  Shared: ${U.join(V,"specs")}
In multi-repo mode, specs are read from the shared speck root.
The local specs/ directory is ignored.
To migrate local specs to shared location:
  1. Copy specs: cp -r ${Z}/* ${U.join(V,"specs")}/
  2. Remove local specs: rm -rf ${Z}
`)}catch(A){let W=A;if(W.code!=="ENOENT")console.warn(`Warning: Could not check local specs/ directory: ${W.message}`)}let K={mode:"multi-repo",speckRoot:V,repoRoot:Y,specsDir:U.join(V,"specs")};return j=K,K}catch(H){let V=H;if(V.code==="ENOENT"){if((await n(Y)).length>0){let K={mode:"multi-repo",speckRoot:Y,repoRoot:Y,specsDir:U.join(Y,"specs")};return j=K,K}let Z={mode:"single-repo",speckRoot:Y,repoRoot:Y,specsDir:U.join(Y,"specs")};return j=Z,Z}if(V.code==="ELOOP")throw Error(`Multi-repo configuration broken: .speck/root contains circular reference
Fix: rm .speck/root && /speck.link <valid-path>`);let J=await v.readlink(Q).catch(()=>"unknown");throw Error(`Multi-repo configuration broken: .speck/root \u2192 ${J} (does not exist)
Fix:
  1. Remove broken symlink: rm .speck/root
  2. Link to correct location: /speck.link <path-to-speck-root>`)}}async function n(Y){let Q=[];try{let H=await v.readdir(Y,{withFileTypes:!0});for(let V of H)if(V.isSymbolicLink()&&V.name.startsWith(".speck-link-")){let J=U.join(Y,V.name);try{let X=await v.realpath(J);if(["/","/etc","/usr","/bin","/sbin","/System","/Library"].some((A)=>X===A||X.startsWith(A+"/"))){console.warn(`Security: Skipping ${V.name} - points to system directory: ${X}`);continue}let K=U.join(X,".git");try{await v.access(K),Q.push(X)}catch{console.warn(`Warning: ${V.name} points to non-git directory: ${X}`)}}catch(X){let Z=X instanceof Error?X.message:String(X);console.warn(`Warning: Broken symlink ${V.name}: ${Z}`)}}}catch(H){if(H.code!=="ENOENT")throw H}return Q}async function i(Y){if(process.env.SPECIFY_FEATURE)return process.env.SPECIFY_FEATURE;try{return(await M`git rev-parse --abbrev-ref HEAD`.quiet()).text().trim()}catch{let Q=U.join(Y,"specs");if(T(Q)){let H="",V=0,J=w(Q,{withFileTypes:!0});for(let X of J)if(X.isDirectory()){let Z=X.name.match(/^(\d{3})-/);if(Z&&Z[1]){let K=parseInt(Z[1],10);if(K>V)V=K,H=X.name}}if(H)return H}return"main"}}async function s(){try{return await M`git rev-parse --show-toplevel`.quiet(),!0}catch{return!1}}async function F(Y,Q,H){if(!Q)return console.error("[specify] Warning: Git repository not detected; skipped branch validation"),!0;let V=U.join(H,".speck","branches.json");if(T(V))try{let J=await v.readFile(V,"utf-8"),X=JSON.parse(J);if(X.branches&&Array.isArray(X.branches)){if(X.branches.some((K)=>K.name===Y))return!0}}catch{}if(!/^\d{3}-/.test(Y))return console.error(`ERROR: Not on a feature branch. Current branch: ${Y}`),console.error("Feature branches should be named like: 001-feature-name"),!1;return!0}async function a(Y,Q,H){let V=U.join(H,".speck","branches.json");if(T(V))try{let K=await v.readFile(V,"utf-8"),A=JSON.parse(K);if(A.branches&&Array.isArray(A.branches)){let W=A.branches.find((I)=>I.name===Q);if(W&&W.specId)return U.join(Y,W.specId)}}catch{}let J=Q.match(/^(\d{3})-/);if(!J)return U.join(Y,Q);let X=J[1],Z=[];if(T(Y)){let K=w(Y,{withFileTypes:!0});for(let A of K)if(A.isDirectory()&&A.name.startsWith(`${X}-`))Z.push(A.name)}if(Z.length===0)return U.join(Y,Q);else if(Z.length===1&&Z[0])return U.join(Y,Z[0]);else return console.error(`ERROR: Multiple spec directories found with prefix '${X}': ${Z.join(", ")}`),console.error("Please ensure only one spec directory exists per numeric prefix."),U.join(Y,Q)}async function x(){let Y=await c(),Q=await i(Y.repoRoot),H=await s(),V=await a(Y.specsDir,Q,Y.repoRoot),J=U.basename(V);return{MODE:Y.mode,SPECK_ROOT:Y.speckRoot,SPECS_DIR:Y.specsDir,REPO_ROOT:Y.repoRoot,CURRENT_BRANCH:Q,HAS_GIT:H?"true":"false",FEATURE_DIR:V,FEATURE_SPEC:U.join(V,"spec.md"),IMPL_PLAN:U.join(Y.repoRoot,"specs",J,"plan.md"),TASKS:U.join(Y.repoRoot,"specs",J,"tasks.md"),RESEARCH:U.join(V,"research.md"),DATA_MODEL:U.join(V,"data-model.md"),QUICKSTART:U.join(V,"quickstart.md"),CONTRACTS_DIR:U.join(V,"contracts")}}function _(Y,Q){return T(Y)?`  \u2713 ${Q}`:`  \u2717 ${Q}`}function b(Y,Q){if(!T(Y))return`  \u2717 ${Q}`;try{return w(Y).length>0?`  \u2713 ${Q}`:`  \u2717 ${Q}`}catch{return`  \u2717 ${Q}`}}function r(Y){return{json:Y.includes("--json"),requireTasks:Y.includes("--require-tasks"),includeTasks:Y.includes("--include-tasks"),pathsOnly:Y.includes("--paths-only"),skipFeatureCheck:Y.includes("--skip-feature-check"),skipPlanCheck:Y.includes("--skip-plan-check"),help:Y.includes("--help")||Y.includes("-h"),includeFileContents:Y.includes("--include-file-contents"),includeWorkflowMode:Y.includes("--include-workflow-mode"),validateCodeQuality:Y.includes("--validate-code-quality")}}function o(){console.log(`Usage: check-prerequisites.ts [OPTIONS]

Consolidated prerequisite checking for Spec-Driven Development workflow.

OPTIONS:
  --json                   Output in JSON format
  --require-tasks          Require tasks.md to exist (for implementation phase)
  --include-tasks          Include tasks.md in AVAILABLE_DOCS list
  --paths-only             Only output path variables (no prerequisite validation)
  --skip-feature-check     Skip feature directory and plan.md validation (for /speck.specify)
  --skip-plan-check        Skip plan.md validation but check feature directory (for /speck.plan)
  --validate-code-quality  Validate TypeScript typecheck and ESLint (Constitution Principle IX)
  --include-file-contents  Include file contents in JSON output
  --include-workflow-mode  Include workflow mode in JSON output
  --help, -h               Show this help message

EXAMPLES:
  # Check task prerequisites (plan.md required)
  bun .speck/scripts/check-prerequisites.ts --json

  # Check implementation prerequisites (plan.md + tasks.md required)
  bun .speck/scripts/check-prerequisites.ts --json --require-tasks --include-tasks

  # Validate code quality before feature completion
  bun .speck/scripts/check-prerequisites.ts --validate-code-quality

  # Get feature paths only (no validation)
  bun .speck/scripts/check-prerequisites.ts --paths-only
`)}function e(Y,Q){if(Q){let H={MODE:Y.MODE,REPO_ROOT:Y.REPO_ROOT,BRANCH:Y.CURRENT_BRANCH,FEATURE_DIR:Y.FEATURE_DIR,FEATURE_SPEC:Y.FEATURE_SPEC,IMPL_PLAN:Y.IMPL_PLAN,TASKS:Y.TASKS};console.log(JSON.stringify(H))}else console.log(`MODE: ${Y.MODE}`),console.log(`REPO_ROOT: ${Y.REPO_ROOT}`),console.log(`BRANCH: ${Y.CURRENT_BRANCH}`),console.log(`FEATURE_DIR: ${Y.FEATURE_DIR}`),console.log(`FEATURE_SPEC: ${Y.FEATURE_SPEC}`),console.log(`IMPL_PLAN: ${Y.IMPL_PLAN}`),console.log(`TASKS: ${Y.TASKS}`)}function t(Y){let Q=["--json","--require-tasks","--include-tasks","--paths-only","--skip-feature-check","--skip-plan-check","--help","-h","--include-file-contents","--include-workflow-mode","--validate-code-quality"];for(let H of Y)if(H.startsWith("--")||H.startsWith("-")){if(!Q.includes(H))console.error(`ERROR: Unknown option '${H}'. Use --help for usage information.`),process.exit(1)}}var D={maxSingleFile:24576,maxTotalFiles:102400};function B(Y,Q){if(!G(Y))return"NOT_FOUND";try{let V=Bun.file(Y).size;if(V>D.maxSingleFile)return"TOO_LARGE";if(Q.value+V>D.maxTotalFiles)return"TOO_LARGE";let J=N(Y,"utf-8");return Q.value+=V,J}catch(H){return"NOT_FOUND"}}async function YY(Y){let{$:Q}=awaitPromise.resolve(globalThis.Bun),H=await Q`bun run typecheck`.cwd(Y).nothrow().quiet();if(H.exitCode!==0)return{passed:!1,message:`\u274C TypeScript validation failed (exit code ${H.exitCode})
${H.stderr.toString()}`};let V=await Q`bun run lint`.cwd(Y).nothrow().quiet();if(V.exitCode!==0){let J=V.stdout.toString();return{passed:!1,message:`\u274C ESLint validation failed (exit code ${V.exitCode})
${J}`}}return{passed:!0,message:"\u2705 Code quality validation passed (0 typecheck errors, 0 lint errors/warnings)"}}function HY(Y,Q){let H=q(Y,"plan.md");if(G(H))try{let X=N(H,"utf-8").match(/\*\*Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(X&&X[1])return X[1]}catch{}let V=q(Q,".speck","memory","constitution.md");if(G(V))try{let X=N(V,"utf-8").match(/\*\*Default Workflow Mode\*\*:\s*(stacked-pr|single-branch)/);if(X&&X[1])return X[1]}catch{}return"single-branch"}async function y(Y){if(!Y.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: Direct invocation deprecated. Prerequisites are now auto-checked via PrePromptSubmit hook.\x1B[0m
`);t(Y);let Q=r(Y);if(Q.help)return o(),0;let H=await x(),V=H.HAS_GIT==="true";if(!Q.skipFeatureCheck){if(!await F(H.CURRENT_BRANCH,V,H.REPO_ROOT))return 1}if(Q.pathsOnly||Q.skipFeatureCheck)return e(H,Q.json),0;if(!G(H.FEATURE_DIR))return console.error(`ERROR: Feature directory not found: ${H.FEATURE_DIR}`),console.error("Run /speck.specify first to create the feature structure."),1;if(!Q.skipPlanCheck&&!G(H.IMPL_PLAN))return console.error(`ERROR: plan.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.plan first to create the implementation plan."),1;if(Q.requireTasks&&!G(H.TASKS))return console.error(`ERROR: tasks.md not found in ${H.FEATURE_DIR}`),console.error("Run /speck.tasks first to create the task list."),1;let J=[];if(G(H.RESEARCH))J.push("research.md");if(G(H.DATA_MODEL))J.push("data-model.md");if(G(H.CONTRACTS_DIR))try{if(P(H.CONTRACTS_DIR).length>0)J.push("contracts/")}catch{}if(G(H.QUICKSTART))J.push("quickstart.md");if(Q.includeTasks&&G(H.TASKS))J.push("tasks.md");let X;if(Q.includeFileContents){X={};let K={value:0};X["tasks.md"]=B(H.TASKS,K),X["plan.md"]=B(H.IMPL_PLAN,K),X["spec.md"]=B(H.FEATURE_SPEC,K);let A=q(H.REPO_ROOT,".speck","memory","constitution.md");X["constitution.md"]=B(A,K),X["data-model.md"]=B(H.DATA_MODEL,K),X["research.md"]=B(H.RESEARCH,K);let W=q(H.FEATURE_DIR,"checklists");if(G(W))try{let I=P(W).filter((O)=>O.endsWith(".md"));for(let O of I){let m=q(W,O);X[`checklists/${O}`]=B(m,K)}}catch{}}let Z;if(Q.includeWorkflowMode)Z=HY(H.FEATURE_DIR,H.REPO_ROOT);if(Q.validateCodeQuality){let K=await YY(H.REPO_ROOT);if(!K.passed)return console.error(`
`+K.message),console.error(`
Constitution Principle IX requires zero typecheck errors and zero lint errors/warnings.`),console.error(`Fix all issues before marking the feature complete.
`),1;if(!Q.json)console.log(`
`+K.message+`
`)}if(Q.json){let K={MODE:H.MODE,FEATURE_DIR:H.FEATURE_DIR,AVAILABLE_DOCS:J,...X&&{FILE_CONTENTS:X},...Z&&{WORKFLOW_MODE:Z}};console.log(JSON.stringify(K))}else if(console.log(`FEATURE_DIR:${H.FEATURE_DIR}`),console.log("AVAILABLE_DOCS:"),console.log(_(H.RESEARCH,"research.md")),console.log(_(H.DATA_MODEL,"data-model.md")),console.log(b(H.CONTRACTS_DIR,"contracts/")),console.log(_(H.QUICKSTART,"quickstart.md")),Q.includeTasks)console.log(_(H.TASKS,"tasks.md"));return 0}var z=null;function S(){if(!z)return null;if(Date.now()-z.timestamp>5000)return z=null,null;return z}function L(Y){z=Y}async function QY(Y){let{log:Q,error:H}=console,V="",J="";console.log=(...X)=>{V+=X.join(" ")+`
`},console.error=(...X)=>{J+=X.join(" ")+`
`};try{return{exitCode:await Y(),stdout:V.trim(),stderr:J.trim()}}catch(X){let Z=X instanceof Error?X:Error(String(X));return J+=`Error: ${Z.message}
`,{exitCode:2,stdout:V.trim(),stderr:J.trim()}}finally{console.log=Q,console.error=H}}async function C(Y={},Q=!0){if(Q){let H=S();if(H)return{success:H.success,output:H.output,error:H.error,cached:!0}}try{let H=["--json"];if(Y.requireTasks)H.push("--require-tasks");if(Y.includeTasks)H.push("--include-tasks");if(Y.skipFeatureCheck)H.push("--skip-feature-check");if(Y.skipPlanCheck)H.push("--skip-plan-check");if(Y.includeFileContents)H.push("--include-file-contents");if(Y.includeWorkflowMode)H.push("--include-workflow-mode");let{exitCode:V,stdout:J,stderr:X}=await QY(()=>y(H));if(V===0)try{let Z=JSON.parse(J),K={success:!0,output:Z,error:null,cached:!1};return L({success:!0,output:Z,error:null,timestamp:Date.now()}),K}catch(Z){let A=`Failed to parse check-prerequisites output: ${(Z instanceof Error?Z:Error(String(Z))).message}`,W={success:!1,output:null,error:A,cached:!1};return L({success:!1,output:null,error:A,timestamp:Date.now()}),W}else{let Z=X||`check-prerequisites exited with code ${V}`,K={success:!1,output:null,error:Z,cached:!1};return L({success:!1,output:null,error:Z,timestamp:Date.now()}),K}}catch(H){let J=`Failed to run check-prerequisites: ${(H instanceof Error?H:Error(String(H))).message}`,X={success:!1,output:null,error:J,cached:!1};return L({success:!1,output:null,error:J,timestamp:Date.now()}),X}}function k(Y){if(!Y.success||!Y.output)return"";let{FEATURE_DIR:Q,AVAILABLE_DOCS:H,MODE:V,FILE_CONTENTS:J,WORKFLOW_MODE:X}=Y.output,Z={MODE:V,FEATURE_DIR:Q,AVAILABLE_DOCS:H};if(J)Z.FILE_CONTENTS=J;if(X)Z.WORKFLOW_MODE=X;return`<!-- SPECK_PREREQ_CONTEXT
${JSON.stringify(Z)}
-->`}function R(Y){return`\u26A0\uFE0F **Prerequisite Check Failed**

${Y}

Please ensure you're on a valid feature branch and have run the necessary Speck commands.
`.trim()}import{appendFile as VY}from"fs/promises";var XY="/private/tmp/.claude-hook-test/speck-hook-log.txt",$=async(Y)=>{await VY(XY,`[${new Date().toISOString()}] [PrePromptSubmit] ${Y}
`)};function JY(Y){return/^\/speck[.:]/.test(Y.trim())}function ZY(Y){let H=Y.match(/^\/speck[.:](\w+)/)?.[1]??"",V=["implement"],J=["implement","analyze"],X=["specify"],Z=["plan"],K=["implement","analyze","plan","tasks","checklist","clarify"],A=["implement"];return{requireTasks:V.includes(H),includeTasks:J.includes(H),skipFeatureCheck:X.includes(H),skipPlanCheck:Z.includes(H),includeFileContents:K.includes(H),includeWorkflowMode:A.includes(H)}}async function KY(){try{let Y=await Bun.stdin.text();await $(`Received hook input (length: ${Y.length})`);let Q=JSON.parse(Y),{prompt:H}=Q;if(await $(`Parsed prompt: ${H.substring(0,100)}${H.length>100?"...":""}`),!JY(H)){await $("Not a /speck.* command, passing through"),console.log(JSON.stringify({}));return}let V=H.match(/^\/speck[.:]\w+/);await $(`Detected /speck.* command: ${V?.[0]??"unknown"}`);let J=ZY(H);await $(`Check options: ${JSON.stringify(J)}`);let X=await C(J,!0);if(await $(`Prerequisite check result: success=${X.success}`),X.success&&X.output){let Z=k(X);await $(`Formatted context (length: ${Z.length})`),await $(`Context preview: ${Z.substring(0,200)}`);let K={hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:Z}};await $("Returning success with additionalContext"),console.log(JSON.stringify(K))}else{let Z=R(X.error||"Unknown error");await $(`Blocking with error: ${X.error}`),console.log(JSON.stringify({decision:"block",reason:Z,hookSpecificOutput:{hookEventName:"UserPromptSubmit"}}))}}catch(Y){let Q=Y instanceof Error?Y.message:String(Y);await $(`Hook error: ${Q}`),console.error(`PrePromptSubmit hook error: ${Q}`),console.log(JSON.stringify({}))}}KY();
