#!/usr/bin/env bun
// @bun
import{a as w,b as R,c as p,d,e as s,f as c,g as Wq,h as i,i as t,j as Xq,k as Yq,l as Zq,m as _q,n as Uq,o as zq,p as m,q as n,r as Vq,s as e,t as Oq}from"./speck-7546wgqm.js";import{B as u,C as Jq,D as Kq,F as o,G as Qq,I as F,u as Gq,x as jq}from"./paths-x5kskk5z.js";import l from"path";import b from"fs/promises";var{$:f}=globalThis.Bun;async function Lq(q){try{let H=(await f`git -C ${q} symbolic-ref --short HEAD 2>/dev/null || git -C ${q} rev-parse --short HEAD 2>/dev/null`.quiet()).text().trim();if(H&&/^\d{3}-.+$/.test(H)){let W=l.join(q,"specs",H);try{return await b.access(W),H}catch{}}let K=l.join(q,"specs"),Y=(await b.readdir(K)).filter((W)=>/^\d{3}-.+$/.test(W));if(Y.length===0)return null;return Y.sort(),Y[Y.length-1]}catch{return null}}async function Eq(){try{return(await f`which gh`.quiet()).exitCode===0}catch{return!1}}async function $q(q,J,H){try{let K=await f`git -C ${H} log ${q}..${J} --format=%s%n%b`.quiet();if(K.exitCode!==0)return[];return K.stdout.toString().trim().split(`
`).filter((Q)=>Q.trim())}catch{return[]}}function Tq(q){let J=[/^wip/i,/^fix$/i,/^tmp/i,/^temp/i,/^test/i,/^update$/i,/^merge/i,/^rebase/i,/^\./],H=q.trim().toLowerCase();return!J.some((K)=>K.test(H))&&H.length>5}function vq(q){if(q.length===0)return null;let J=q.filter((Q)=>Q.trim()&&Tq(Q));if(J.length===0)return null;let H=J[0].split(`
`)[0],K=J.map((Q)=>`- ${Q.split(`
`)[0]}`).join(`
`);return{title:H,body:K}}async function Aq(q,J,H){try{let Q=(await f`git -C ${H} diff ${q}...${J} --stat`.quiet()).stdout.toString().trim(),W=(await f`git -C ${H} diff ${q}...${J} --name-status`.quiet()).stdout.toString().trim().split(`
`).filter((U)=>U.trim()),X=`Update ${J} (${W.length} files changed)`,z=`## Changes

${Q}

## Files Modified
${W.map((U)=>`- ${U}`).join(`
`)}`;return{title:X,body:z}}catch{return{title:`Update ${J}`,body:"Changes made on this branch"}}}function Dq(q,J,H){if(J)return J;return"main"}async function Pq(q,J,H,K,Q){if(Q?.context==="child"){if(!await Oq(K))return console.warn(`
\u26A0\uFE0F  WARNING: No remote configured for this repository.`),console.warn("Branch created locally. PR creation unavailable."),console.warn(`
To configure remote:`),console.warn("  git remote add origin <url>"),console.warn(`  git push -u origin <branch-name>
`),null}if(!await Eq())return null;let W=d(H,q),X;if(Q?.context==="child")X=await e(K)||"main";else X=Dq(q,W?.baseBranch||null,K);let z=await $q(X,q,K);if(z.length===0)return null;let U=vq(z);if(!U)U=await Aq(X,q,K);let O=U.title;if(Q?.childRepoName)O=`[${Q.childRepoName}] ${U.title}`;return{title:O,body:U.body,prBase:X}}function h(q,J,H){let K=q.branches.filter((W)=>W.specId===J),Q=K.filter((W)=>!K.some((X)=>X.name===W.baseBranch));function Y(W,X,z){let U=K.find((L)=>L.name===W);if(!U)return;let O="  ".repeat(X),Z=X===0?"":z?"\u2514\u2500 ":"\u251C\u2500 ",V=W===H?" (current)":"",j=U.status!=="active"?` (${U.status}${U.pr?`, PR #${U.pr}`:""})`:"";console.log(`${O}${Z}${W}${V}${j}`);let P=K.filter((L)=>L.baseBranch===W);P.forEach((L,G)=>{Y(L.name,X+1,G===P.length-1)})}Q.forEach((W)=>{console.log(`  ${W.baseBranch}`),Y(W.name,1,!0)})}function qq(q,J){let H=J;while(H){let K=q.branches.find((Q)=>Q.name===H.baseBranch);if(!K)return H.baseBranch;H=K}return"main"}async function wq(q){let J=q.findIndex((_)=>!_.startsWith("--"));if(J===-1)throw Error("Branch name required: /speck.branch create <name> [--base <base>]");let H=q[J],K=q.indexOf("--base"),Q=q.indexOf("--spec"),Y=q.includes("--skip-pr-prompt"),W=q.includes("--create-pr"),X=q.indexOf("--title"),z=q.indexOf("--description"),U=q.indexOf("--pr-base"),O=q.includes("--json"),Z=await F(),V=Z.REPO_ROOT,j=await u(),P=await Jq(),L=null;if(j.mode==="multi-repo"){let _=P?"child":"root",k=P?await Lq(j.speckRoot):null,C=P?await Kq(j.repoRoot,j.speckRoot):null;L={...j,context:_,parentSpecId:k,childRepoName:C}}let G="";try{G=await m(V)}catch(_){G=""}let A;if(K!==-1&&q[K+1])A=q[K+1];else{if(!G)return console.error("Error: No commits in repository. Cannot determine current branch."),console.error("Please create an initial commit first, or specify --base explicitly."),1;A=G,console.log(`Defaulting base to current branch: ${A}`)}let $=Q!==-1?q[Q+1]:null;if(!await Qq(H))throw Error(`Invalid branch name: '${H}'. Must be a valid git ref name.`);try{await Vq(A,V)}catch(_){if(_ instanceof Error)throw Error(_.message);throw _}if(!$){if(Z.FEATURE_DIR&&Z.FEATURE_DIR.includes("/specs/")){let _=Z.FEATURE_DIR.match(/\/specs\/([^\/]+)/);if(_){if($=_[1],!O)console.log(`Auto-detected spec: ${$}`)}}if(!$)throw Error(`Could not auto-detect spec ID. Please specify with --spec flag:
  /speck.branch create <name> [--base <base>] --spec <spec-id>`)}let T=L?j.specsDir:l.join(V,"specs"),v=l.join(T,$);try{await b.access(v)}catch{throw Error(`Spec directory not found: specs/${$}/`)}if((await f`git -C ${V} status --porcelain`.quiet()).stdout.toString().split(`
`).filter((_)=>_.trim().length>0).filter((_)=>!_.includes(".speck/branches.json")).length>0){console.log(`
${"\u26A0".repeat(30)}`),console.log(`\u26A0 Warning: Current branch '${G}' has uncommitted changes`),console.log(`${"\u26A0".repeat(30)}
`);let _=await f`git -C ${V} diff --stat`.quiet();throw console.log("Changed files:"),console.log(_.stdout.toString()),console.log(`
Options:`),console.log("  1. Commit changes now (recommended)"),console.log("  2. Stash changes (saves for later)"),console.log("  3. Carry changes to new branch (creates new branch with changes)"),console.log("  4. Abort branch creation"),console.log(`
Choose an option or run one of these commands first:`),console.log('  git add . && git commit -m "message"  # Commit changes'),console.log("  git stash                              # Stash changes"),console.log(`
Then re-run: /speck.branch create `+q.join(" ")),Error("Uncommitted changes detected. Please commit or stash changes before creating a new branch.")}let E=await w(V);if(!Y&&!W){let _=await Pq(G,A,E,V,L);if(_){if(O){let k={branch:G,title:_.title,body:_.body,base:_.prBase};console.log(JSON.stringify(k))}else{let k={type:"pr-suggestion",branch:G,suggestedTitle:_.title,suggestedDescription:_.body,suggestedBase:_.prBase,newBranch:H};console.error(JSON.stringify(k)),console.log(`
${"=".repeat(60)}`),console.log(`\uD83D\uDCA1 PR Opportunity: Create PR for '${G}' before switching`),console.log(`${"=".repeat(60)}`),console.log(`
Suggested PR details:`),console.log(`  Title: ${_.title}`),console.log(`  Base: ${_.prBase}`),console.log(`
Description:`),console.log(_.body.split(`
`).map((C)=>`  ${C}`).join(`
`)),console.log(`
${"-".repeat(60)}`),console.log("Option 1: Create PR with gh CLI:"),console.log(`  gh pr create --base ${_.prBase} --title "${_.title}" --body "${_.body.replace(/"/g,"\\\"")}"`),console.log(`
Option 2: Create PR via GitHub URL:`),console.log(`  https://github.com/OWNER/REPO/compare/${_.prBase}...${G}?expand=1&title=${encodeURIComponent(_.title)}`),console.log(`
Option 3: Skip and create branch without PR`),console.log(`${"=".repeat(60)}
`)}return 2}}if(W){let _=X!==-1?q[X+1]:null,k=z!==-1?q[z+1]:null,C=U!==-1?q[U+1]:null;if(!_||!k||!C)throw Error("--create-pr requires --title, --description, and --pr-base flags");console.log(`Creating PR for '${G}'...`);try{let N=await f`gh pr create --base ${C} --title ${_} --body ${k}`.quiet();if(N.exitCode!==0)throw Error(`gh pr create failed: ${N.stderr.toString()}`);let a=N.stdout.toString().match(/\/pull\/(\d+)/),g=a?parseInt(a[1],10):null;if(g){if(console.log(`\u2713 Created PR #${g} for '${G}'`),d(E,G))E=c(E,G,"submitted",g),await R(V,E)}else console.log(`\u2713 PR created for '${G}' (could not parse PR number from output)`)}catch(N){let y=N instanceof Error?N.message:String(N);if(y.includes("gh: command not found")||y.includes("not found"))return console.error(`
\u274C Error: GitHub CLI (gh) is not installed`),console.error(`
To install gh:`),console.error("  brew install gh           # macOS"),console.error("  sudo apt install gh       # Ubuntu/Debian"),console.error("  winget install GitHub.cli # Windows"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${H} --skip-pr-prompt`),1;if(y.includes("authentication")||y.includes("401"))return console.error(`
\u274C Error: GitHub CLI is not authenticated`),console.error(`
To authenticate:`),console.error("  gh auth login"),console.error(`
Or use --skip-pr-prompt to create branch without PR:`),console.error(`  /speck.branch create ${H} --skip-pr-prompt`),1;return console.error(`
\u274C Error creating PR: ${y}`),console.error(`
You can:`),console.error("  1. Check your network connection and try again"),console.error("  2. Create the PR manually via GitHub web UI"),console.error("  3. Use --skip-pr-prompt to create branch without PR"),1}}let B=new Date().toISOString(),x={name:H,specId:$,baseBranch:A,status:"active",pr:null,createdAt:B,updatedAt:B,...L?.parentSpecId&&{parentSpecId:L.parentSpecId}},r=i(H,{...E,branches:[...E.branches,x]});if(r)throw Error(`Circular dependency detected: ${r.join(" \u2192 ")}`);if(E=s(E,x),await Zq(H,A,V),await zq(H,V),await R(V,E),!O)console.log(`\u2713 Created stacked branch '${H}'`),console.log(`\u2713 Based on: ${A}`),console.log(`\u2713 Linked to spec: ${$}`),console.log(),console.log("Branch stack:"),h(E,$,H),console.log(),console.log("Next steps:"),console.log("  - Implement feature on this branch"),console.log(`  - Run /speck.tasks --branch ${H} to generate tasks`),console.log(`  - When ready: /speck.branch create <next-branch> --base ${H}`)}async function Mq(q){let J=q.includes("--all"),H=await F(),K=await u(),Q=H.REPO_ROOT;if(J&&K.mode==="multi-repo"){await xq(K.speckRoot,Q);return}let Y=await w(Q);if(Y.branches.length===0){console.log("No stacked branches found."),console.log("Create your first stacked branch with:"),console.log("  /speck.branch create <name> --base main");return}let W="";try{W=await m(Q)}catch(X){W=""}if(J){let X=Object.keys(Y.specIndex);for(let z of X)console.log(`
Spec: ${z}`),console.log("Branch Stack:"),h(Y,z,W);console.log(`
Total: ${Y.branches.length} branches across ${X.length} specs`)}else{let X=p(Y,W);if(!X){console.log("Current branch is not in stacked mode."),console.log("Use --all to see all stacked branches.");return}console.log(`Spec: ${X}
`),console.log("Branch Stack:"),h(Y,X,W),console.log(`
Legend:`),console.log("  (current) = checked out branch"),console.log("  (active) = development in progress"),console.log("  (submitted) = PR open for review")}}async function xq(q,J){let H=await t(q,J);if(console.log(`Branch List (All Repositories)
`),H.rootRepo&&H.rootRepo.branchCount>0){console.log("Root Repository:"),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let Q=await w(q);for(let Y of Q.branches){let W=Y.pr?String(Y.pr).padEnd(5):"-".padEnd(5);console.log(`${Y.name.padEnd(18)} ${Y.baseBranch.padEnd(14)} ${Y.specId.padEnd(23)} ${W} ${Y.status}`)}console.log("")}let K=Array.from(H.childRepos.keys()).sort();for(let Q of K){let Y=H.childRepos.get(Q);console.log(`Child: ${Q}`),console.log("Branch             Base           Spec                    PR#   Status"),console.log("\u2500".repeat(80));let W=await w(Y.repoPath);for(let X of W.branches){let z=X.pr?String(X.pr).padEnd(5):"-".padEnd(5);console.log(`${X.name.padEnd(18)} ${X.baseBranch.padEnd(14)} ${X.specId.padEnd(23)} ${z} ${X.status}`)}console.log("")}if(K.length===0&&!H.rootRepo)console.log("No branches found in any repository.")}async function kq(q=[]){let J=q.includes("--all"),H=await F(),K=await u(),Q=H.REPO_ROOT;if(J&&K.mode==="multi-repo"){await fq(K.speckRoot,Q);return}let Y=await w(Q),W="";try{W=await m(Q)}catch(Z){W=""}let X=p(Y,W);if(!X){console.log("Current branch is not in stacked mode.");return}let z=Y.branches.filter((Z)=>Z.specId===X),U=0;console.log(`Spec: ${X}
`);for(let Z of z){if(!await n(Z.name,Q)){console.log(`${Z.name} (${Z.status}${Z.pr?`, PR #${Z.pr}`:""})`),console.log("  \u26A0 ORPHANED: Branch no longer exists in git"),console.log(`  \u2192 Run: /speck.branch delete ${Z.name} (cleanup metadata)`),U++;continue}let j=await _q(Z.name,Z.baseBranch,Q);if(j&&Z.status!=="merged")console.log(`${Z.name} (${Z.status}${Z.pr?`, PR #${Z.pr}`:""})`),console.log(`  \u26A0 MERGED: Branch merged into base but status is '${Z.status}'`),console.log(`  \u2192 Run: /speck.branch update ${Z.name} --status merged`),U++;if(j&&Z.status==="merged"){let P=z.filter((L)=>L.baseBranch===Z.name&&L.status!=="merged");if(P.length>0)for(let L of P)console.log(`
${L.name} (${L.status})`),console.log(`  \u26A0 REBASE NEEDED: Base branch '${Z.name}' has been merged`),console.log(`  \u2192 Run: git rebase ${qq(Y,Z)}`),console.log(`  \u2192 Update base: /speck.branch update ${L.name} --base ${qq(Y,Z)}`),U++}}if(U===0)console.log("\u2713 Branch stack is healthy - no warnings");else console.log(`
\u26A0 ${U} warning(s) found`);let O=await o();if(O.mode==="child"&&Y.branches.length>0)try{let{findChildRepos:Z}=await import("./paths-x5kskk5z.js"),V=O.speckRoot||"";if(!(await Z(V)).includes(Q))console.log(`
\u26A0 Orphaned tracking detected:`),console.log(`  ${Y.branches.length} branch(es) tracked but repo unlinked from parent spec`),console.log(`  Parent: ${V}`),console.log("  Fix: Re-link with /speck.link or archive .speck/branches.json")}catch{}}async function fq(q,J){let H=await t(q,J);if(console.log(`Branch Status (All Repositories)
`),H.rootRepo&&H.rootRepo.branchCount>0)console.log("Root Repository:"),await Hq(q,H.rootRepo),console.log("");let K=Array.from(H.childRepos.keys()).sort();for(let Q of K){let Y=H.childRepos.get(Q);console.log(`Child: ${Q}`),await Hq(Y.repoPath,Y),console.log("")}if(K.length===0&&!H.rootRepo)console.log("No branches found in any repository.")}async function Hq(q,J){let H=await w(q),K=[];if(J.statusCounts.active>0)K.push(`${J.statusCounts.active} active`);if(J.statusCounts.submitted>0)K.push(`${J.statusCounts.submitted} submitted`);if(J.statusCounts.merged>0)K.push(`${J.statusCounts.merged} merged`);if(J.statusCounts.abandoned>0)K.push(`${J.statusCounts.abandoned} abandoned`);if(K.length>0)console.log(`  Total: ${J.branchCount} branches (${K.join(", ")})`);console.log("  Dependency Tree:");for(let Q of J.chains)if(Q.branches.length>0)Iq(Q.branches,H)}function Iq(q,J){q.forEach((H,K)=>{let Q=J.branches.find((X)=>X.name===H);if(!Q)return;let W=`${K===0?"    \u2514\u2500":"       \u2514\u2500"} ${H}`;if(Q.pr)W+=` (${Q.status}, PR #${Q.pr})`;else if(Q.status!=="active")W+=` (${Q.status})`;console.log(W)})}async function Nq(q){let J=q[0];if(!J)throw Error("Branch name required: /speck.branch update <name> [options]");let H=q.indexOf("--status"),K=q.indexOf("--pr"),Q=q.indexOf("--base"),W=(await F()).REPO_ROOT,X=await w(W);if(!d(X,J))throw Error(`Branch '${J}' not found in mapping`);if(H!==-1){let U=q[H+1];if(!["active","submitted","merged","abandoned"].includes(U))throw Error(`Invalid status: '${U}'. Must be: active, submitted, merged, or abandoned`);let O=K!==-1?parseInt(q[K+1],10):void 0;X=c(X,J,U,O)}if(Q!==-1){let U=q[Q+1];if(!await n(U,W))throw Error(`Base branch '${U}' does not exist`);let Z=X.branches.map((j)=>j.name===J?{...j,baseBranch:U,updatedAt:new Date().toISOString()}:j),V=i(J,{...X,branches:Z});if(V)throw Error(`Cannot update base: circular dependency detected: ${V.join(" \u2192 ")}`);X={...X,branches:Z}}await R(W,X),console.log(`\u2713 Updated branch '${J}'`)}async function Fq(q){let J=q[0];if(!J)throw Error("Branch name required: /speck.branch delete <name>");let H=q.includes("--force"),Q=(await F()).REPO_ROOT,Y=await w(Q),W=Y.branches.filter((z)=>z.baseBranch===J);if(W.length>0&&!H)throw console.error(`Error: Branch '${J}' has child branches:`),W.forEach((z)=>console.error(`  - ${z.name}`)),console.error(`
Use --force to delete anyway (will orphan children)`),Error("Branch has children");let X=Wq(Y,J);await R(Q,X),console.log(`\u2713 Removed branch '${J}' from metadata`),console.log(),console.log("Note: Git branch still exists. To delete it, run:"),console.log(`  git branch -D ${J}`)}async function Sq(q){let J=q.indexOf("--pattern"),H=J!==-1?q[J+1]:void 0,K=q.indexOf("--batch"),Q=K!==-1,W=(await F()).REPO_ROOT,X=await o(),z=X.context==="child"?await Lq(X.speckRoot):null,U=await Uq(W,H);if(U.length===0){console.log("No branches found to import.");return}let O=await w(W),Z=await e(W),V=U.filter(({name:D})=>!O.branches.some((T)=>T.name===D)&&D!==Z);if(V.length===0){console.log("All branches are already in stacked mode.");return}let j=X.specsDir,L=(await b.readdir(j)).filter((D)=>/^\d{3}-/.test(D));if(!Q){let D=V.map(({name:v,upstream:M})=>{let S="main";if(M){let I=M.replace(/^origin\//,"");if(I&&I!==v)S=I}return{name:v,upstream:M||null,inferredBase:S}});return console.error(JSON.stringify({type:"import-prompt",branches:D,availableSpecs:L})),console.log(`Found ${V.length} branches to import:
`),D.forEach((v)=>{console.log(`\u2022 ${v.name}`),console.log(`  Upstream: ${v.upstream||"(none)"}`),console.log(`  Inferred base: ${v.inferredBase}`),console.log()}),console.log(`Available specs: ${L.join(", ")}
`),console.log("Agent interaction required: Map each branch to a spec."),3}let G=q.slice(K+1),A=0,$=0;for(let D of G){let[T,v]=D.split(":");if(!T||!v){console.log(`\u26A0 Invalid mapping format: ${D}`);continue}if(v==="skip"){console.log(`\u2298 Skipped ${T}`),$++;continue}let M=V.find((x)=>x.name===T);if(!M){console.log(`\u26A0 Branch not found: ${T}`);continue}let S="main";if(M.upstream){let x=M.upstream.replace(/^origin\//,"");if(x&&x!==M.name)S=x}let I=new Date().toISOString(),E={name:T,specId:v,baseBranch:S,status:"active",pr:null,createdAt:I,updatedAt:I,...z&&{parentSpecId:z}},B=i(T,{...O,branches:[...O.branches,E]});if(B){console.log(`\u26A0 Skipped ${T} (would create cycle: ${B.join(" \u2192 ")})`),$++;continue}O=s(O,E),console.log(`\u2713 Imported ${T} \u2192 ${v}`),A++}await R(W,O),console.log(`
\u2713 Import complete:`),console.log(`  Imported: ${A}`),console.log(`  Skipped: ${$}`)}async function iq(q=process.argv.slice(2)){if(q.length===0)return console.log("Usage: /speck.branch <command> [args]"),console.log(),console.log("Commands:"),console.log("  create <name> [--base <base>] [--spec <spec-id>]"),console.log("  list [--all]"),console.log("  status"),console.log("  update <name> [--status <status>] [--pr <number>] [--base <branch>]"),console.log("  delete <name> [--force]"),console.log("  import [--pattern <pattern>]"),1;let J=q[0],H=q.slice(1);try{switch(J){case"create":await wq(H);break;case"list":await Mq(H);break;case"status":await kq(H);break;case"update":await Nq(H);break;case"delete":await Fq(H);break;case"import":await Sq(H);break;default:return console.error(`Unknown command: ${J}`),console.error("Run '/speck.branch' for usage"),1}}catch(K){if(K instanceof Yq||K instanceof Xq)return console.error(`Error: ${K.message}`),1;if(K instanceof Error){if(console.error(`Error: ${K.message}`),K.stack)console.error(`Stack trace: ${K.stack}`);return 1}return console.error(`Unknown error: ${String(K)}`),1}return 0}export{iq as main};
