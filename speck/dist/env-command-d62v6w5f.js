// @bun
import{a as _,i as $,p as v}from"./speck-v4perbmj.js";import{B as F,E as H,F as W}from"./paths-qqmkr5wb.js";import T from"fs/promises";import j from"path";async function b(z=process.argv.slice(2)){if(!z.includes("--json")&&process.stdout.isTTY)console.warn(`\x1B[33m\u26A0\uFE0F  DEPRECATION WARNING: This script is deprecated. Use 'speck-env' virtual command or 'bun .speck/scripts/speck.ts env' instead.\x1B[0m
`);if(z.includes("--help"))return E(),0;let q=z.includes("--json");try{return await I(q),0}catch(D){if(q)console.error(JSON.stringify({error:D instanceof Error?D.message:String(D)}));else console.error(`Error: ${D instanceof Error?D.message:String(D)}`);return 1}}function E(){console.log(`
Speck Environment Check

Usage:
  bun run .speck/scripts/env-command.ts [options]

Options:
  --help     Show this help message
  --json     Output as JSON (for programmatic use)

Description:
  Displays comprehensive environment information including:
  - Multi-repo configuration
  - Branch stack status (single-repo or aggregate)
  - Feature detection
  - System diagnostics
  `.trim())}async function I(z){let q=await F(),D=await W();if(z)await B(q,D);else await L(q,D)}async function L(z,q){console.log(`=== Speck Environment Status ===
`),A(q),await k(z,q)}function A(z){if(z.mode==="single-repo")console.log("Mode: Single-repo"),console.log(`  Repo Root: ${z.repoRoot}`),console.log(`  Specs Directory: ${z.specsDir}`),console.log("");else if(z.context==="root")console.log("Mode: Multi-repo (Root)"),console.log(`  Speck Root: ${z.speckRoot}`),console.log(`  Specs Directory: ${z.specsDir}`),console.log("");else if(z.context==="child")console.log("Mode: Multi-repo (Child Repository)"),console.log(`  Context: Child repo (${z.childRepoName})`),console.log(`  Parent Spec: ${z.parentSpecId||"Unknown"}`),console.log(`  Repo Root: ${z.repoRoot}`),console.log(`  Speck Root: ${z.speckRoot}`),console.log("")}async function k(z,q){let K=(await H(z.speckRoot)).size>0,U=j.join(z.repoRoot,".speck","branches.json"),G=!1;try{await T.access(U),G=!0}catch{}if(!G&&!K){console.log("Branch Stack Status: Not enabled"),console.log(""),console.log("To enable stacked PRs:"),console.log("  /speck.branch create <branch-name> --base <base-branch>"),console.log("");return}if(q.mode==="multi-repo"&&q.context==="root"||q.mode==="single-repo"&&K)await C(z.speckRoot,z.repoRoot);else await S(z.repoRoot)}async function C(z,q){console.log(`=== Branch Stack Status (Multi-Repo) ===
`);let D=await $(z,q);if(D.rootRepo)w("Root",D.rootRepo);else console.log("Root Repository: (no branches)"),console.log("");let K=Array.from(D.childRepos.keys()).sort();for(let U of K){let G=D.childRepos.get(U);w(`Child: ${U}`,G)}if(K.length===0&&!D.rootRepo)console.log("No branches found in any repository."),console.log("")}function w(z,q){console.log(`${z}${q.specId?` (${q.specId})`:""}:`);let D=[];if(q.statusCounts.active>0)D.push(`${q.statusCounts.active} active`);if(q.statusCounts.submitted>0)D.push(`${q.statusCounts.submitted} submitted`);if(q.statusCounts.merged>0)D.push(`${q.statusCounts.merged} merged`);if(q.statusCounts.abandoned>0)D.push(`${q.statusCounts.abandoned} abandoned`);if(D.length>0)console.log(`  ${D.join(", ")}`);for(let K of q.chains)if(K.branches.length>0)O(K.branches,q.branches);console.log("")}function O(z,q){if(z.length===0)return;z.forEach((D,K)=>{let U=K===0?"\u2514\u2500":"   \u2514\u2500",G=q.find((Y)=>Y.name===D),V=`  ${U} ${D}`;if(G){if(G.pr)V+=` (${G.status}, PR #${G.pr})`;else if(G.status!=="active")V+=` (${G.status})`}console.log(V)})}async function S(z){console.log(`=== Branch Stack Status ===
`);let q=await _(z);if(q.branches.length===0){console.log("No branches tracked yet."),console.log("");return}let D="";try{D=await v(z)}catch(G){D=""}let K=Object.keys(q.specIndex);for(let G of K){console.log(`Spec: ${G}`),console.log("Branch Stack:");let V=q.specIndex[G]||[],Y=V.map((Q)=>q.branches.find((X)=>X.name===Q)).filter((Q)=>Q!==void 0);Y.filter((Q)=>Q!==void 0&&!V.includes(Q.baseBranch)).forEach((Q)=>{if(!Q)return;console.log(`  ${Q.baseBranch}`),J(Q.name,"  ",!0,Y,D)}),console.log("")}let U=q.branches.filter((G)=>G.status==="active"&&G.pr===null).length;if(U>0)console.log(`\u26A0 ${U} branch(es) may need attention`),console.log("Run /speck.branch status for details"),console.log("")}function J(z,q,D,K,U){let G=K.find((X)=>X.name===z);if(!G)return;let V=D?"\u2514\u2500":"\u251C\u2500",Y=z===U,Z=`${q}${V} ${z}`;if(G.pr)Z+=` (${G.status}, PR #${G.pr})`;else if(G.status!=="active")Z+=` (${G.status})`;if(Y)Z+=" (current)";console.log(Z);let Q=K.filter((X)=>X.baseBranch===z);Q.forEach((X,M)=>{let P=q+(D?"  ":"\u2502 ");J(X.name,P,M===Q.length-1,K,U)})}async function B(z,q){let D={mode:q.mode,context:q.context,speckRoot:q.speckRoot,repoRoot:q.repoRoot,specsDir:q.specsDir};if(q.context==="child")D.childRepoName=q.childRepoName,D.parentSpecId=q.parentSpecId;if(q.mode==="multi-repo"&&q.context==="root"){let K=await $(q.speckRoot,q.repoRoot);D.branchStatus={type:"aggregate",rootRepo:K.rootRepo,childRepos:Object.fromEntries(K.childRepos)}}else try{let K=await _(q.repoRoot);D.branchStatus={type:"local",branches:K.branches,specIndex:K.specIndex}}catch{D.branchStatus={type:"none"}}console.log(JSON.stringify(D,null,2))}export{b as main};
