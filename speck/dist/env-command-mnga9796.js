// @bun
import{a as _,i as $,p as v}from"./speck-7546wgqm.js";import{B as F,E as H,F as W,u as T,x as E}from"./paths-x5kskk5z.js";import I from"fs/promises";import j from"path";async function x(z=process.argv.slice(2)){if(z.includes("--help"))return L(),0;let q=z.includes("--json");try{return await A(q),0}catch(D){if(q)console.error(JSON.stringify({error:D instanceof Error?D.message:String(D)}));else console.error(`Error: ${D instanceof Error?D.message:String(D)}`);return 1}}function L(){console.log(`
Speck Environment Check

Usage:
  bun run .speck/scripts/env-command.ts [options]

Options:
  --help     Show this help message
  --json     Output as JSON (for programmatic use)

Description:
  Displays comprehensive environment information including:
  - Multi-repo configuration
  - Branch stack status (single-repo or aggregate)
  - Feature detection
  - System diagnostics
  `.trim())}async function A(z){let q=await F(),D=await W();if(z)await R(q,D);else await O(q,D)}async function O(z,q){console.log(`=== Speck Environment Status ===
`),k(q),await C(z,q)}function k(z){if(z.mode==="single-repo")console.log("Mode: Single-repo"),console.log(`  Repo Root: ${z.repoRoot}`),console.log(`  Specs Directory: ${z.specsDir}`),console.log("");else if(z.context==="root")console.log("Mode: Multi-repo (Root)"),console.log(`  Speck Root: ${z.speckRoot}`),console.log(`  Specs Directory: ${z.specsDir}`),console.log("");else if(z.context==="child")console.log("Mode: Multi-repo (Child Repository)"),console.log(`  Context: Child repo (${z.childRepoName})`),console.log(`  Parent Spec: ${z.parentSpecId||"Unknown"}`),console.log(`  Repo Root: ${z.repoRoot}`),console.log(`  Speck Root: ${z.speckRoot}`),console.log("")}async function C(z,q){let K=(await H(z.speckRoot)).size>0,Q=j.join(z.repoRoot,".speck","branches.json"),G=!1;try{await I.access(Q),G=!0}catch{}if(!G&&!K){console.log("Branch Stack Status: Not enabled"),console.log(""),console.log("To enable stacked PRs:"),console.log("  /speck.branch create <branch-name> --base <base-branch>"),console.log("");return}if(q.mode==="multi-repo"&&q.context==="root"||q.mode==="single-repo"&&K)await S(z.speckRoot,z.repoRoot);else await f(z.repoRoot)}async function S(z,q){console.log(`=== Branch Stack Status (Multi-Repo) ===
`);let D=await $(z,q);if(D.rootRepo)w("Root",D.rootRepo);else console.log("Root Repository: (no branches)"),console.log("");let K=Array.from(D.childRepos.keys()).sort();for(let Q of K){let G=D.childRepos.get(Q);w(`Child: ${Q}`,G)}if(K.length===0&&!D.rootRepo)console.log("No branches found in any repository."),console.log("")}function w(z,q){console.log(`${z}${q.specId?` (${q.specId})`:""}:`);let D=[];if(q.statusCounts.active>0)D.push(`${q.statusCounts.active} active`);if(q.statusCounts.submitted>0)D.push(`${q.statusCounts.submitted} submitted`);if(q.statusCounts.merged>0)D.push(`${q.statusCounts.merged} merged`);if(q.statusCounts.abandoned>0)D.push(`${q.statusCounts.abandoned} abandoned`);if(D.length>0)console.log(`  ${D.join(", ")}`);for(let K of q.chains)if(K.branches.length>0)B(K.branches,q.branches);console.log("")}function B(z,q){if(z.length===0)return;z.forEach((D,K)=>{let Q=K===0?"\u2514\u2500":"   \u2514\u2500",G=q.find((X)=>X.name===D),U=`  ${Q} ${D}`;if(G){if(G.pr)U+=` (${G.status}, PR #${G.pr})`;else if(G.status!=="active")U+=` (${G.status})`}console.log(U)})}async function f(z){console.log(`=== Branch Stack Status ===
`);let q=await _(z);if(q.branches.length===0){console.log("No branches tracked yet."),console.log("");return}let D="";try{D=await v(z)}catch(G){D=""}let K=Object.keys(q.specIndex);for(let G of K){console.log(`Spec: ${G}`),console.log("Branch Stack:");let U=q.specIndex[G]||[],X=U.map((V)=>q.branches.find((Y)=>Y.name===V)).filter(Boolean);X.filter((V)=>!U.includes(V.baseBranch)).forEach((V)=>{console.log(`  ${V.baseBranch}`),J(V.name,"  ",!0,X,D)}),console.log("")}let Q=q.branches.filter((G)=>G.status==="active"&&G.pr===null).length;if(Q>0)console.log(`\u26A0 ${Q} branch(es) may need attention`),console.log("Run /speck.branch status for details"),console.log("");if(context.mode==="child"&&q.branches.length>0)try{let{findChildRepos:G}=await import("./paths-x5kskk5z.js"),U=context.speckRoot||"";if(!(await G(U)).includes(z))console.log("\u26A0 Orphaned tracking detected:"),console.log(`  ${q.branches.length} branch(es) tracked but repo unlinked from parent spec`),console.log(`  Parent: ${U}`),console.log("  Fix: Re-link with /speck.link or archive .speck/branches.json"),console.log("")}catch{}}function J(z,q,D,K,Q){let G=K.find((Y)=>Y.name===z);if(!G)return;let U=D?"\u2514\u2500":"\u251C\u2500",X=z===Q,Z=`${q}${U} ${z}`;if(G.pr)Z+=` (${G.status}, PR #${G.pr})`;else if(G.status!=="active")Z+=` (${G.status})`;if(X)Z+=" (current)";console.log(Z);let V=K.filter((Y)=>Y.baseBranch===z);V.forEach((Y,M)=>{let P=q+(D?"  ":"\u2502 ");J(Y.name,P,M===V.length-1,K,Q)})}async function R(z,q){let D={mode:q.mode,context:q.context,speckRoot:q.speckRoot,repoRoot:q.repoRoot,specsDir:q.specsDir};if(q.context==="child")D.childRepoName=q.childRepoName,D.parentSpecId=q.parentSpecId;if(q.mode==="multi-repo"&&q.context==="root"){let K=await $(q.speckRoot,q.repoRoot);D.branchStatus={type:"aggregate",rootRepo:K.rootRepo,childRepos:Object.fromEntries(K.childRepos)}}else try{let K=await _(q.repoRoot);D.branchStatus={type:"local",branches:K.branches,specIndex:K.specIndex}}catch{D.branchStatus={type:"none"}}console.log(JSON.stringify(D,null,2))}export{x as main};
